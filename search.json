[{"title":"动态链接库、静态链接库","path":"/posts/动态链接库、静态链接库.html","content":"一、什么是链接库有时候我们对外提供功能的时候，可能不希望对方看到源码，我们就可以制作成库文件，把库文件和头文件给到对方就可以达到提供功能又不暴露源码的目的。链接库就是指将库文件编译后打包为一个二进制文件，这些二进制文件会在程序调用的时候加载到内存中。实际上，一个或多个源文件编译为目标文件后，这个文件中所引用的外部的符号需要通过链接来找到这部分缺失的地址。而链接的方式又分为两种，如果是在生成可执行文件之前就已经把所有的链接操作完成了，这种链接称为静态链接，这种库文件称为静态链接库；如果是在程序执行的时候才进行链接，这种称为动态链接，对应的库文件称为动态链接库。也正因为如此，使用静态库时生成的可执行文件是可以独立运行的，因为他不再需要外部的内容，而动态库编译生成的可执行文件就无法单独运行，因为他在运行时，才会去链接所引用的外部地址。 1. 静态链接库静态库会直接加载到代码段，他和所有的目标文件一起链接成可执行文件，生成可执行文件后可以独立运行。但是，正因为静态库会直接加载到内存的代码段，可执行文件的内部都拷贝了所有目标文件和静态库的指令和数据，编译生成的可执行文件会比较大。并且，如果整个系统中有多个链接统一静态库的可执行文件时，每个可执行文件都要拷贝一份静态库的指令和数据，这就造成了空间浪费，因为他们拷贝的数据都是同样的内容。最后，如果一旦静态库文件有代码更新，就需要重新编译链接重新生成整个可执行文件，更新升级麻烦。在 Linux 系统中，静态链接库文件的名称通常为 libxxx .a，在 Windows 系统中，静态链接库文件的后缀名为 .lib。 2. 动态链接库其实，动态库这个称呼本身是对 Windows 平台上动态链接所用的库文件的一种称呼，在 Linux 下，一般称为共享库。动态库是在运行时加载到内存的共享库段，这样，如果很多程序都要用到静态库的时候，就会节省大量内存，因为它不像静态库那样加载到代码段，而是是在运行时载入内存的共享库段，当多个程序要用到同一个动态库时，所有程序可以共享这个共享库段的指令和数据。动态链接的实现是这样的，在编译时首先由静态链接器将所有的目标文件链接为一个可执行文件，等到程序运行时会将要用到的动态库加载到内存的共享库段，由动态链接器完成可执行文件和动态库文件的链接工作，可以理解为按需载入内存（在需要用到的时候，才会载入内存）。动态库大大方便了程序的升级和更改，只要用新的动态库文件替换旧的动态库文件即可，在运行时，会自动连接新的库文件。但是正因为动态库运行时载入的这个特点，使用动态库的可执行文件在运行时，会略慢一些，但整体来说，运行速度的性能损失，远远小于内存节省带来的收益。在Linux系统中，动态链接库的名称通常为 libxxx.so，在 Windows 系统中，动态链接库的后缀名为 .dll。GCC 编译器在生成可执行文件时，默认会优先使用动态链接库完成链接，如果当前系统环境中没有程序文件所需要的动态链接库，GCC 便会选择静态链接库进行静态链接。如果两种库文件都没有找到，则链接失败。 3. 库文件与头文件我们在发布库文件的同时，要将库文件和头文件一起发布，头文件中存储了变量、函数或者类等这些功能模块的声明部分，库文件中存储了各模块具体的实现部分。也就是说，头文件中定义了调用库文件中功能模块的接口。头文件的存在也实现了这样一种功能，当我们对外提供功能时，可以通过库文件来隐藏源码实现，功能的使用方只需要根据头文件所提供的接口来调用功能模块即可。 4. 库文件的引用当我们使用 GCC 编译和链接程序时，GCC 默认会链接 libc.a 或者 libc.so这两个标准库，但是对于其他的库（非标准库、第三方库等），就需要手动去添加链接库。通过 GCC -l 选项来指定库名，直接在 -l 后面加库名即可。（ -l 是小写的 L ）正常情况下，我们指定了要使用的库名时，GCC 会自动在标准库目录中搜索文件，例如在CentOS中是 &#x2F;usr&#x2F;lib 目录。但是，如果想链接位于其它目录中的库，比如说我们自己建的库，或者我们要引用别人提供的库，就需要在编译时显示指定库的路径。指定方法有三种：① 像指定普通头文件的路径一样，为 GCC 显示指定该库文件的完整路径与文件名 -I &#x2F;目录名 。② 通过 GCC 的 -L 选项，为GCC增加搜索目录，可以使用多个 -L 选项，或者在一个选项内使用冒号 : 分割来指定多个搜索路径。③ 把库文件所在的目录加到环境变量 LIBRARYPATH 中。 二、自己动手制作静态链接库准备工作，共准备4个文件，目录结构如下 my_print.h 文件内容如下 123456789101112#ifndef _TEST_H#define _TEST_H#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;void print_array_int(int* array, int len);void print_array_char(char* array, int len);void print_array_string(char* array[], int len);void print_hello();#endif my_print.c 文件内容如下 12345678910111213141516171819202122232425262728293031323334#include &quot;my_print.h&quot; void print_array_int(int* array, int len)&#123; int i = 0; printf(&quot;array: &quot;); for(i = 0; i &lt; len; i++) &#123; printf(&quot;%d &quot;, array[i]); &#125; printf(&quot; &quot;);&#125; void print_array_char(char* array, int len)&#123; i = 0; printf(&quot;array: &quot;); for(i = 0; i &lt; len; i++) &#123; printf(&quot;%c &quot;, array[i]); &#125; printf(&quot; &quot;);&#125;void print_array_string(char* array[], int len)&#123; int i = 0; printf(&quot;array: &quot;); for(i = 0; i &lt; len; i++) &#123; printf(&quot;%s &quot;, array[i]); &#125; printf(&quot; &quot;);&#125; main.c 文件内容如下 12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; #include &quot;my_print.h&quot; int main()&#123; int a1[10]; int i = 0; for(i = 0; i &lt; 10; i++) &#123; a1[i] = i + 1; &#125; print_array_int(a1, 10); print_hello(); return 0;&#125; print_hello.c 文件内容如下 123456#include &quot;my_print.h&quot; void print_hello()&#123; printf(&quot;hello Linux ... &quot;);&#125; 1. 静态库的制作① 首先把所有 .c 文件编译为 .o 文件 1gcc -c *.c -I ../header/ 一定要从 .o 文件去生成 .a 文件，否则即使你生成了库，在使用时也可能出现未知的错误。② 将 .o 文件打包为 .a 文件这一步需要使用 ar 工具来完成。ar 工具是用来创建, 修改和提取档案的工具，ar 是 archive 的缩写。归档是指将多个文件（或一个文件）放到单个文件中，不进行其他额外的操作。也就是说，归档并不等同于压缩，压缩会使文件的大小减小。 1ar rcs libmprint.a *.o 参数 r ：在库中插入模块（替换）。当插入的模块名已经在库中存在，则替换同名的模块。如果若干模块中有一个模块在库中不存在，ar 显示一个错误消息，并不替换其他同名模块。默认的情况下，新的成员增加在库的结尾处，可以使用其他任选项来改变增加的位置。 参数 c ：创建一个库。不管库是否存在，都将创建。 参数 s ：创建目标文件索引，这在创建较大的库时能加快时间。如果不需要创建索引，可改成大写 S 参数。如果 .a 文件缺少索引，可以使用 ranlib 命令添加）。 一般我们命令静态库的时候是这样的，前面是 lib 中间加上我们自己给静态库文件的名称，后面加后缀 .a ，也就是 libxxx.a ，实际上， xxx 才是静态库文件的名称。 可以查看一下生成的 libmprint.a 的内容，一堆乱码 我们可以用 nm 命令查看库文件的信息，可以看到它是由 my_print.o 和 print_hello.o 生成的。 2. 静态库的使用静态库的使用方法 1gcc main.c -o exe -lmyprint -L ../lib/ -I ../header/ 首先对上面的命令进行分解一下，-lmyprint 用于指定链接库的名字，我们上面生成了一个名为 libmprint.a 的静态库，把前缀后缀去掉留下中间的名字即可；-L …&#x2F;lib&#x2F; 指定静态库的搜索目录，不指定的会，编译器只会去默认的链接库搜索路径寻找；-I …&#x2F;header&#x2F; 这个就比较熟悉了，指定头文件的路径。 我们再发布的时候，只需要把 header 和 lib 发布给别人即可 三、自己动手制作动态链接库1. 动态库的制作① 编译生成与位置无关的 .o 文件动态共享库是在运行的时候才加载的，它加载到内存的共享库段，用完后就释放，所以要编译为与位置无关的。这里要用到GCC 的 -fPIC 选项参数，该选项表示编译为位置独立的代码，如果不用这个选项的话编译后的代码是位置相关的，所以动态载入的时候会通过代码拷贝的方式来满足不同进程的需要，而不能达到真正代码段共享的目的。在静态链接库中，可执行文件在链接时就知道每一行代码、每一个变量会被放到线性地址空间的什么位置，因此这些地址可以都作为常数写到代码里面。对于动态库，只有加载的时候才知道。也就是说，动态链接库要编译为与位置无关的代码，这样只有在运行时才直到代码的位置。而静态库是在生成可执行文件之前，就直接把代码加载到内存的代码段了，代码的位置等信息也就已经知道了，所以不需要生成与位置无关的代码。 1gcc -fPIC -c *.c -I ../header/ ② 将 .o 文件打包这里要用到 GCC 的 -shared 选项，该选项指定生成动态连接库（让连接器生成T类型的导出符号表，有时候也生成弱连接W类型的导出符号），如果不用该标志的话外部程序将无法连接。可以在动态库文件名后面加版本号 libxxx.so.主版本号.副版本号 ，比如 libmdprint.so.1.1 表示我这是 1.1 版本的动态库，文件后缀后面的数字就是版本号的意思。 1gcc -shared *.o -o libmdrint.so 2. 动态库的使用（1）加载动态库使用动态库的命令和使用静态库的命令一样 1gcc main.c -o exe -lmdrint -L ../lib/ -I ../header/ （2）“加载共享库出错”的解决方法这个是时候，虽然我们已经生成了可执行文件，但是当我们运行可执行文件的时候，可能会出现这样的错误 我们可以通过命令 ldd 来查看一下可执行文件的链接情况 在我们自己引入的库 libmdrint.so 一栏显示 “not found” ，在默认情况下，我们自己引入的动态库是无法使用的，需要进行一些配置。这里提供以下几种解决方法。 ① 在系统库路径下建立软链接前面我们已经介绍了，GCC 会默认去系统库路径下搜索库文件，所以只要我们把自己的库文件放到这个目录下就可以了，系统库的路径是 &#x2F;usr&#x2F;lib 或 &#x2F;lib 。但是我们实际操作的时候，可能无法把文件拷贝到这两个路径下，我们可以在系统库路径下建立一个软链接来指向我们的库文件（软链接相关知识请参考本人 Linux 专栏文章《【Linux王者之路基础篇：基本命令与基础知识】Linux常用shell命令（及相关知识）详解与用法演示》） 1sudo ln -s /home/qq/dm/dm_lib/lib/libmdrint.so /usr/lib/libmdrint.so 这里第一个路径也就是我们自己的动态库文件所在目录，一定要用绝对路径（如果使用相对路径，会找不到该路径），第二个路径是系统库的路径。 ② 配置环境变量实际上， ld 链接器在寻找库路径的时候，都是通过一个环境变量 LD_LIBRARY_PATH 来寻找的，我们可以打印看一下这个环境变量 我们可以通过 export 命令来给环境变量增加一个路径，只需要把自己的路径加进去即可，命令如下 1export LD_LIBRARY_PATH=/home/qq/dm/dm_lib/lib/:$LD_LIBRARY_PATH 我们知道在 shell 下直接把绝对路径加到环境变量中，只是一种临时的环境变量，当关机再次开机的时候，就会失效，如果想要永久有效，可以修改配置文件。我们可以把上面这条命令放到 .bashrc 文件中。在我的 Linux 专栏文章中，已经不只一次提到 .bashrc 这个配置文件了，其实 Linux 每次开机都会执行这个配置文件，我们实现环境变量永久有效的原理就是，Linux 每次开机都会执行 .bashrc 配置文件，而配置文件中包含设置环境变量的命令，所以每次开机都会配一下环境变量，这样就达到了环境变量永久有效的目的。.bashrc 配置文件在家目录下 1vim ~/.bashrc ③ 修改 ld.so 加载器的配置文件 ld.so.conf这里先介绍几个概念： ld链接器 ：gcc 可以在编译周期传递参数，指定需要链接的库文件，生命周期是在 compile-time。 ld.so动态链接器&#x2F;加载器，程序运行的时候会根据指定的路径去加载指定的库，生命周期是在 run-time。 ld.so加载器及配置文件ld.so.conf：指定动态链接库的搜索路径（也可以通过配置环境变量$LD_LIBRARY_PATH 来指定程序运行时的动态库.so文件的搜索路径）。使用 ldconfig 就可以将 ld.so.conf 中的指定目录的库文件加载到内存中，并记录在&#x2F;etc&#x2F;ld.so.cache文件中。配置文件 &#x2F;etc&#x2F;ld.so.conf 记录了编译时使用的动态链接库的路径，在默认情况下，编译器只会使用 &#x2F;lib 和 &#x2F;usr&#x2F;lib 这两个目录下的库文件，通过这个配置文件可以增加我们自己的动态库文件搜索路径。 使用 vim 编辑器打开配置文件，把路径放进去 1sudo vim /etc/ld.so.conf 放入路径之后，还要在 shell 下执行一条命令，使刚才的配置生效 1sudo ldconfig -v 不管使用上面三种方法的哪种，都可以使动态库正常加载到可执行文件中，我们再次使用 ldd 命令查看 exe 文件，可以看到，我们的动态库 libmdrint.so 后面由原来的 “not found” 变成了一个路径，这说明加载器现在可以找到动态库的路径了，可执行文件 exe 也就可以运行了。","tags":["C语言"],"categories":["C语言"]},{"title":"预处理、编译、汇编、链接","path":"/posts/预处理、编译、汇编、链接.html","content":"C语言经典的 “hello world ” 程序，伴随着每个程序员一起步入编程世界的大门。从编写、编译到运行，看到屏幕上输出的“hello world ”，那么你知道它都经历了什么吗？今天我们就来聊聊这个话题。 一、从hello.c聊起hello world.c 123456#include &lt;stdio.h&gt;int main() &#123; printf(&quot;hello,world! &quot;); return 0;&#125; 在linux下，使用 gcc 编译hello.c源文件，会在当前目录下默认生成 a.out 可执行文件，在终端输出hello，world！。 123$ gcc hello.c$ ./a.out$ hello,world! 预编译器、汇编器as、链接器ld，实际上gcc 命令只是对这些不同程序的封装，根据不同的参数去调用不同的程序。 从 hello.c 到可执行文件的全过程，可分为4个步骤： 1、预处理gcc -E hello.c -o hello.i 得到预处理文件，其中，-E 表示只进行预编译。源文件在预编译阶段会被编译器生成.i文件，主要处理源代码文件中以“#”开头的预编译指令。如：宏定义展开，将被包含的文件插入到该编译指令的位置等。 2、编译gcc -S hello.i -o hello.s 得到汇编文件，其中，-S 表示生成汇编文件。编译就是把预处理完的文件，进行语法分析、词法分析、语义分析及优化后生成相应的汇编代码文件，这个过程是整个程序构建的核心过程，也是最复杂的部分。 3、汇编as hello.s -o hello.o 或者 gcc -c hello.s -o hello.o，其中，-c 表示只编译不链接。将汇编代码文件转变成机器可以执行的指令文件，即目标文件。也可以直接使用：gcc -c hello.c -o hello.o 经过预处理、编译、汇编直接输出目标文件。为什么汇编器不直接生成可执行程序，而是一个目标文件呢？为什么要链接？这个我们后面会详细讨论。 4、链接随着代码量的增多，所有代码若是都放在同一个文件里，那将是一场灾难。现代大型软件，动辄由成千上万的模块组成，每个模块相互依赖又相互独立。将这些模块组装起来的过程就是链接。这些模块如何形成一个单一的程序呢？无非就是两种方式：1、模块间的函数调用；2、模块间的变量访问。函数访问必须知道函数地址，变量访问必须知道变量地址，所以终归到底就是一种方式，不同模块间符号的引用。","tags":["C语言"],"categories":["C语言"]},{"title":"内存申请函数","path":"/posts/内存申请函数.html","content":"一、malloc函数原型： 1void* malloc (size_t size); 这个函数向内存申请一块连续可用的空间，并返回指向这块空间的指针； 如果开辟成功，返回一个指向开辟的空间的首地址的指针； 如果开辟失败，返回一个NULL指针，因此malloc函数的返回值，一定要做检查； 返回值的类型时void*，所以malloc函数并不知道开辟空间的类型，具体在使用时由使用者自己决定（强制转换）； 如果参数size为0，malloc函数的行为是标准未定义的，取决于编译器； 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;int main()&#123; int arr[10] = &#123; 0 &#125;; int* p = (int*)malloc(sizeof(arr));//动态内存开辟； if (p == NULL) &#123; perror(&quot;malloc&quot;);//是空指针则输出错误代码； return 1;//终止程序； &#125; for (int i = 0; i &lt; 10; i++) &#123; *(p + i) = i;//赋值； &#125; for (int i = 0; i &lt; 10; i++) &#123; printf(&quot;%d &quot;, *(p + i));//输出 &#125; //没有使用 动态内存释放函数 free ，此时如果程序继续运行，则被malloc函数开辟的空间不会被回收； //但只要程序退出，系统会自动回收内存空间； //正常情况下，由动态内存开辟函数所开辟的内存空间，在使用完成后必须被释放并销毁； free(p);//将p空间中的值销毁； p = NULL;//p不再指向有效空间； return 0;&#125; 二、calloc函数原型： 1void* calloc(size_t num,size_t size); 函数的功能是为num个大小为size的元素开辟一块空间，并将空间的每个字节初始化为0； 与函数malloc的区别在于，calloc会在返回地址前把申请的空间的每个字节初始化为全0； 1234567891011121314151617#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;int main()&#123; int* p = (int*)calloc(10, sizeof(int));//动态内存开辟； if (p == NULL) &#123; perror(&quot;calloc&quot;);//是空指针则输出错误代码； return 1;//终止程序； &#125; for (int i = 0; i &lt; 10; i++) &#123; printf(&quot;%d &quot;, *(p + i));//输出为：0 0 0 0 0 0 0 0 0 0； &#125; free(p);//将p空间中的值销毁； p = NULL;//p不再指向有效空间； return 0;&#125; 三、realloc函数原型： 1void* realloc(void* ptr,size_t size); ptr是需要调整的内存地址，size是调整之后的空间大小； 返回值为调整后的内存的起始地址； 函数在调整原内存空间大小的基础上，还会将原来内存中的数据移动到新的空间； &#x2F;&#x2F;对于内存空间的调整，存在两种情况： 1.原有空间之后的空间足够满足新空间的开辟； 2.原有空间之后没有足够大的空间满足新空间的开辟； &#x2F;&#x2F;函数调整失败的情况： 1.realloc失败的时候，返回NULL； 2.realloc失败的时候，原来的内存不改变，不会释放也不会移动； &#x2F;&#x2F;注意使用realloc函数改变或开辟空间，最好使用新的变量接收，再将新变量赋值给旧变量；原因是为了避免开辟空间失败返回空指针，导致的旧空间内存泄漏(指针被置空，无法找到旧空间)； 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;int main()&#123; int* p = (int*)malloc(40);//开辟40字节空间赋予p； if (p == NULL) &#123; perror(&quot;malloc&quot;); return 1; &#125; for (int i = 0; i &lt; 10; i++) &#123; *(p + i) = i + 1; &#125; int* ptr = realloc(p, 80);//扩容；此时，如果后续内存空间足够，则空间首地址不会改变，但如果后续内存空间不足，则会发现空间首地址改变，即新空间的开辟； if (ptr != NULL) &#123; p = ptr;//扩容成功则将扩容后的空间赋予p； ptr = NULL;//ptr不再指向有效空间； &#125; else &#123; perror(&quot;realloc&quot;); return 1; &#125; for (int i = 10; i &lt; 20; i++)//为扩容后的空间赋值； &#123; *(p + i) = i + 1; &#125; ptr = realloc(p, 40);//缩容； if (ptr != NULL) &#123; p = ptr;//缩容成功则将扩容后的空间赋予p； ptr = NULL;//将ptr置空； &#125; for (int i = 0; i &lt; 20; i++)//为扩容后的空间赋值； &#123; printf(&quot;%d &quot;, p[i]); &#125; free(p);//将p空间中的值销毁； p = NULL;//p不再指向有效空间； return 0;&#125;","tags":["C语言"],"categories":["C语言"]},{"title":"字符串函数","path":"/posts/字符串函数.html","content":"一、strlen1、原型：size_t strlen(char const* string);2、功能：返回字符串 string 的长度（不包含字符串终止符NUL）3、注意：size_t是一个无符号整数类型 二、strcpy1、原型：char *strcpy(char *dst, char const *src); 2、功能：将参数src字符串复制到dst参数中。如果参数src和dst在内存中出现重叠，其结果是未定义的。由于dst参数将进行修改，所以它必须是个字符数组或者是一个指向动态分配内存的数组的指针，不能使用字符串常量。返回参数dst的一份拷贝。 3、注意： 目标参数dst的以前内容将被覆盖并丢失。即使新的字符串比dst原先的内存更短，由于新字符串是以NUL字符结尾，所以老字符串最后剩余的几个字符也会被有效的删除。如果字符串比数组长，多余的字符仍被复制，它们将覆盖原先存储于数组后面的内存空间的值。所以必须保证目标字符数组的空间足以容纳需要复制的字符串。 三、strncpy1、原型：char *strncpy(char *dst, char const *src, size_t len); 2、功能：和strcpy一样，strncpy把源字符串的字符复制到目标数组。然而，它总是 正好向dst写入len个字符。如果strlen(src)的值小于len, dst数组就用额外的NUL字节填充到len长度。如果strlen(src)的值大于或者等于len,那么只有len个字符被复制到dst中。 3、注意：strncpy调用的结果可能不是一个字符串，它的结果将不会以NUL字符结尾， 因此字符串必须以NUL字符结尾 四、strcat1、原型：char *strcat(char *dst, char const *src); 2、功能：将一个字符串添加(连接)到另一个字符串的后面。 3、注意：src和dst的所指的内存区域不能重叠，如果发生重叠，其结果是未定义的。 五、strncat1、原型：char *strncat(char *dst, char const *src, size_t len); 2、功能：它从src最多复制 len个字符到dst中。但是, strncat总是在结果字符串后面添加一个NUL字符。 3、注意：src和dst所指的内存区域不能重叠，并且dst必须有足够多的空间来容纳src的字符串。 六、strcmp1、原型：int strcmp(char const *s1, char const *s2); 2、功能：比较两个字符串。如果s1小于s2，strcmp函数返回一个小于零的值。如果s1大于s2，函数返回一个大于零的值。如果两个字符串相等，函数就返回零。 3、注意：由于strcmp并不修改它的任何一个参数，所以不存在溢出字符数组的危险。但是，和其他不受限制的字符串函数(strcpy, strcat)一样，strcmp函数的字符串参数也必须以一个NUL字符结尾。如果并非如此，strcmp就可能对参数后面的字符进行比较，这个比较结果将不会有什么意义。 七、strncmp1、原型：int strncmp(char const *s1, char const *s2, size_t len); 2、功能：和strcmp一样，也用于比较两个字符串，但它最多比较 len 个字节。如果两个字符串在第 len 个字符之前存在不相等的字符，这个函数就像strcmp一样停止比较，返回结果。如果两个字符串的前len 个字符相等，函数就返回零。 八、strchr、strrchr1、原型：char *strchr(char const *str, int ch); char *strrchr(char const *str, int ch); 2、功能：在一个字符串中查找一个特定字符。 3、注意：第2个参数是一个整型值。但是，它包含了一个字符值。strchr在字符串str中查找字符ch第一次出现的位置，找到后函数返回一个指向该位置的指针。如果该字符并不存在于str中，函数就返回一个NULL指针。strrchr的功能和strchr基本一致，只是它所返回的是一个指向字符串中该字符最后一次出现的位置(最右边那个)。 九、strpbrk1、原型：char *strpbrk(char const *str, char const *group); 2、功能：这个函数返回一个指向str中第1个匹配group中任何一个字符的字符位置。如果未找到匹配，函数返回一个NULL指针。 十、strstr1、原型：char *strstr(char *s1, char *s2); 2、功能：这个函数在s1中查找整个s2第1次出现的起始位置，并返回一个指向该位置的指针。如果s2并没有完整地出现在s1的任何地方，函数将返回一个NULL指针。如果第2个参数是一个空字符串，函数就返回s1。 十一、strtok1、原型：char *strtok(char *str, char const *sep); 2、功能：分解字符串str为一组字符串，分隔符为sep。 3、注意：如果strtok函数的第1个参数不是NULL，函数将找到字符串的第1个标记。strtok同时将保存它在字符串中的位置。如果strtok函数的第1个参数是NULL，函数就在同一个字符串中从这个被保存的位置开始像前面一样查找下一个标记。如果字符串内不存在更多的标记，strtok函数就返回一个NULL指针。在典型情况下，在第1次调用strtok时，向它传递一个指向字符串的指针。然后，这个函数被重复调用（第1个参数为NULL），直到它返回NULL为止。 1234567891011121314#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main()&#123; char whitespace[] = &quot; &quot;; char *token; char line[] = &quot;I love you&quot;; for (token = strtok(line, whitespace); token !=NULL; token = strtok(NULL, whitespace)) &#123; printf(&quot;Next token is |%s| &quot;, token); &#125; return 0;&#125;","tags":["C语言"],"categories":["C语言"]},{"title":"指针","path":"/posts/指针.html","content":"1、C语言的精髓–指针指针就是地址，在一定程度上可以把数组名就看成一个特殊的指针,指针也就是一个变量而已，指针全名指针变量。 （1）指针数组指针数组，是个数组，里边放的东西都是指针。char *p[2]=&#123;&quot;china&quot;,&quot;linux&quot;&#125;; 仔细来说，从运算符优先级来看，[]的优先级比*高，所以p先和[]结合。所以这就是个数组，再与指针结合，所以叫指针数组。 二重指针可以指向指针数组。 （2）数组指针数组指针，是个指针，指向数组的指针. 12int a[2][5]=&#123;0&#125;; int (*p)[5]=a; //指向二维数组 int b[2][3][4] = &#123;0&#125;; // 多维数组 int(*q)[3][4] = b; 这里指针是在()中放着，())和[]优先级都是最高的，结合性是从左向右，所以先与*结合，这是个指针，然后与[]结合，就是指针数组。 （3）函数指针1int (*p)(int a,char b);// 函数指针p指向返回值类型为int的，两个参数为int和char的函数 使用方法如下， p(a,b); 或者 (*p)(a,b); void *类型可以指向任何一个类型的指针 void (*signal(int sig, void (*func) (int))) (int) signal仍然是一个函数，他返回一个函数指针，这个指针指向的函数没有返回值，只有一个int类型的参数 （4）二维数组a[5][7];//用指针访问就是*（*（p+5）+7） int (*p)[7]=a; （5）字符数组与指向字符串指针的问题其中char *p=&quot;linux&quot; 这种情况字符串Linux只存在于只读数据段中（rodata），所以p所指向的内容不可以被更改，如*（p+1）=a;这是实现不了的，但是可以更改指针p 指向的地址，例如p&#x3D;”mengchao”,但是这里的p&#x3D;”mengchao”这段话放在子函数中是不可以的，字符串mengchao是存在于栈中，子函数结束就被释放了，不能够达到改变的目的。可以使用二重指针来实现。 char p[]&#x3D;”linux” 这个是字符数组，相当于初始化数组，可以更改内容，如p[1]&#x3D;’a’;* 这里Linux存在于栈上 所以有的字符串操作函数例如​​char *strcat(char *dst,char const *src);​​前面的参数dst,需要修改，只能传数组，不能直接传一个字符串，因为字符串不可改变 所以想修改字符串，请将他放在字符数组中。 另外关于这个程序 12345678char c = &#x27;a&#x27;; char *p = &amp;c;char *q = &quot;china&quot;; printf(&quot;%p &quot;,p); //006DFEE7 printf(&quot;%c &quot;,*p); //a cout &lt;&lt; *p &lt;&lt; endl; //a printf(&quot;%p &quot;,q); //004B9024 printf(&quot;%s &quot;,q); //china cout &lt;&lt; q &lt;&lt; endl; //china cout &lt;&lt; *q &lt;&lt; endl; //c 这里想插一句关于strlen和sizeof的区别。比如我们定义char buf[100]&#x3D;{“helloworld”}; strlen(buf);就是里边字符串的长度，而sizeof(buf);就是数组长度100. 一定程度上可以认为一级指针与一维数组名等价，二级指针与指针数组名等价，数组指针与二维数组名等价。而二级指针和二维数组名没有一毛钱关系。 （6）数组名数组名可以看成是首元素的首地址，也可以当成一个整体来看。数组名是常量，才可以唯一的确定数组元素的起始地址。设有一维数组int a[5]: a[1] = *(a+1); //a代表首元素首地址,加1跨度为int大小为4 对一维数组名和二维数组名引用(取地址)对一维数组名进行引用会将使其升级为二维数组名。 (&amp;a+1)//这个东西加1，加的大小是整个数组的大小，是20. 二维数组名解引用，降维为一维数组名。二维数组名是首元素首地址，设有int a[4][3],则 *(a+1) //代表的是二维数组的第二维 a[1][2] = *(*(a+1)+2) 注意下面的问题 1234567*p++：等同于：*p; p += 1;先运算再++ 解析：实际上*p++符号整体对外表现的值是*p的值，运算完成后p再加1. 【注意】是运算后p再加1，而不是p所指向的变量*p再加1 *++p：等同于 p += 1; *p;先++再运算 解析：由于++在p的前面，++前置的含义是，先加1，得到一个新的p（它的值是原来p的值加1）。然后这个新的p再与前面的*结合. 【总结】无论是*p++还是*++p，都是指针p += 1，即p的值+1，而不是p所指向的变量*p的值+1。 ++前置与++后置，只是决定了到底是先p += 1，还是先*p。++前置表示先p += 1，再*p。++后置表示先*p，在p += 1； --前置与--后置的的分析方法++前置与++后置的一样。 2、进程空间 123全局变量：不初始化的默认为0，放在.bss段，初始化为0的也放在.bss段 初始化为非0的全局变量放在.data段中，生命周期全局 局部变量放在栈上，当调用结束，生命周期结束 3、结构体《道德经》 曰：”一生二，二生三，三生万物”。结构体用关键字 struct 定义，表达出多个不同变量在一起的类型。我们由此可以使用struct自定义几乎所有想要的类型。 结构体的定义： 12345678struct student&#123; char name[30]; char sex; int age; float high;&#125;stu1;//这里定义了一个变量stu1struct student stu2;//这里定义了一个变量stu2 这种定义出来的结构体类型在定义变量时必须跟着struct，就像struct student stu1;一样，我们引入typedef，避免这种情况。 12345678typedef struct student&#123; char name[30]; char sex; int age; float high;&#125;STUDENT;//将struct student类型重命名为STUDENTSTUDENT stu, stu2;//使用STUDENT替换struct student定义变量 结构体变量初始化及成员访问定义的结构体变量用点成员运算符（.）访问成员变量，比如stu.sex就这样访问成员变量。如果是结构体类型的指针变量则使用-&gt;访问成员变量。STUDENT stu; stu-&gt;sex = &#39;x&#39;;初始化大概有三种方法。 举例： 12345typede struct block &#123; char name[32]; int type; int size; &#125;block; 方法一： 1block test = &#123;&quot;version&quot;, 1, 32&#125;； 需要注意对应的顺序，不能错位。 方法二： 1234block test; test.name = &quot;version&quot;; test.type = 1; test.size= 3; 方法三： 12345block test = &#123; .type= 1, .size = 12, .name= &quot;version&quot; &#125;; 结构体大小设计内存对齐 1234567struct Date &#123; char a; int b; int64_t c; char d;&#125;; Date data [2][10]; 结构体所占的内存大小 a.整体所占的内存大小应该是结构中成员类型最大的整数倍，此处最大的类型是int_64t，占8个字节。即最后所占字节的总数应该是8的倍数，不足的补足 b.数据对齐原则-内存按结构体成员的先后顺序排列，当排到该成员变量时，其前面所有成员已经占用的空间大小必须是该成员类型大小的整数倍，如果不够，则前面的成员占用的空间要补齐，使之成为当前成员类型的整数倍。假设是地址是从0开始，结构体中第一个成员类型char型占一个字节，则内存地址0-1，第二成员从2开始，int型所占内存4个字节根据原则b，第一个成员所占内存补齐4的倍数，故第一个成员所占内存:1＋3＝4；第二个成员占5-8.第三个成员占8个字节，满足原则b，不需要补齐，占9-16第四个成员占一个字节，占17.故总内存为1＋3＋4＋8＋1＝17个字节，但根据原则1总字节数需是8的倍数，需将17补齐到24.故此结构体总字节数为:24字节 4、一些关键字的详解inline在c&#x2F;c++中，为了解决一些频繁调用的小函数大量消耗栈空间（栈内存）的问题，特别的引入了inline修饰符，表示为内联函数。栈空间就是指放置程序的局部数据（也就是函数内数据）的内存空间。 inline的使用是有所限制的，inline只适合涵数体内代码简单的涵数使用，不能包含复杂的结构控制语句例如while、switch，并且不能内联函数本身不能是直接递归函数（即，自己内部还调用自己的函数）。 inline函数仅仅是一个对编译器的建议，所以最后能否真正内联，看编译器的意思，它如果认为函数不复杂，能在调用点展开，就会真正内联，并不是说声明了内联就会内联，声明内联只是一个建议而已。 inline函数的定义放在头文件中其次，因为内联函数要在调用点展开，所以编译器必须随处可见内联函数的定义，要不然就成了非内联函数的调用了。所以，这要求每个调用了内联函数的文件都出现了该内联函数的定义。 因此，将内联函数的定义放在头文件里实现是合适的，省却你为每个文件实现一次的麻烦。 声明跟定义要一致：如果在每个文件里都实现一次该内联函数的话，那么，最好保证每个定义都是一样的，否则，将会引起未定义的行为。如果不是每个文件里的定义都一样，那么，编译器展开的是哪一个，那要看具体的编译器而定。所以，最好将内联函数定义放在头文件中。 注：之所以定义放在头文件中，是因为inline是在编译阶段展开的，并不是连接源文件。 staticstatic别的东西不想说，就说static在修饰局部变量的时候，函数结束此时局部变量并不会被释放，并且修饰的局部变量的值是一直保存的，类似于全局变量，但是还是只能在这个函数内才能访问 constconst又叫常变量，修饰的变量一般不能被更改。但是在C语言中这是假的，通过定义一个指针，修改指针指向的内存依旧可以更改const修饰的变量。在C++中才是真正的const，无法修改。 const一般出现在参数列表中，意味着这个变量在函数中并不会被修改，是输入型参数。 volatile这个volatile，英文名易变的。因为访问寄存器要比访问内存单元快的多,所以编译器一般都会作减少存取内存的优化，但有可能会读脏数据。当要求使用volatile声明变量值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。 精确地说就是，遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问；如果不使用valatile，则编译器将对所声明的语句进行优化。 5、多文件编程一个简单的例子 全局变量最好声明为 static，只在当前文件中可见，不要对外暴露；如果必须对外暴露，可以使用宏定义代替，全局变量最好只在本文件内使用，如果其他文件必须使用，最好封装get接口set接口，请看下面的代码。 main.c 源码： 1234567891011#include &lt;stdio.h&gt;#include &lt;conio.h&gt;#include &quot;module.h&quot;int main()&#123; int n1 = 1, n2 = 100; printf(&quot;从%d 加到%d 的和为%ld [By %s]&quot;, n1, n2, sum(n1, n2), OS); getch(); return 0;&#125; module.c 源码：如果使用了头文件中的宏定义，这里也是需要包含头文件的 123456789101112131415161718#include &lt;stdio.h&gt;#include &quot;module.h&quot;long sum(int fromNum, int endNum)&#123; int i; long result = 0; // 参数不符合规则，返回 -1 if(fromNum&lt;0 || endNum&lt;0 || endNum&lt;fromNum)&#123; return -1; &#125; for(i=fromNum; i&lt;=endNum; i++)&#123; result += i; &#125; // 返回大于等于 0 的值 return result;&#125; module.h 源码： 1234567#ifndef __MODULE_H_ #define __MODULE_H_ // 用宏定义来代替全局变量 #define OS &quot;Windows 7&quot; // 也可以省略 extern；不过为了程序可读性，建议写上 extern long sum(int, int);#endif 多个.c文件的时候，也可以只用一个.h头文件，然后都包含一下这个.h文件 6、文件操作https://www.cnblogs.com/wuqianling/p/5340719.html这篇文章写的就不错。 主要是文件操作分为二进制文件和文本文件，fopen打开的时候设置打开模式，返回值问FILE*类型的一个文件指针。通过这个文件指针就可以访问这个文件。 7、编码规范 for while等关键字和括号之间留出一个空格，突出关键字，for后哪怕只有一行也写{} 注释的双斜线之后要有一个空格，突出注释 函数名和类使用大驼峰命名法首个单词大写，变量使用小驼峰命名法第一个字母小写 类和函数写完之后要空一行 分号、逗号前边不空格，后边留空格。双目运算符两边留空格","tags":["C语言"],"categories":["C语言"]},{"title":"proc目录下pid各文件目录含义","path":"//posts/1.html","content":"Linux 内核提供了一种通过 proc 文件系统，在运行时访问内核内部数据结构、改变内核设置的机制。proc 文件系统是一个伪文件系统，它只存在内存当中，而不占用外存空间。它以文件系统的方式为访问系统内核数据的操作提供接口。 用户和应用程序可以通过 proc 得到系统的信息，并可以改变内核的某些参数。由于系统的信息，如进程，是动态改变的，所以用户或应用程序读取 proc 文件时，proc 文件系统是动态从系统内核读出所需信息并提交的。 下面列出的这些文件或子文件夹，并不是都是在你的系统中存在，这取决于你的内核配置和装载的模块。另外，在 proc 下还有三个很重要的目录：net，scsi 和 sys。 sys 目录是可写的，可以通过它来访问或修改内核的参数，而 net 和 scsi 则依赖于内核配置。例如，如果系统不支持 scsi，则 scsi 目录不存在。 除了以上介绍的这些，还有的是一些以数字命名的目录，它们是进程目录。系统中当前运行的每一个进程都有对应的一个目录在 proc 下，以进程的 PID 号为目录名，它们是读取进程信息的接口。而 self 目录则是读取进程本身的信息接口，是一个 link。 &#x2F;proc&#x2F;[pid]&#x2F;auxv&#x2F;proc&#x2F;[pid]&#x2F;auxv 包含传递给进程的 ELF 解释器信息，格式是每一项都是一个 unsigned long长度的 ID 加上一个 unsigned long 长度的值。最后一项以连续的两个 0x00 开头。举例如下： $ hexdump -x &#x2F;proc&#x2F;2406&#x2F;auxv 0000000 0021 0000 0000 0000 f000 f7fa 7fff 00000000010 0010 0000 0000 0000 fbff 1f8b 0000 00000000020 0006 0000 0000 0000 1000 0000 0000 00000000030 0011 0000 0000 0000 0064 0000 0000 00000000040 0003 0000 0000 0000 0040 0040 0000 00000000050 0004 0000 0000 0000 0038 0000 0000 00000000060 0005 0000 0000 0000 0007 0000 0000 00000000070 0007 0000 0000 0000 0000 0000 0000 00000000080 0008 0000 0000 0000 0000 0000 0000 00000000090 0009 0000 0000 0000 55e0 0045 0000 000000000a0 000b 0000 0000 0000 0000 0000 0000 000000000b0 000c 0000 0000 0000 0000 0000 0000 000000000c0 000d 0000 0000 0000 0000 0000 0000 000000000d0 000e 0000 0000 0000 0000 0000 0000 000000000e0 0017 0000 0000 0000 0000 0000 0000 000000000f0 0019 0000 0000 0000 f079 f7f6 7fff 00000000100 001f 0000 0000 0000 ffea f7f6 7fff 00000000110 000f 0000 0000 0000 f089 f7f6 7fff 00000000120 0000 0000 0000 0000 0000 0000 0000 00000000130 &#x2F;proc&#x2F;[pid]&#x2F;cmdline&#x2F;proc&#x2F;[pid]&#x2F;cmdline 是一个只读文件，包含进程的完整命令行信息。如果该进程已经被交换出内存或者这个进程是 zombie 进程，则这个文件没有任何内容。该文件以空字符 null 而不是换行符作为结束标志。举例如下： $ ps aux|grep frpsroot 2406 0.1 0.1 54880 10524 ? Sl Dec11 21:30 frps -c .&#x2F;frps.ini $ cat &#x2F;proc&#x2F;2406&#x2F;cmdlinefrps-c.&#x2F;frps.ini &#x2F;proc&#x2F;[pid]&#x2F;comm&#x2F;proc&#x2F;[pid]&#x2F;comm 包含进程的命令名。举例如下： $ cat &#x2F;proc&#x2F;2406&#x2F;commfrps &#x2F;proc&#x2F;[pid]&#x2F;cwd&#x2F;proc&#x2F;[pid]&#x2F;cwd 是进程当前工作目录的符号链接。举例如下： $ ls -lt &#x2F;proc&#x2F;2406&#x2F;cwdlrwxrwxrwx 1 root root 0 Dec 12 20:39 &#x2F;proc&#x2F;2406&#x2F;cwd -&gt; &#x2F;home&#x2F;mike&#x2F;frp_0.13.0_linux_amd64 &#x2F;proc&#x2F;[pid]&#x2F;environ&#x2F;proc&#x2F;[pid]&#x2F;environ 显示进程的环境变量。举例如下： $ strings &#x2F;proc&#x2F;2406&#x2F;environ SUPERVISOR_GROUP_NAME&#x3D;sshTERM&#x3D;linuxSUPERVISOR_SERVER_URL&#x3D;unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;supervisor.sockSUPERVISOR_PROCESS_NAME&#x3D;sshRUNLEVEL&#x3D;2UPSTART_EVENTS&#x3D;runlevelPREVLEVEL&#x3D;NPATH&#x3D;&#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;sbin:&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;binUPSTART_INSTANCE&#x3D;UPSTART_JOB&#x3D;rcSUPERVISOR_ENABLED&#x3D;1runlevel&#x3D;2PWD&#x3D;&#x2F;previous&#x3D;N &#x2F;proc&#x2F;[pid]&#x2F;exe&#x2F;proc&#x2F;[pid]&#x2F;exe 为实际运行程序的符号链接。举例如下： $ ls -lt &#x2F;proc&#x2F;2406&#x2F;exelrwxrwxrwx 1 root root 0 Dec 11 19:00 &#x2F;proc&#x2F;2406&#x2F;exe -&gt; &#x2F;usr&#x2F;bin&#x2F;frps &#x2F;proc&#x2F;[pid]&#x2F;fd&#x2F;proc&#x2F;[pid]&#x2F;fd 是一个目录，包含进程打开文件的情况。举例如下： $ ls -lt &#x2F;proc&#x2F;2406&#x2F;fd lrwx—— 1 root root 64 Dec 24 09:39 77 -&gt; socket:[44377722]lrwx—— 1 root root 64 Dec 17 15:07 47 -&gt; socket:[29482617]lr-x—— 1 root root 64 Dec 12 20:18 0 -&gt; pipe:[13282]l-wx—— 1 root root 64 Dec 12 20:18 1 -&gt; pipe:[13283]lrwx—— 1 root root 64 Dec 12 20:18 10 -&gt; socket:[12238218]lrwx—— 1 root root 64 Dec 12 20:18 4 -&gt; anon_inode:[eventpoll]lrwx—— 1 root root 64 Dec 12 20:18 40 -&gt; socket:[19378614] 目录中的每一项都是一个符号链接，指向打开的文件，数字则代表文件描述符。 &#x2F;proc&#x2F;[pid]&#x2F;latency&#x2F;proc&#x2F;[pid]&#x2F;latency 显示哪些代码造成的延时比较大。如果要使用这个特性需要执行： $ echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;latencytop 举例如下 $ cat &#x2F;proc&#x2F;2406&#x2F;latency Latency Top version : v0.130667 10650491 4891 poll_schedule_timeout do_sys_poll SyS_poll system_call_fastpath 0x7f636573dc1d8 105 44 futex_wait_queue_me futex_wait do_futex SyS_futex system_call_fastpath 0x7f6365a167bc 每一行前三个数字分别是后面代码执行的次数、总共执行延迟时间(单位是微秒)和最长执行延迟时间(单位是微秒)。后面则是代码完整的调用栈。 &#x2F;proc&#x2F;[pid]&#x2F;maps&#x2F;proc&#x2F;[pid]&#x2F;maps 显示进程的内存区域映射信息。举例如下： $ cat &#x2F;proc&#x2F;2406&#x2F;maps00400000-006ea000 r-xp 00000000 fd:01 1727569 &#x2F;usr&#x2F;bin&#x2F;frps006ea000-00a6c000 r–p 002ea000 fd:01 1727569 &#x2F;usr&#x2F;bin&#x2F;frps00a6c000-00ab1000 rw-p 0066c000 fd:01 1727569 &#x2F;usr&#x2F;bin&#x2F;frps00ab1000-00ad4000 rw-p 00000000 00:00 0c000000000-c00000b000 rw-p 00000000 00:00 0c41feac000-c420000000 rw-p 00000000 00:00 0c420000000-c420400000 rw-p 00000000 00:00 0c420400000-c420700000 rw-p 00000000 00:00 0c420700000-c420800000 rw-p 00000000 00:00 0c420800000-c420900000 rw-p 00000000 00:00 0c420900000-c420a00000 rw-p 00000000 00:00 0c420a00000-c421ea0000 rw-p 00000000 00:00 0c421ea0000-c422a00000 rw-p 00000000 00:00 0c422a00000-c422a60000 rw-p 00000000 00:00 07f0418c01000-7f0418ee1000 rw-p 00000000 00:00 07ffff7f4f000-7ffff7f70000 rw-p 00000000 00:00 0 [stack:5121]7ffff7fad000-7ffff7faf000 r–p 00000000 00:00 0 [vvar]7ffff7faf000-7ffff7fb1000 r-xp 00000000 00:00 0 [vdso]ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0 [vsyscall] 其中注意的一点是 [stack:] 是线程的堆栈信息，对应于 &#x2F;proc&#x2F;[pid]&#x2F;task&#x2F;[tid]&#x2F; 路径。 &#x2F;proc&#x2F;[pid]&#x2F;root&#x2F;proc&#x2F;[pid]&#x2F;root 是进程根目录的符号链接。举例如下： $ ls -lt &#x2F;proc&#x2F;2406&#x2F;rootlrwxrwxrwx 1 root root 0 Dec 12 20:39 &#x2F;proc&#x2F;2406&#x2F;root -&gt; &#x2F; &#x2F;proc&#x2F;[pid]&#x2F;stack&#x2F;proc&#x2F;[pid]&#x2F;stack 示当前进程的内核调用栈信息，只有内核编译时打开了 CONFIG_STACKTRACE 编译选项，才会生成这个文件。举例如下： 1234567$ cat /proc/2406/stack[&lt;ffffffff810fa996&gt;] futex_wait_queue_me+0xc6/0x130[&lt;ffffffff810fb05d&gt;] futex_wait+0x17d/0x270[&lt;ffffffff810fd2d5&gt;] do_futex+0xd5/0x520[&lt;ffffffff810fd791&gt;] SyS_futex+0x71/0x150[&lt;ffffffff8180cc76&gt;] entry_SYSCALL_64_fastpath+0x16/0x75[&lt;ffffffffffffffff&gt;] 0xffffffffffffffff &#x2F;proc&#x2F;[pid]&#x2F;statm&#x2F;proc&#x2F;[pid]&#x2F;statm 显示进程所占用内存大小的统计信息。包含七个值，度量单位是 page(page大小可通过 getconf PAGESIZE 得到)。举例如下： $ cat &#x2F;proc&#x2F;2406&#x2F;statm13720 2617 493 746 0 12007 0 各个值含义： a）进程占用的总的内存b）进程当前时刻占用的物理内存c）同其它进程共享的内存d）进程的代码段e）共享库(从2.6版本起，这个值为0)f）进程的堆栈g）dirty pages(从2.6版本起，这个值为0) &#x2F;proc&#x2F;[pid]&#x2F;status&#x2F;proc&#x2F;[pid]&#x2F;status 包含进程的状态信息。其很多内容与 &#x2F;proc&#x2F;[pid]&#x2F;stat 和 &#x2F;proc&#x2F;[pid]&#x2F;statm 相同，但是却是以一种更清晰地方式展现出来。举例如下： $ cat &#x2F;proc&#x2F;2406&#x2F;statusName: frpsState: S (sleeping)Tgid: 2406Ngid: 0Pid: 2406PPid: 2130TracerPid: 0Uid: 0 0 0 0Gid: 0 0 0 0FDSize: 128Groups: 0NStgid: 2406NSpid: 2406NSpgid: 2406NSsid: 2130VmPeak: 54880 kBVmSize: 54880 kBVmLck: 0 kBVmPin: 0 kBVmHWM: 34872 kBVmRSS: 10468 kBVmData: 47896 kBVmStk: 132 kBVmExe: 2984 kBVmLib: 0 kBVmPTE: 68 kBVmPMD: 20 kBVmSwap: 0 kBHugetlbPages: 0 kBThreads: 11SigQ: 0&#x2F;31834SigPnd: 0000000000000000ShdPnd: 0000000000000000SigBlk: 0000000000000000SigIgn: 0000000000000000SigCgt: fffffffe7fc1feffCapInh: 0000000000000000CapPrm: 0000003fffffffffCapEff: 0000003fffffffffCapBnd: 0000003fffffffffCapAmb: 0000000000000000Seccomp: 0Cpus_allowed: fCpus_allowed_list: 0-3Mems_allowed: 00000000,00000001Mems_allowed_list: 0voluntary_ctxt_switches: 2251028nonvoluntary_ctxt_switches: 18031 关于信号（signal）的信息：SigQ 分为两部分（例如 0&#x2F;31834），前面表示当前处在队列中的信号（0），后面则表示队列一共可以存储多少信号（31834）；SigPnd 表示当前线程 pending 的信号，而ShdPnd 则表示整个进程 pending 的信号；SigBlk、SigIgn 和 SigCgt 分别表示对信号的处理是阻塞，忽略，还是捕获。（关于Unix信号的相关知识，可以参考 Unix: Dealing with signals）。 &#x2F;proc&#x2F;[pid]&#x2F;syscall&#x2F;proc&#x2F;[pid]&#x2F;syscall 显示当前进程正在执行的系统调用。举例如下： $ cat &#x2F;proc&#x2F;2406&#x2F;syscall202 0xab3730 0x0 0x0 0x0 0x0 0x0 0x7ffff7f6ec68 0x455bb3 第一个值是系统调用号（202代表poll），后面跟着 6 个系统调用的参数值（位于寄存器中），最后两个值依次是堆栈指针和指令计数器的值。如果当前进程虽然阻塞，但阻塞函数并不是系统调用，则系统调用号的值为 -1，后面只有堆栈指针和指令计数器的值。如果进程没有阻塞，则这个文件只有一个 running 的字符串。 内核编译时打开了 CONFIG_HAVE_ARCH_TRACEHOOK 编译选项，才会生成这个文件。 &#x2F;proc&#x2F;[pid]&#x2F;wchan&#x2F;proc&#x2F;[pid]&#x2F;wchan 显示当进程 sleep 时，kernel 当前运行的函数。举例如下： $ cat &#x2F;proc&#x2F;2406&#x2F;wchanfutex_wait_queue_meadmin","tags":["Linux"],"categories":["Linux"]},{"title":"查找内核符号","path":"//posts/1.html","content":"一、&#x2F;proc&#x2F;kallsyms 内核符号可以通过&#x2F;proc&#x2F;kallsyms查看。 (1)符号类型说明 在Linux内核中，kallsyms是一个符号表，它包含了内核中所有的符号信息，包括函数、变量、常量等等。这些符号信息可以被内核模块和其他程序使用，这些符号类型可以帮助开发人员更好地理解内核中的符号信息，从而更好地进行内核开发和调试。 在kallsyms中，每个符号都有一个类型，表示它的用途。下面是一些常见的符号类型： T：表示该符号是一个函数，可以被其他代码调用。 t：表示该符号是一个局部函数，只能在当前文件中使用。 D：表示该符号是一个全局变量，可以被其他代码访问和修改。 d：表示该符号是一个局部变量，只能在当前文件中使用。 R：表示该符号是一个只读变量，不能被修改。 r：表示该符号是一个只读局部变量，只能在当前文件中使用 A：表示该符号是一个可读写的变量，可以被其他代码访问和修改。 a：表示该符号是一个可读写的局部变量，只能在当前文件中使用。 B：表示该符号是一个未初始化的全局变量，它的值在程序启动时被初始化为0。 b：表示该符号是一个未初始化的局部变量，它的值在程序启动时被初始化为0。 G：表示该符号是一个全局变量，但是它的值在程序运行时可能会被修改。 C：表示该符号是一个常量，它的值在程序运行时不能被修改。 W：表示该符号是一个弱符号， ?: 表示该符号的类型未知。 (2)弱符号关于弱符号的一些说明：__weak 是一个关键字，用于声明一个弱符号。在 C 语言中，如果一个符号被定义了多次，编译器会报错。但是，如果一个符号被声明为弱符号，那么编译器就不会报错，而是在链接时选择其中一个符号作为最终的符号。这个特性在编写库时非常有用，因为它允许用户在链接时覆盖库中的函数。 如下为一个例子： 123456789101112131415161718192021222324252627282930313233/** * probe_kernel_read(): safely attempt to read from a location * @dst: pointer to the buffer that shall take the data * @src: address to read from * @size: size of the data chunk * * Safely read from address @src to the buffer at @dst. If a kernel fault * happens, handle that and return -EFAULT. * * We ensure that the copy_from_user is executed in atomic context so that * do_page_fault() doesn&#x27;t attempt to take mmap_sem. This makes * probe_kernel_read() suitable for use within regions where the caller * already holds mmap_sem, or other locks which nest inside mmap_sem. */long __weak probe_kernel_read(void *dst, const void *src, size_t size) __attribute__((alias(&quot;__probe_kernel_read&quot;)));long __probe_kernel_read(void *dst, const void *src, size_t size)&#123; long ret; mm_segment_t old_fs = get_fs(); set_fs(KERNEL_DS); pagefault_disable(); ret = __copy_from_user_inatomic(dst, (__force const void __user *)src, size); pagefault_enable(); set_fs(old_fs); return ret ? -EFAULT : 0;&#125;EXPORT_SYMBOL_GPL(probe_kernel_read); (3)内核驱动获取符号地址符号存在于&#x2F;proc&#x2F;kallsyms 文件中，可以通过kallsyms_lookup_name获取其符号的地址。在内核版本 2.6.33 - 5.7.0 可以用kallsyms_lookup_name来获取该函数的地址。在内核2.6.33 以下和 5.7.0 以上可以用 kprobe 来获取该函数的地址 kallsyms_lookup_name是内核API，源码如下： 使用kallsyms_lookup_name函数需要#include &lt;linux/kallsyms.h&gt; 12345678910111213141516/* Lookup the address for this symbol. Returns 0 if not found. */unsigned long kallsyms_lookup_name(const char *name)&#123; char namebuf[KSYM_NAME_LEN]; unsigned long i; unsigned int off; for (i = 0, off = 0; i &lt; kallsyms_num_syms; i++) &#123; off = kallsyms_expand_symbol(off, namebuf, ARRAY_SIZE(namebuf)); if (strcmp(namebuf, name) == 0) return kallsyms_sym_address(i); &#125; return module_kallsyms_lookup_name(name);&#125;EXPORT_SYMBOL_GPL(kallsyms_lookup_name); 上述函数可以使用符号名找到在内核中的地址，使用该方法可以使用内核中未导出的内核函数。如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * text_poke - Update instructions on a live kernel * @addr: address to modify * @opcode: source of the copy * @len: length to copy * * Only atomic text poke/set should be allowed when not doing early patching. * It means the size must be writable atomically and the address must be aligned * in a way that permits an atomic write. It also makes sure we fit on a single * page. */void *text_poke(void *addr, const void *opcode, size_t len)&#123; unsigned long flags; char *vaddr; struct page *pages[2]; int i; /* * While boot memory allocator is runnig we cannot use struct * pages as they are not yet initialized. */ BUG_ON(!after_bootmem); lockdep_assert_held(&amp;text_mutex); if (!core_kernel_text((unsigned long)addr)) &#123; pages[0] = vmalloc_to_page(addr); pages[1] = vmalloc_to_page(addr + PAGE_SIZE); &#125; else &#123; pages[0] = virt_to_page(addr); WARN_ON(!PageReserved(pages[0])); pages[1] = virt_to_page(addr + PAGE_SIZE); &#125; BUG_ON(!pages[0]); local_irq_save(flags); set_fixmap(FIX_TEXT_POKE0, page_to_phys(pages[0])); if (pages[1]) set_fixmap(FIX_TEXT_POKE1, page_to_phys(pages[1])); vaddr = (char *)fix_to_virt(FIX_TEXT_POKE0); memcpy(&amp;vaddr[(unsigned long)addr &amp; ~PAGE_MASK], opcode, len); clear_fixmap(FIX_TEXT_POKE0); if (pages[1]) clear_fixmap(FIX_TEXT_POKE1); local_flush_tlb(); sync_core(); /* Could also do a CLFLUSH here to speed up CPU recovery; but that causes hangs on some VIA CPUs. */ for (i = 0; i &lt; len; i++) BUG_ON(((char *)addr)[i] != ((char *)opcode)[i]); local_irq_restore(flags); return addr;&#125; text_poke为非导出函数，在驱动中无法使用，可以使用kallsyms_lookup_name获取函数地址并赋值给函数指针，便可以使用该函数。 12void *(*text_poke_fn)(void *addr, const void *opcode, size_t len);text_poke_fn = (void *(*)(void *, const void *, size_t))kallsyms_lookup_nama(&quot;text_poke&quot;);","tags":["Linux"],"categories":["Linux"]},{"title":"OOM","path":"/posts/OOM.html","content":"在Linux操作系统中，OOM（Out of Memory）指的是系统可用内存耗尽，无法再为任何进程分配所需的内存，从而导致系统必须采取某些极端措施的情况。当系统面临OOM时，可能会选择杀死某些进程以释放内存，这是通过Linux内核的OOM Killer机制实现的。 OOM发生的原因： 物理内存不足：实际物理内存资源耗尽，无法满足所有进程的内存需求，尤其是当大量进程同时运行且内存占用较大时更容易出现。 交换空间不足：即使有交换分区（Swap），但当系统试图将物理内存中的页换出到交换空间时，发现交换空间也已满，无法继续进行内存交换。 内存泄漏：应用程序存在内存泄漏问题，随着时间推移不断消耗内存，直至耗尽整个系统资源。 一次性加载大量数据：某个进程瞬间请求大量内存，超出了系统所能提供的范围。 内存限制：在容器环境下，单个容器可能存在严格的内存限制，超出限制后也会触发OOM。","tags":["Linux"],"categories":["Linux"]},{"title":"ftpget","path":"/posts/ftpget.html","content":"ftpget -u username -p passwd IP source target ftpput -u username -p passwd IP target source 举个例子： 12ftpput -u zhangsan -p 000000 192.168.10.10 target.txt source.txt // 将本地的 source.txt 文件传输到 192.168.10.10 /home/zhangsan/ 目录下，并以target.txt 保存","tags":["Linux工具"],"categories":["Linux工具"]},{"title":"scp","path":"/posts/scp.html","content":"一、从本地复制到远程主机命令格式如下： scp &#x2F;path&#x2F;to&#x2F;local&#x2F;file.txt user@remote_host:&#x2F;path&#x2F;on&#x2F;remote&#x2F; 这会将本地的 file.txt 文件复制到远程主机 remote_host 的 /path/on/remote/ 目录下。 二、从远程主机复制到本地（1）命令解释命令格式如下：scp user@remote_host:&#x2F;path&#x2F;on&#x2F;remote&#x2F;file.txt &#x2F;path&#x2F;to&#x2F;local&#x2F; 这会将远程主机 remote_host 的 /path/on/remote/file.txt 文件复制到本地的 /path/to/local/ 目录下。 （2）实际操作实操命令如下：scp &#114;&#111;&#111;&#x74;&#x40;&#x31;&#x39;&#50;&#x2e;&#49;&#54;&#56;&#46;&#49;&#46;&#49;&#48;&#x39;:&#x2F;home&#x2F;DataBaseMysql.zip .&#x2F; 这会将远程主机 192.168.1.109 的&#x2F;home&#x2F;DataBaseMysql.zip 文件复制到本地的当前目录下 三、递归复制目录实操命令如下：scp -r user@remote_host:&#x2F;path&#x2F;on&#x2F;remote&#x2F;directory &#x2F;path&#x2F;to&#x2F;local&#x2F; 这会将远程主机 remote_host 的 /path/on/remote/directory 目录及其所有内容复制到本地的 /path/to/local/ 目录下。 四、指定 SSH 端口如果远程主机的 SSH 端口不是默认的 22，可以使用 -P 选项指定端口： scp -P 2222 user@remote_host:&#x2F;path&#x2F;on&#x2F;remote&#x2F;file.txt &#x2F;path&#x2F;to&#x2F;local&#x2F;","tags":["Linux工具"],"categories":["Linux工具"]},{"title":"find","path":"/posts/find.html","content":"find . -name “my_file” find . -name &#x2F;etc -type d","tags":["Linux工具"],"categories":["Linux工具"]},{"title":"grep","path":"/posts/grep.html","content":"文本搜索工具，根据用户指定的“模式”（过滤条件），对目标文本逐行进行匹配，并打印输出匹配到的行。 完整语法： 123grep [options] [pattern] file 命令 参数 匹配模式 文件数据 常用参数： 常用参数 描述 -i 忽略大小写 -n 显示匹配行与行号 -r 递归查找子目录 -v 显示不能被匹配到的字符串 常用正则表达式 表达式\t解释 ^\t用于模式最左侧，如 “^yu” 即匹配以yu开头的单词 $\t用于模式最右侧，如 “yu$” 即匹配以yu结尾的单词 ^$\t组合符，表示空行 .\t匹配任意一个且只有一个字符，不能匹配空行 |\t使用egrep命令 重匹配前一个字符连续出现0次或1次以上 .*\t匹配任意字符 ^.*\t组合符，匹配任意多个字符开头的内容 .*$\t组合符，匹配任意多个字符结尾的内容 [abc]\t匹配 [] 内集合中的任意一个字符，a或b或c，也可以写成 [ac] [^abc]\t匹配除了 ^后面的任意一个字符，a或b或c，[]内 ^ 表示取反操作 常用： 1grep -nr &quot;xxx&quot; .","tags":["Linux工具"],"categories":["Linux工具"]},{"title":"内存检测工具","path":"/posts/内存检测工具.html","content":"在写大型C&#x2F;C++工程时难免会发生内存泄漏现象，系统编程中一个重要的方面就是有效地处理与内存相关的问题。你的工作越接近系统，你就需要面对越多的内存问题。有时这些问题非常琐碎，而更多时候它会演变成一个调试内存问题的恶梦。 常见的内存问题一共七种： 动态内存泄露； 资源泄露，比如文件指针不关闭； 动态内存越界； 4.数组内存越界； 5.动态内存double free； 6.使用野指针，即未初始化的指针； 7.释放野指针，即未初始化的指针。 内存问题非常难定位，对于小工程来说，简单去检查代码中new和delete的匹配对数就基本能定位到问题，但是一旦代码量上升到以万单位时，仅靠肉眼检查来定位问题那就非常困难了，所以我们需要利用工具帮助我们找出问题所在。在Linux系统下内存检测工具首推Valgrind，一款非常好用的开源内存管理框架。Valgrind其实是一个工具集，内存错误检测只是它众多功能的一个，但我们用得最多的功能正是它——memcheck。 该工具可以检测下列与内存相关的问题 : 未释放内存的使用 对释放后内存的读&#x2F;写 对已分配内存块尾部的读&#x2F;写 内存泄露 不匹配的使用malloc&#x2F;new&#x2F;new[] 和 free&#x2F;delete&#x2F;delete[] 重复释放内存 首先安装Valgrind非常简单： 123456789//valgrind下载：http://valgrind.org/downloads/valgrind-3.12.0.tar.bz2valgrind安装：1. tar -jxvf valgrind-3.12.0.tar.bz22. cd valgrind-3.12.03. ./configure4. make5. sudo make install 下面开始讲解Valgrind的应用场景。 注意: 下面讨论的所有测试代码都应该使用gcc&#x2F;g++并且加上-g选项。 1. 使用未初始化的内存（使用野指针）这里我们定义了一个指针p，但并未给他开辟空间，即他是一个野指针，但我们却使用它了。 Valgrind检测出我们程序使用了未初始化的变量，但并未检测出内存泄漏。 2.在内存被释放后进行读&#x2F;写（使用野指针）p所指向的内存被释放了，p变成了野指针，但是我们却继续使用这片内存。 Valgrind检测出我们使用了已经free掉的内存，并给出这片内存是哪里分配哪里释放的。 3.从已分配内存块的尾部进行读&#x2F;写（动态内存越界）我们动态地分配了一段数组，但我们在访问个数组时发生了越界读写，程序crash掉。 Valgrind检测出越界的位置。 注意：Valgrind不检查静态分配数组的使用情况！所以对静态分配的数组，Valgrind表示无能为力！比如下面的例子，程序crash掉，我们却不知道为什么。 4.内存泄漏内存泄漏的原因在于没有成对地使用malloc&#x2F;free和new&#x2F;delete，比如下面的例子。 Valgrind会给出程序中malloc和free的出现次数以判断是否发生内存泄漏，比如对上面的程序运行memcheck，Valgrind的记录显示上面的程序用了1次malloc，却调用了0次free，明显发生了内存泄漏！ 上面提示了我们可以使用–leak-check&#x3D;full进一步获取内存泄漏的信息，比如malloc和free的具体行号。 5. 不匹配地使用malloc&#x2F;new&#x2F;new[] 和 free&#x2F;delete&#x2F;delete[]正常使用new&#x2F;delete和malloc&#x2F;free是这样子的： 而不匹配地使用malloc&#x2F;new&#x2F;new[] 和 free&#x2F;delete&#x2F;delete[]则会被提示mismacth： 6.两次释放内存double free的情况同样是根据malloc&#x2F;free的匹配对数来体现的，比如free多了一次，Valgrind也会提示。 当然，Valgrind也不是万能的。Valgrind也有无法找到问题的时候，有些问题只能通过不断的review代码找到了症结。发现问题，解决问题，毕竟是末流。最好的方法，就是不引入内存问题。这可以通过良好的代码风格和设计来实现的。","tags":["Linux工具"],"categories":["Linux工具"]},{"title":"top","path":"/posts/top.html","content":"1ps -ef | grep xxx //xxx为进程名字 通过ps找到进程号，通过如下命令可以查看该进程下的所有线程CPU利用率，注意这里是该进程PID下对应的所有线程 1top -H -p pid 例如进程pid为5810，则命令为： 1top -H -p 5810 一、top命令的使用帮助1、top命令的选项top命令的使用方法：top [-d number] | top [-bnp] 选项 解析 -b 以批处理模式操作； -c 显示完整的治命令； -d 屏幕刷新间隔时间； -I 忽略失效过程； -s 保密模式； -S 累积模式； -i&lt;时间&gt; 设置间隔时间； -u&lt;用户名&gt; 指定用户名； -p&lt;进程号&gt; 指定进程； -n&lt;次数&gt; 循环显示的次数。 二、top命令的交换命令在top命令执行过程中可以使用的一些交互命令。这些命令都是单字母的，如果在命令行中使用了-s选项， 其中一些命令可能会被屏蔽。 也就是在top命令运行过程中，可以按下如下案件，会按照相应指令显示 1234567891011121314151617h：显示帮助画面，给出一些简短的命令总结说明；k：终止一个进程；i：忽略闲置和僵死进程，这是一个开关式命令；q：退出程序；r：重新安排一个进程的优先级别；S：切换到累计模式；s：改变两次刷新之间的延迟时间（单位为s），如果有小数，就换算成ms。输入0值则系统将不断刷新，默认值是5s；f或者F：从当前显示中添加或者删除项目；o或者O：改变显示项目的顺序；l：切换显示平均负载和启动时间信息；m：切换显示内存信息；t：切换显示进程和CPU状态信息；c：切换显示命令名称和完整命令行；M：以内存的使用资源排序显示；P：根据CPU使用百分比大小进行排序；T：根据时间/累计时间进行排序；w：将当前设置写入~/.toprc文件中。 三、top显示信息解释1、top的第一行解释在命令行输入top，进入系统监控信息的交互界面，第一行解释如下： 123410:40:53 表示当前时间up 7:09 系统运行时间，格式为时：分。3 users 当前登录用户数load average: 0.05, 0.03, 0.05 系统负载，即任务队列的平均长度。 三个数值分别为 1分钟、5分钟、15分钟前到现在的平均值。 2、top的第二、三行信息解释在命令行输入top，进入系统监控信息的交互界面，第2、3行为进程和CPU的信息，当有多个CPU时，这些内容可能会超过两行， 第二行解释如下： 12345678910111213216 total 进程总数1 running 正在运行的进程数215 sleeping 睡眠的进程数0 stopped 停止的进程数0 zombie 僵尸进程数0.0 us 用户空间占用CPU百分比0.1 sy 内核空间占用CPU百分比0.0 ni 用户进程空间内改变过优先级的进程占用CPU百分比99.9 id 空闲CPU百分比0.0 wa 等待输入输出的CPU时间百分比0.0 hi 硬中断（Hardware IRQ）占用CPU的百分比0.0 si 软中断（Software Interrupts）占用CPU的百分比0.0 st 虚拟CPU等待实际CPU的时间的百分比。 3、top的第四、五行信息解释第四行及第五行主要显示系统的内存信息。 123456789KiB Mem: 12119056 tota 物理内存总量10016948 free 空闲内存总量923252 used 使用的物理内存总量1178856 buff/cache 用作内核缓存的内存量KiB Swap: 2093052 total 交换区总量267544 used 使用的交换区总量2093052 free 空闲交换区总量0 used 缓冲的交换区总量。10742188 avail Mem 代表可用于进程下一次分配的物理内存数量 4、top的进程信息top命令的交换界面主要区域，监控系统进程的实时状态信息。 123456789101112PID 进程idUSER 进程所有者的用户名PR 优先级NI nice值，负值表示高优先级，正值表示低优先级。VIRT 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RESRES 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATASHR 共享内存大小，单位kbS 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程%CPU 上次更新到现在的CPU时间占用百分比%MEM 进程使用的物理内存百分比TIME+ 进程使用的CPU时间总计，单位1/100秒COMMAND 命令名/命令行 其余监控项解释 1234567891011121314PPID 父进程idRUSER Real user nameUID 进程所有者的用户idGROUP 进程所有者的组名TTY 启动进程的终端名。不是从终端启动的进程则显示为 ?P 最后使用的CPU，仅在多CPU环境下有意义TIME 进程使用的CPU时间总计，单位秒SWAP 进程使用的虚拟内存中，被换出的大小，单位kbCODE 可执行代码占用的物理内存大小，单位kbDATA 可执行代码以外的部分(数据段+栈)占用的物理内存大小，单位kbnFLT 页面错误次数nDRT 最后一次写入到现在，被修改过的页面数。WCHAN 若该进程在睡眠，则显示睡眠中的系统函数名Flags 任务标志 四、top命令的基本使用1、查看当前系统cpu占用最高的进程 进入top交互界面后，按P键对CPU负载的进程进行排列。 2、查看当前系统内存使用最高的进程 进入top交互界面后，按M键对CPU负载的进程进行排列。 3、对排序的列进行高亮显示 敲击键盘‘x’（打开&#x2F;关闭排序列的加亮效果） 4、对运行的进程进行高亮显示 敲击键盘‘b’（打开关闭加亮效果），对运行的进程进行高亮显示","tags":["Linux工具"],"categories":["Linux工具"]},{"title":"tcpdump","path":"/posts/tcpdump.html","content":"tmpdump用于抓包，一个例子： 1tcpdump -i any host 192.168.x.x -s0 -vvv -w 1.cap -i any 任何网络 -s0 防止截断 -w写入文件 -vvv详细的信息 最终得到一个名为1.cap的文件，可以使用wireshark工具打开","tags":["Linux工具"],"categories":["Linux工具"]},{"title":"sed","path":"/posts/sed.html","content":"https://blog.csdn.net/2301_78315274/article/details/133880462 1、将每行第一个111替换为AAA 1sed -i &quot;s/111/AAA/&quot; a.txt -i作用会修改源文件，如这里的a.txt，如果不加-i就不会修改，只是命令回显改变了 2、替换所有的111为AAA 11. sed -i &quot;s/111/AAA/g&quot; a.txt 3、替换第一到四行的所有111为AAA 1sed &quot;1,4s/111/AAA/g&quot; a.txt","tags":["Linux工具"],"categories":["Linux工具"]},{"title":"tar","path":"/posts/tar.html","content":"tar全称是tape archive，初衷是将多个文件写入磁带。首先，需要分清两个概念——打包与压缩。打包：将多个文件汇总成一个文件。压缩：将一个大文件通过压缩算法变成一个小文件。而tar命令执行的打包流程，真正执行压缩的是使用的压缩算法，比如gzip、bzip2、xz。tar命令在Linux社区内十分受欢迎，其中一个原因就是灵活性强，可以根据需要选择不同的压缩算法。 一、常用参数 打包过程 -c或--create。创建档案文件（可以理解为压缩包名） -x或--extract。解压（提取）文件 -f或--file。指定档案文件，告诉tar命令，后面是文件名 -t或--list。列出档案文件的内容 -v或--verbose。显示处理文件的详细信息 当多个参数简写在一起的时候，可以只用一个-。在实际使用中，最常使用的参数就是-cvf，即创建压缩包，并以显示详细处理信息。 压缩过程 gzip：参数-z或--gzip；文件拓展名：.tar.gz或.tgz bzip2：-j或--bzip2；.tar.bz2 xz：-J或--xz；.tar.xz 压缩算法之间的区别： 压缩算法 gzip bzip2 xz 参数 -z -j -J 文件拓展名 .tar.gz .tar.bz2 .tar.xz 压缩速度 快 中 慢 解压速度 快 中 中 压缩比 低 中 高 资源占用 少 中 高 适用场景 快速压缩&#x2F;解压 高压缩比 最大压缩比 在日常使用中，使用gzip压缩就可以了，虽然压缩比低，但是它十分的快。并且如果被压缩的文件本身就比较小，使用xz压缩的结果也不会少太多。因此，日常使用建议gzip，既想要速度也想要压缩比建议bzip2，超大文件建议xz。 二、示例流程相似，只需更换压缩算法的参数。 1234567# 压缩。压缩包名 + 被压缩的目录或者文件路径tar -czvf archive_name.tar.gz path_to_compress# 解压。用什么压缩算法压缩的，就用什么压缩算法解压tar -xzvf archive_name.tar.gz # 解压到当前目录tar -xzvf archive_name.tar.gz -C path_to_extract # 解压至指定目录。 -C （change directory）指出目录地址","tags":["Linux工具"],"categories":["Linux工具"]},{"title":"objdump","path":"/posts/objdump.html","content":"objdump提供了对二进制文件进行反汇编和查看目标文件信息的能力。用于分析目标文件（object file）和可执行文件（executable file）。它可以显示二进制文件的汇编代码、符号表、段信息等，是理解程序底层实现、调试和逆向工程的有力助手。 一、objdump的基本用法显示目标文件的反汇编代码： 1objdump -d your_binary 该命令会显示目标文件中所有段的反汇编代码。这是一种深入了解程序执行逻辑的方式。 显示符号表信息： 1objdump -t your_binary 该命令会显示目标文件的符号表，包括函数名、变量名等信息。 显示文件头信息： 1objdump -f your_binary 该命令显示目标文件的文件头信息，包括文件格式、入口点地址等。objdump 的使用还可以根据需求加入一些参数来获取更详细的信息。 显示所有段的详细信息： 1objdump -p your_binary 这将显示目标文件中所有段的详细信息，包括每个段的大小、偏移量等。 显示特定段的反汇编代码： 1objdump -s -j section_name your_binary 这将显示指定段（section_name）的反汇编代码。 只显示符号表的信息： 1objdump -T your_binary 该命令显示符号表的信息，但不显示反汇编代码。 显示源代码和反汇编代码： 1objdump -S your_binary 这将显示源代码和反汇编代码的混合视图，方便理解源代码和汇编之间的对应关系。 以指定格式显示反汇编代码： 1objdump -M intel -d your_binary -M 参数允许你指定反汇编代码的输出格式，例如 intel 或 att。 以上是一些常见的 objdump 用法和参数。通过组合使用这些参数，你可以根据具体的需求更深入地了解目标文件的内部结构和代码执行逻辑。","tags":["Linux工具"],"categories":["Linux工具"]},{"title":"objcopy","path":"/posts/objcopy.html","content":"objcopy转换elf文件为bin文件，以下是一个将boot.elf转为boot.bin的命令 1arm-linux-objcopy -O binary -R .note -R .comment -S boot.elf boot.bin 使用 -O binary (或–out-target&#x3D;binary) 输出为原始的二进制文件 使用 -R .note (或–remove-section) 输出文件中不要.note这个section，缩小了文件尺寸 使用 -S (或 –strip-all) 输出文件中不要重定位信息和符号信息，缩小了文件尺寸","tags":["Linux工具"],"categories":["Linux工具"]},{"title":"nm","path":"/posts/nm.html","content":"nm命令是linux下针对某些特定文件的分析工具，能够列出库文件（.a、.lib）、目标文件（*.o）、可执行文件的符号表。 一、nm命令的常用参数 -A 或 -o 或 –print-file-name：打印出每个符号属于的文件 -a 或 –debug-syms：显示调试符号。 -B：等同于–format&#x3D;bsd，用来兼容MIPS的nm。 -C 或 –demangle：将低级符号名解码(demangle)成用户级名字。这样可以使得C++函数名具有可读性。 -D 或 –dynamic：显示动态符号。该任选项仅对于动态目标(例如特定类型的共享库)有意义。 -f forma 或 –format&#x3D;formatt：使用format格式输出。format可以选取bsd、sysv或posix，该选项在GNU的nm中有用。默认为bsd。 -g 或 –extern-only：仅显示外部符号。 -n 、-v 或 –numeric-sort：按符号对应地址的顺序排序，而非按符号名的字符顺序。 -p 或 –no-sort：按目标文件中遇到的符号顺序显示，不排序。 -P 或 –portability：使用POSIX.2标准输出格式代替默认的输出格式。等同于使用任选项-f posix。 -s 或 –print-armap：当列出库中成员的符号时，包含索引。索引的内容包含：哪些模块包含哪些名字的映射。 -r 或 –reverse-sort：反转排序的顺序(例如，升序变为降序)。 –size-sort：按大小排列符号顺序。该大小是按照一个符号的值与它下一个符号的值进行计算的。 -t radix 或 –radix&#x3D;radix：使用radix进制显示符号值。radix只能为“d”表示十进制、“o”表示八进制或“x”表示十六进制。 –target&#x3D;bfdname：指定一个目标代码的格式，而非使用系统的默认格式。 -u 或 –undefined-only：仅显示没有定义的符号(那些外部符号)。 -l 或 –line-numbers：对每个符号，使用调试信息来试图找到文件名和行号。对于已定义的符号，查找符号地址的行号。对于未定义符号，查找指向符号重定位入口的行号。如果可以找到行号信息，显示在符号信息之后。 -V 或 –version：显示nm的版本号。 –help：显示nm的任选项。 举个栗子 编写源文件test.c 1234567891011#include &lt;stdio.h&gt;const char ch = &#x27;x&#x27;;int uninit;int init = 10;void function() &#123; int *ref = &amp;init; static int sta_int = 10; printf(&quot;%c&quot;, ch);&#125; 编译test.c文件 生成test.o gcc -c test.c 用nm命令分析符号表 nm -n test.o（-n以地址排序，方便查看） 输出结果： 123456 U putchar0000000000000000 R ch0000000000000000 T function0000000000000000 D init0000000000000004 d sta_int.21820000000000000004 C uninit 二、nm信息的含义第一列：符号值，即该符号的起始地址第二列：符号类型，各字母代表什么类型在下一小节中介绍第三列：符号名称 三、输出符号类型详解符号类型大写代表全局符号，小写代表本地符号 A 该符号的值是绝对的，在以后的链接过程中，不允许进行改变。这样的符号值，常常出现在中断向量表中，例如用符号来表示各个中断向量函数在中断向量表中的位置。 B 该符号的值出现在非初始化数据段(bss)中。例如，在一个文件中定义全局static int test。则该符号test的类型为b，位于bss section中。其值表示该符号在bss段中的偏移。一般而言，bss段分配于RAM中。 C 该符号为common。common symbol是未初始话数据段。该符号没有包含于一个普通section中。只有在链接过程中才进行分配。符号的值表示该符号需要的字节数。例如在一个c文件中，定义int test，并且该符号在别的地方会被引用，则该符号类型即为C。否则其类型为B。 D 该符号位于初始话数据段中。一般来说，分配到data section中。例如定义全局int baud_table[5] &#x3D; {9600, 19200, 38400, 57600, 115200}，则会分配于初始化数据段中。 G 该符号也位于初始化数据段中。主要用于small object提高访问small data object的一种方式。 I 该符号是对另一个符号的间接引用。 N 该符号是一个debugging符号。 R 该符号位于只读数据区。例如定义全局const int test[] &#x3D; {123, 123};则test就是一个只读数据区的符号。注意在cygwin下如果使用gcc直接编译成MZ格式时，源文件中的test对应_test，并且其符号类型为D，即初始化数据段中。但是如果使用m6812-elf-gcc这样的交叉编译工具，源文件中的test对应目标文件的test,即没有添加下划线，并且其符号类型为R。一般而言，位于rodata section。值得注意的是，如果在一个函数中定义const char *test &#x3D; “abc”, const char test_int &#x3D; 3。使用nm都不会得到符号信息，但是字符串“abc”分配于只读存储器中，test在rodata section中，大小为4。 S 符号位于非初始化数据区，用于small object。 T 该符号位于代码区text section。 U 该符号在当前文件中是未定义的，即该符号的定义在别的文件中。例如，当前文件调用另一个文件中定义的函数，在这个被调用的函数在当前就是未定义的；但是在定义它的文件中类型是T。但是对于全局变量来说，在定义它的文件中，其符号类型为C，在使用它的文件中，其类型为U。 V 该符号是一个weak object。 W 该符号是没有被明确标记为weak object的弱符号类型。 该符号是a.out格式文件中的stabs symbol。 ? 该符号类型没有定义。","tags":["Linux工具"],"categories":["Linux工具"]},{"title":"readelf","path":"/posts/readelf.html","content":"一、三类目标文件（ELF）：1.可重定位目标文件 (.o ) 每个 .o 文件都是由对应的 .c 文件通过编译器和汇编器生成；包含代码和数据，代码和数据地址都从0开始。通过 gcc -c xxx.c 得到。 2.可执行目标文件（默认为a.out） 由链接器生成，包含的代码和数据可以直接通过加载器加载到内存中并被执行。通过gcc -o xxx.c 得到。 3.共享目标文件 (.so） 特殊的可重定位目标文件，可以在链接(静态共享库)时加入目标文件或加载时或运行时(动态共享库)被动态的加载到内存并执行。在 windows 中被称为 Dynamic Link Libraries(DLLs)。 gcc xxx.c -fPIC -shared -o libxxx.so （-fPIC 作用于编译阶段，告诉编译器产生与位置无关代码。） readelf命令： 通过readelf来区分上面三种类型的ELF文件，每种类型文件的头部信息是不一样的。 二、readelf -hreadelf -h main.o -h等价于–file-header 1234567891011121314151617181920 1 ELF Header: 2 Magic: 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 3 Class: ELF64 4 Data: 2&#x27;s complement, little endian 5 Version: 1 (current) 6 OS/ABI: UNIX - System V 7 ABI Version: 0 8 Type: REL (Relocatable file) 9 Machine: Advanced Micro Devices X86-6410 Version: 0x111 Entry point address: 0x012 Start of program headers: 0 (bytes into file)13 Start of section headers: 720 (bytes into file)14 Flags: 0x015 Size of this header: 64 (bytes)16 Size of program headers: 0 (bytes)17 Number of program headers: 018 Size of section headers: 64 (bytes)19 Number of section headers: 1220 Section header string table index: 11 第 1 行，ELF Header: 指名 ELF 文件头开始。 第 2 行，Magic 魔数，用来指名该文件是一个 ELF 目标文件。第一个字节 7F 是个固定的数；后面的 3 个字节正是 E, L, F 三个字母的 ASCII 形式。 第 3 行，CLASS 表示文件类型，这里是 64位的 ELF 格式。 第 4 行，Data 表示文件中的数据是按照什么格式组织(大端或小端)的，不同处理器平台数据组织格式可能就不同，如x86平台为小端存储格式。 第 5 行，当前 ELF 文件头版本号，这里版本号为 1 。 第 6 行，OS&#x2F;ABI ，指出操作系统类型，ABI 是 Application Binary Interface 的缩写。 第 7 行，ABI 版本号，当前为 0 。 第 8 行，Type 表示文件类型。ELF 文件有 3 种类型，一种是如上所示的 Relocatable file 可重定位目标文件，一种是可执行文件(Executable)，另外一种是共享库(Shared Library) 。 [这里就是区分上面三种类型的ELF文件] 第 9 行，机器平台类型，这里是在X86-64位机器。 第 10 行，当前目标文件的版本号。 第 11 行，程序的虚拟地址入口点，因为这还不是可运行的程序，故而这里为零。如果是可运行程序，这个地址并不是main函数的地址，而是_start函数的地址，_start由链接器创建，_start是为了初始化程序。通过这个命令可以看到_start函数，objdump -d -j .text a.out(默认，改名之后需更改此处)。 第 12 行，与 11 行同理，这个目标文件没有 Program Headers。 第 13 行，sections 头开始处，这里 720 是十进制，表示从地址偏移 0x450 处开始。 第 14 行，是一个与处理器相关联的标志，x86 平台上该处为 0 。 第 15 行，ELF 文件头的字节数。64bytes 第 16 行，因为这个不是可执行程序，故此处大小为 0。 第 17 行，同理于第 16 行。 第 18 行，sections header 的大小，这里每个 section 头大小为 64bytes。 第 19 行，一共有多少个 section 头，这里是 12个。 第 20 行，section 头字符串表索引号。区中存储的信息是用来链接使用的，主要包括：程序代码、程序数据（变量）、重定向信息等。比如：Code section保存的是代码，data section保存的是初始化或未初始化的数据，等等。 三、readelf -S main功能：查看区内容 1234567891011121314151617181920212223242526272829303132333435361 There are 29 section headers, starting at offset 0x1948: 2 Section Headers: 3 [Nr] Name Type Address Offset Size EntSize Flags Link Info Align 4 [ 0] NULL 0000000000000000 00000000 0000000000000000 0000000000000000 0 0 0 5 [ 1] .interp PROGBITS 0000000000000238 00000238 000000000000001c 0000000000000000 A 0 0 1 6 [ 2] .note.ABI-tag NOTE 0000000000000254 00000254 0000000000000020 0000000000000000 A 0 0 4 7 [ 3] .note.gnu.build-i NOTE 0000000000000274 00000274 0000000000000024 0000000000000000 A 0 0 4 8 [ 4] .gnu.hash GNU_HASH 0000000000000298 00000298 000000000000001c 0000000000000000 A 5 0 8 9 [ 5] .dynsym DYNSYM 00000000000002b8 000002b8 0000000000000090 0000000000000018 A 6 1 810 [ 6] .dynstr STRTAB 0000000000000348 00000348 000000000000007d 0000000000000000 A 0 0 111 [ 7] .gnu.version VERSYM 00000000000003c6 000003c6 000000000000000c 0000000000000002 A 5 0 212 [ 8] .gnu.version_r VERNEED 00000000000003d8 000003d8 0000000000000020 0000000000000000 A 6 1 813 [ 9] .rela.dyn RELA 00000000000003f8 000003f8 00000000000000c0 0000000000000018 A 5 0 814 [10] .init PROGBITS 00000000000004b8 000004b8 0000000000000017 0000000000000000 AX 0 0 415 [11] .plt PROGBITS 00000000000004d0 000004d0 0000000000000010 0000000000000010 AX 0 0 1616 [12] .plt.got PROGBITS 00000000000004e0 000004e0 0000000000000008 0000000000000008 AX 0 0 817 [13] .text PROGBITS 00000000000004f0 000004f0 00000000000001e2 0000000000000000 AX 0 0 1618 [14] .fini PROGBITS 00000000000006d4 000006d4 0000000000000009 0000000000000000 AX 0 0 419 [15] .rodata PROGBITS 00000000000006e0 000006e0 0000000000000004 0000000000000004 AM 0 0 420 [16] .eh_frame_hdr PROGBITS 00000000000006e4 000006e4 0000000000000044 0000000000000000 A 0 0 421 [17] .eh_frame PROGBITS 0000000000000728 00000728 0000000000000128 0000000000000000 A 0 0 822 [18] .init_array INIT_ARRAY 0000000000200df0 00000df0 0000000000000008 0000000000000008 WA 0 0 823 [19] .fini_array FINI_ARRAY 0000000000200df8 00000df8 0000000000000008 0000000000000008 WA 0 0 824 [20] .dynamic DYNAMIC 0000000000200e00 00000e00 00000000000001c0 0000000000000010 WA 6 0 825 [21] .got PROGBITS 0000000000200fc0 00000fc0 0000000000000040 0000000000000008 WA 0 0 826 [22] .data PROGBITS 0000000000201000 00001000 0000000000000018 0000000000000000 WA 0 0 827 [23] .bss NOBITS 0000000000201018 00001018 0000000000000008 0000000000000000 WA 0 0 128 [24] .comment PROGBITS 0000000000000000 00001018 000000000000002b 0000000000000001 MS 0 0 129 [25] .symtab SYMTAB 0000000000000000 00001048 0000000000000600 0000000000000018 26 43 830 [26] .strtab STRTAB 0000000000000000 00001648 0000000000000200 0000000000000000 0 0 131 [27] .shstrtab STRTAB 0000000000000000 00001848 00000000000000f9 0000000000000000 0 0 132 Key to Flags:33 W (write), A (alloc), X (execute), M (merge), S (strings), I (info),34 L (link order), O (extra OS processing required), G (group), T (TLS),35 C (compressed), x (unknown), o (OS specific), E (exclude),36 l (large), p (processor specific) .text：已编译程序的机器代码（二进制指令），该区的标志为X表示可执行。 .rodata：只读数据，比如printf语句中的格式串和开关（switch）语句的跳转表。 .data：已初始化的全局C变量。局部C变量在运行时被保存在栈中，既不出现在.data中，也不出现在.bss节中。 .bss：未初始化的全局C变量。在目标文件中并没有分配实际的空间给它，它只是一个占位符。目标文件格式区分初始化和未初始化变量是为了空间效率在：在目标文件中，未初始化变量不需要占据任何实际的磁盘空间。 .symtab：一个符号表（symbol table），它存放在程序中被定义和引用的函数和全局变量的信息。一些程序员错误地认为必须通过-g选项来编译一个程序，得到符号表信息。实际上，每个可重定位目标文件在.symtab中都有一张符号表。然而，和编译器中的符号表不同，.symtab符号表不包含局部变量的表目。 .rel.text：当链接噐把这个目标文件和其他文件结合时，.text节中的许多位置都需要修改。一般而言，任何调用外部函数或者引用全局变量的指令都需要修改。另一方面调用本地函数的指令则不需要修改。注意，可执行目标文件中并不需要重定位信息，因此通常省略，除非使用者显式地指示链接器包含这些信息。 .rel.data：被模块定义或引用的任何全局变量的信息。一般而言，任何已初始化全局变量的初始值是全局变量或者外部定义函数的地址都需要被修改。 .strtab：一个字符串表，其内容包括.symtab和.debug节中的符号表，以及节头部中的节名字。字符串表就是以null结尾的字符串序列。 .init和.fini保存了进程初始化和结束所用的代码，这通常是由编译器自动添加的。 四、readelf -sreadelf -s main.o 功能：查看符号表，Value的值是符号的地址。 1234567891011121314Symbol table &#x27;.symtab&#x27; contains 12 entries: Num: Value Size Type Bind Vis Ndx Name 0: 0000000000000000 0 NOTYPE LOCAL DEFAULT UND 1: 0000000000000000 0 FILE LOCAL DEFAULT ABS main.c 2: 0000000000000000 0 SECTION LOCAL DEFAULT 1 3: 0000000000000000 0 SECTION LOCAL DEFAULT 3 4: 0000000000000000 0 SECTION LOCAL DEFAULT 4 5: 0000000000000000 0 SECTION LOCAL DEFAULT 6 6: 0000000000000000 0 SECTION LOCAL DEFAULT 7 7: 0000000000000000 0 SECTION LOCAL DEFAULT 5 8: 0000000000000000 8 OBJECT GLOBAL DEFAULT 3 array 9: 0000000000000000 33 FUNC GLOBAL DEFAULT 1 main 10: 0000000000000000 0 NOTYPE GLOBAL DEFAULT UND _GLOBAL_OFFSET_TABLE_ 11: 0000000000000000 0 NOTYPE GLOBAL DEFAULT UND sum 符号表保存了程序实现或使用的所有全局变量和函数，如果程序引用一个自身代码未定义的符号，则称之为未定义符号，这类引用必须在静态链接期间用其他目标模块或库解决，或在加载时通过动态链接解决。","tags":["Linux工具"],"categories":["Linux工具"]},{"title":"dm-verity","path":"/posts/dm-verity.html","content":"一、技术模块简介 Dm-verity 是 device-mapper 架构下的一个目标设备类型， 通过它来保障设备或者设备分区的完整性。 dm-verity通常用于验证镜像的完整性。比如常规的系统启动的对根文件系统的验签，耗时很长。可以使用dm-verity替代，由于dm-verity是使用时才进行hash计算校验，所以对启动性能的提高有很大帮助。 Dm-verity类型的目标设备有两个底层设备，一个是数据设备(data device), 是用来存储实际数据的，另一个是hash设备(hash device), 用来存储hash数据的，这个是用来校验data device数据的完整性的。 简单的架构图如下： 图中映射设备(Mapper Device)和目标设备(Target Device)是一对一关系，对映射设备的读操作被映射成对目标设备的读操作，在目标设备中，dm-verity又将读操作映射为数据设备（Data Device）的读操作。但是在读操作的结束处，dm-verity加了一个额外的校验操作，对读到的数据计算一个hash值，用这个哈希值和存储在哈希设备(Hash Device) 二、设计原理 对于本文要介绍的dm-verity功能模块，笔者选择在当前移动终端应用的角度来展开讲解，也就是Android平台在dm-verity的应用。 Android 端主要是在镜像启动时验证这个功能场景上使用到了 dm-verity 技术，该技术可以对块存储设备进行完整性检查，有助于阻止某些恶意程序对镜像的修改，有助于Android用户在启动设备时确认设备状态与上次使用时是否相同。在系统镜像(比如 system、vendor等)启动时以及运行时可以实时性监测当前镜像是否被篡改。 通过dm-verity技术，可以确认块设备内容是否跟预期一致，具体的实现原理是利用哈希树(hashtree)做到的。用以下图来形象说明 (图来自：https://source.android.com/security/verifiedboot/dm-verity) 简单说明一下这个插图背后的原理： 在编译(一般应该是运行open)阶段，首先会对系统镜像(比如system.img、vendor.img)按照每4k大小计算对应hash，将这些hash信息存起来，形成上面图中的layer 0层，紧接着会对 layer 0 层同样按照每4k大小计算hash，并将这层的hash信息存起来，形成layer 1层，以此类推，直至最后的hash信息存放在一个4k大小的块中(未填满使用0填充)，这里边存储的hash信息称为 root hash。 在运行阶段，对于镜像里的文件进行访问时，操作对应所在块设备的存储区域时，会计算当前存储块(按4k大小)的hash值，然后会跟存储在哈希树上对应块的hash值进行比较，如果匹配不上，则认为当前该文件在底层存储被篡改或是损坏了。 为了更形象的描述下镜像运行时如何利用哈希树做校验的，下面以一个1G大小的镜像为例，来说明一下这个过程： 根据 hashtree 的生成方式，以 1G 的镜像为例： 1）按照 4K 大小划分，将1G 大小的镜像依顺序划分可得到 262144 个 4k 大小的块 2）对这 262144 块数据块进行第一层(Level 0) hash 计算，由于 SHA256(具体的hash算法可配置，此例以SHA256为参考) 计算出来的hash值占 256 个字节，一个 4K 的块可以存储 128 个hash值，所以存储这 262144 块数据块的hash值需要花费 2048 块 3）对第一层存储 hash 值的数据块进行第二层(Level 1) 的 hash 计算，同理，计算这 2048 块hash数据块需要花费 16 块 4）对第二层存储 hash 值的数据块进行第三层(Level 2) 的 hash 计算，由于第二层的hash数据块小于128块，所以第三层是最后一层，直接计算得到 root hash 数据块(不够4K大小补齐0)。 细心的读者可能已经发现了，Level 0 层其实已经包含了所有raw data数据块的hash信息了，也就说明Level 0 层已经具备可以验证 raw data 的能力了，为何还需要在 Level 0 的基础上继续算hash组装下一个 Level 层级呢？ 这里要引入一个安全策略设计问题，镜像raw data数据块是由对应的hash信息来校验保证的，为了保证镜像raw data是我们“想要的”，我们还需要对 hash 信息进行合法性验证，简单理解就是要确认这个hash信息是我们“想要的”， 方法就是对这个hash信息再次计算一次hash值，这里称为 root hash，然后添加一些类似于签名保护并保存起来（通常在实际工作中，在镜像编译阶段将root hash计算出来，保存在镜像的某个地方，通过cms等签名方式保存，启动阶段会进行cms验签以保证root_hash的正确性），主要是为了防止 root hash 被非法篡改。在一次 raw data 数据块的校验过程中，需要对 hash 信息计算一次 hash，然后跟保存的 root hash 进行比较，验证了 hash 信息的合法性之后，再来校验对应的 raw data 数据块。 有了以上背景，再回到刚刚这个“为何还需要在 Level 0 的基础上继续算hash组装下一个 Level 层级”的问题，按照上面的安全策略，如果 hash 信息只有 Level 0 一层的话，接下来对 raw data 数据块的校验将会是这样：每操作一个raw data数据块，都需要计算一次 Level 0 的 hash 值，跟 root hash 进行比较，验证合法之后再对 raw data 数据块进行校验。本文中举例是 1G 的镜像，Level 0用来保存 hash 信息的数据块已经达到 2048 块，如果对面对更大的镜像，Level 0 所占的数据块也会更大，如果是按照上面的计算方法，对 raw data 数据块的校验效率将会非常非常低。 作为对比，哈希树机制是如何体现出效率呢，下面以具体某一块 raw data 数据块的读取过程来说明其设计原理： 1）假设目前正需要读取第 200000 块的数据块，通过前面哈希树的构造，可以比较快速的计算出在 Level 0 层，也就是直接对应这个数据块的hash值存储位置，通过对 128 相除以及求余的方式就可以分别计算出该 hash 值存储在具体某一块(块A)以及这一块上的偏移(偏移A)。 2）确定了 Level 0 层的具体块A后，利用相同的方式可以得到 Level 0 块A在 Level 1 层存储其 hash 值的块B位置以及块B上的偏移(偏移B) 3）同上述原理，可以最终定位到 Level 1 层块 B 在 Level 2 上的数据块(只有一块)上偏移(偏移C) 4）在获取到该数据块对应hashtree关联的各个层级的块以及偏移后，接下来就是做一层一层的验证： 步骤1. 优先验证的是Level 2 中的数据块(只有一个4k的数据块)， 计算这个数据块的hash，跟保存的 root hash进行比对，验证Level 2的数据块块是否正确。 步骤2. 在Level 2中的数据块得到验证后，由上面计算到的Level 2中数据块上的偏移 C 去校验 Level 1 层的 B 块。 步骤3. 在 Level 1 层的 B 数据块得到验证后，由上面计算到的 Level 1 中 B 数据块上的偏移B去验证 Level 0 层的 A块。 步骤4. Level 0层中的 A 数据块得到验证后，最终会由 Level 0 层的偏移A来校验最终的 raw data数据块(第 200000 块). 可以看到，在使用哈希树的设计之后，对数据块验证整个过程中，涉及到的数据块hash计算只有3块(有N层就计算N块)，相比于一层校验模式，效率要高很多。 三、应用层面 读者到目前为止应该大致了解到了移动终端在镜像完整性校验上相关的设计原理，接下来会从应用端层面来说明如何使用 dm-verity 底层提供的接口来初始化 dm 设备，并为后续实时校验做好准备，内核绝大多数功能模块存在的意义都要靠跟应用端的交互来体现，作为对内核某个模块的研究，初步从应用层出发不乏是一个好办法。 通常系统启动阶段，使用veritysetup工具指定data device和hash device，以及指定的root hash值，hash device的具体位置，hash device通常位于data device的后面一部分。通过veritysetup工具执行后，会生成dm设备，如我们原来使用的文件系统为&#x2F;dev&#x2F;sda3，则此时可以生成一个dm设备为sda3-dm，后续通过mount挂载sda3-dm到&#x2F;sysroot即可实现挂载根文件系统，后续读取根文件系统数据，均会通过sda3-dm设备中转，通过IO定向映射访问&#x2F;dev&#x2F;sda3，并进行hash校验 如下为veritysetup应用层的3个常规步骤： 步骤一. Create dm device 创建 dm 设备主要有如下小步骤： open &#x2F;dev&#x2F;device-mapper 设备节点 传入逻辑分区name、随机生成的uuid参数，调用 DM_DEV_CREATE ioctl 命令 步骤二. Load verity table 这里需要引入一个 verity table 的概念，先简单介绍以下 verity table 所包含的内容： 1）Verity target version(verity target 版本号) 2）Data block device(存储实际待校验数据的块设备) 3）Hash block device(存储校验使用到hash的块设备，一般情况跟data block device是同一个) 4）Data block size(数据块设备的每块存储size) 5）Hash block size（hash块设备的每块存储size） 6）Num data block(数据块设备占用的块数量) 7）Hash start block(hash设备在存储设备的起始位置) 8）Hash algo(hash算法) 9）root digest(对应上面说的 root hash) 10）Salt(用于计算hash的盐值) 这些信息主要是跟最终数据块在校验计算过程中会被使用到的，比如说 hash 设备的起始位置、hash算法、root hash、salt，这些都在实际运行时校验数据块时会用到，这些信息是存储是镜像的固定位置上，这些信息在编译阶段构建镜像的时候就已经计算好的，并存储在镜像的固定位置。 Verity table 初始化代码具体如下： 上层通过从镜像固定位置获取到信息并初始化好 verity table， 通过调用DM_TABLE_LOAD Ioctl 命令将 verity table 传递至kernel。 步骤三. Active dm device 调用DM_DEV_SUSPEND ioctl 指令激活 dm device，对应底层，该 cmd 对应 suspend &amp; resume的实现，如果不设置 DM_SUSPEND_FLAG 标志位，默认走 resume 流程。 应用端在实现上比较简单，主要通过 create -&gt; load verity table -&gt; active dm device 的流程完成了对dm设备的创建、verity table的读取以及传递以及dm设备的激活，为后续实时进行的数据块校验做好了初始化工作。 四、内核层面 有了以上应用层面的流程讲解，那对应内核，自然而然就是对每一步应用端的系统调用做对应的内核实现做讲解。 相应的，内核层面也有以下3个步骤： 步骤一. dev_create 对应应用端的DM_DEV_CREATE ioctl cmd，kernel端的大致实现如下： 这部分比较简单： 1). 检测传入参数的partition name是否合法 2). 开始尝试分配内存初始化 mapped device 结构体以及分配设备minor号（最终用于 dm 设备的设备号，比如 dm-1），使用内核提供的blk_queue_make_request函数注册该mapped device对应的请求队列dm_make_request, 该请求队列最终会在IO重定向中被使用到。并将该mapped device作为磁盘块设备注册到内核中。 3). 将创建好的mapped device插入到一个全局hash表中，该表中保存了内核中当前创建的所有mapped device。 步骤二. dm_ctl_ioctl(DM_TABLE_LOAD_CMD(table_load)) 对应应用端的DM_TABLE_LOAD ioctl cmd，kernel端的大致实现可看下面的思维导图： 总的来说，这个步骤主要是根据入参初始化相应的dm_table、dm_target结构，并且根据参数所指定的target类型，调用相应的target类型的构建函数ctr在内存中构建target device， 在结构上形成 dm_table –&gt; dm_target –&gt; target type –&gt; target device 的链路结构。 步骤三. dm_ctl_ioctl(DM_DEV_SUSPEND_CMD(dev_suspend)) 很显然，这一个步骤主要是建立 mapped device 与 dm_table 的关联。 通过以上几个步骤，在内核中就建立一个可以提供给用户使用的mapped device逻辑块设备 综上涉及到了几个关键的数据结构： mapped device、dm_table、dm_target、target_type、target device(以dm-verity为例) 其实这几个步骤主要是对上述数据结构进行初始化，并且更重要是互相建立了关联关系。他们之间的关联关系如下： 内核经过了这3个步骤，一方面是创建了一个可以提供给应用端使用的 mapped device 逻辑块设备，另一方面是内部建立了 mapped device - target device 的联系， 应用层可以通过对 mapped device 进行策略逻辑操作，最终会通过 mapped device - target device 的联系作用到 对应的target device 上。 五、核心数据流 在上面介绍了dm-verity的设计原理、应用层面以及内核层面的实现之后，读者可能比较关心整个链路的数据流，或者说镜像在校验链路具体流程是如何的，接下来以下主要是围绕着访问镜像文件时的IO流是如何的。 上面说到，应用层在经过 create -&gt; load verity table -&gt; active dm device 的流程完成了dm块设备的初始化工作，之后应用层会对该逻辑块设备进行文件系统挂载，在挂载的过程中，需要访问到实际存储设备(读取文件系统的super block等)，这个过程中就需要透过这个逻辑块设备，最终操作到与其关联的target device。 在这个过程中， 对块设备的IO请求会从逻辑设备mapped device转发相应的target device上，并且会根据对应target_type描述的IO处理规则对IO请求进行处理。以本文讨论的 dm-verity 类型的 target device 来说，对于 mapped device 转发过来的IO，会在 hashtree 里找到该 IO data 对应的 hash 数据，并进行比较，完成校验，返回此次的校验结果并结束本次IO请求。 同时dm-verity通常有两种模式，一般可以通过上述说的veritysetup工具或自研工具指定，两种模式为EIO模式和Loggin模式，EIO模式在校验到数据块的hash不对时直接返回错误，而Loggin模式在校验错误还可以正常使用，Loggin一般为debug使用","tags":["dm-verity"],"categories":["dm-verity"]},{"title":"98、验证二叉搜索树","path":"/posts/98、验证二叉搜索树.html","content":"一、题目描述给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。 有效 二叉搜索树定义如下： 节点的左子树只包含 小于 当前节点的数。节点的右子树只包含 大于 当前节点的数。所有左子树和右子树自身必须也是二叉搜索树。 示例 1： 输入：root &#x3D; [2,1,3]输出：true 示例 2： 输入：root &#x3D; [5,1,4,null,null,3,6]输出：false解释：根节点的值是 5 ，但是右子节点的值是 4 。 提示： 树中节点数目范围在[1, 10^4] 内-2^31 &lt;&#x3D; Node.val &lt;&#x3D; 2^31 - 1 二、C语言代码根据二叉搜索树的性质，二叉搜索树的中序遍历后，结果为有序且从小到大，所以我们遍历二叉树，将结果保存到数组中，然后判断数组是否有序即可。 12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * struct TreeNode *left; * struct TreeNode *right; * &#125;; */bool isValidBST(struct TreeNode* root) &#123; int returnSize = 0; int *res = (int *)malloc(10000 * sizeof(int)); if (res == NULL) &#123; return false; &#125; traverse(root, res, &amp;returnSize); for (int i = 0; i &lt; returnSize - 1; i++) &#123; if (res[i] &gt;= res[i + 1]) &#123; return false; &#125; &#125; return true;&#125;void traverse(struct TreeNode* root, int *res, int *returnSize) &#123; if (root == NULL) &#123; return; &#125; traverse(root-&gt;left, res, returnSize); res[*returnSize] = root-&gt;val; (*returnSize)++; traverse(root-&gt;right, res, returnSize);&#125;","tags":["二叉树"],"categories":["二叉树"]},{"title":"96、不同的二叉搜索树","path":"/posts/96、不同的二叉搜索树.html","content":"一、题目描述给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。 示例 1：输入：n &#x3D; 3输出：5示例 2： 输入：n &#x3D; 1输出：1 提示：1 &lt;&#x3D; n &lt;&#x3D; 19 二、C++代码解法一： 这种题目，我一般是计算出前面多个例子，根据计算出来的多个例子，进行归纳总结，利用数学归纳法，找规律，推算出第n个的结果，然后利用类似如下方法，根据第0个，第1个，第2个……，以此计算出第n个。 n&#x3D;1,搜索二叉树种数：1 ,只有一个节点，所以为1 n&#x3D;2,搜索二叉树种数：2 ,只有二个节点，要么1为根节点，要么2为根节点，所以结果为2 n&#x3D;3,搜索二叉树种数：5 ,有三个节点(1)、1为根节点，另外两个节点，均大于1，根据二叉搜索树的性质，大于根节点的数字，即另外两个节点2和3只能作为右子树，再作为一个整体，构成二叉搜索树，此时另外两个节点构成结果等同于n&#x3D;2时的结果，为2(2)、2为根节点，根据二叉搜索树性质，1只能作为左子树，3只能作为右子树，只有一种情况，所以结果为1(3)、3为根节点，根据二叉搜索树性质，1和2只能作为左子树,1和2作为一个整体再构成二叉搜索树，此时与(1)一样，结果等于n&#x3D;2时的结果为2所以n&#x3D;3时，搜索二叉树种数为2+1+2&#x3D;5 n&#x3D;4,搜索二叉树种数：14(1)、1为根节点，另外三个节点，均大于1，另外节点只能作为右子树，其他节点再作为一个整体，构成二叉搜索树，此时另外三个节点构成结果等同于n&#x3D;3时的结果，为5(2)、2为根节点，根据二叉搜索树性质，1只能作为左子树，3,4只能作为右子树，此时进行排列组合，即为n&#x3D;1和n&#x3D;2的结果相乘，为2(3)、3为根节点，结果等于(2)时的结果为2(3)、4为根节点，结果等于(1)时的结果为5 n&#x3D;5,搜索二叉树种数：42……所以我总结规律为当输入数字为100,结果应该为n=0 * n=99 + n=1 * n=98 + …… + n=99 * n=0, n&#x3D;0时为1 1234567891011121314151617181920212223242526class Solution &#123;public: int numTrees(int n) &#123; int i = 0; int res = 0; if (n == 0) &#123; return 1; &#125; if (n == 1) &#123; return 1; &#125; if (n == 2) &#123; return 2; &#125; if (n == 3) &#123; return 5; &#125; for (i = 0; i &lt; n; ++i) &#123; res += (numTrees(i) * numTrees(n- 1 - i)); &#125; return res; &#125;&#125;; 解法二：解法一比较耗时，所以在解法一基础上进行优化，可以把中间的结果都保存到数组nums中，后续就不需要每次都遍历才拿到结果了。 1234567891011121314151617181920212223class Solution &#123;public: int numTrees(int n) &#123; vector&lt;int&gt; nums(20, 0); nums[0] = 1; traverse(n, nums); return nums[n]; &#125; int traverse(int n, vector&lt;int&gt; &amp;nums) &#123; int res = 0; int i = 0; if (nums[n] != 0) &#123; return nums[n]; &#125; for (i = 0; i &lt; n; ++i) &#123; nums[n] += (traverse(i, nums) * traverse(n- 1 - i, nums)); &#125; return nums[n]; &#125;&#125;; 解法3：动态规划，后续再写具体思路吧： 123456789101112class Solution &#123;public: int numTrees(int n) &#123; // 二叉搜索数的特征，左子树小于根，右子树大于根 vector&lt;int&gt; dp(n+1, 0); dp[0]=1; // dp[0]初始化为1 for(int i=1; i&lt;=n; i++) // 从1...n的二叉搜索数数目 for(int j=1; j&lt;=i; j++) // 逐步选用1...n作为根节点 dp[i]+=dp[j-1]*dp[i-j]; // 左侧j-1个数，右侧i-j个数 return dp[n]; &#125;&#125;;","tags":["二叉树"],"categories":["二叉树"]},{"title":"94、二叉树的中序遍历","path":"/posts/94、二叉树的中序遍历.html","content":"一、题目描述给定一个二叉树的根节点root，返回它的中序遍历 。 示例 1： 输入：root &#x3D; [1,null,2,3]输出：[1,3,2]示例 2： 输入：root &#x3D; []输出：[]示例 3： 输入：root &#x3D; [1]输出：[1] 提示： 树中节点数目在范围 [0, 100] 内-100 &lt;&#x3D; Node.val &lt;&#x3D; 100 进阶: 递归算法很简单，你可以通过迭代算法完成吗？ 二、C语言题解递归算法很简单，只需要按照左右根的顺序递归即可，代码如下：不过需要注意的是，leetcode中尽量最好不要使用全局变量吧，因为leetcode网站的题目，所有的用例是共享全局变量的，也就是第一个用例执行完后，第二个用例会继承第一个用例执行后的全局变量的值，导致后续的用例执行失败 123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * struct TreeNode *left; * struct TreeNode *right; * &#125;; *//** * Note: The returned array must be malloced, assume caller calls free(). */int* inorderTraversal(struct TreeNode* root, int* returnSize) &#123; int* res = (int *)malloc(100 * sizeof(int)); if (res == NULL) &#123; return NULL; &#125; *returnSize = 0; traverse(root, res, returnSize); return res;&#125;void traverse(struct TreeNode* root, int* res, int* returnSize)&#123; if (root == NULL) &#123; return; &#125; traverse(root-&gt;left, res, returnSize); res[*returnSize] = root-&gt;val; (*returnSize)++; traverse(root-&gt;right, res, returnSize);&#125; 迭代方法： 三、C++题解递归方法： 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; traverse(root, res); return res; &#125; void traverse(TreeNode* root, vector&lt;int&gt; &amp;res) &#123; if (root == nullptr) &#123; return; &#125; traverse(root-&gt;left, res); res.push_back(root-&gt;val); traverse(root-&gt;right, res); &#125;&#125;;","tags":["二叉树"],"categories":["二叉树"]},{"title":"二叉树算法核心纲领","path":"/posts/二叉树算法核心纲领.html","content":"一、二叉树基本概念二叉树二叉搜索树完全二叉树 二、二叉树的前中后序遍历二叉树的前中后序对应的不只是三种顺序不同的列表。前中后序是遍历二叉树过程中处理每一个节点的三个特殊时间点，绝不仅仅是三个顺序不同的 List：前序位置的代码在刚刚进入一个二叉树节点的时候执行；后序位置的代码在将要离开一个二叉树节点的时候执行；中序位置的代码在一个二叉树节点左子树都遍历完，即将开始遍历右子树的时候执行。 三、二叉树解题的思维方式1、是否可以通过遍历一遍二叉树得到答案？如果可以，用一个 traverse 函数配合外部变量来实现，这叫「遍历」的思维模式。 2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「分解问题」的思维模式。 无论使用哪种思维模式，你都需要思考： 如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前&#x2F;中&#x2F;后序位置）做？其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作。 四、后序位置的特殊之处五、二叉树的层序遍历六、N叉树","tags":["二叉树"],"categories":["二叉树"]},{"title":"dd命令","path":"/posts/dd命令.html","content":"dd命令可以从一个文件或设备向另一个文件或设备进行复制 一、dd命令常用语法1dd if=input_file of=output_file [options] options是一些可选参数，if和of是必须有的 if 表示输入文件 of 表示输出文件 bs：设置每次读取和写入的块大小（单位为字节或者是可以添加的后缀，如b、k、m等），默认为512字节。 count：设置要复制的块数。 iflag：设置输入选项，常用的选项有direct（绕过缓存直接读取）和sync（同步数据到磁盘）。 oflag：设置输出选项，常用的选项有direct（绕过缓存直接写入）和sync（同步数据到磁盘）。 skip&#x3D;xxx 是在备份时对if 后面的部分也就是原文件跳过多少块再开始备份； seek&#x3D;xxx则是在备份时对of 后面的部分也就是目标文件跳过多少块再开始写 二、dd常用命令-读磁盘1dd if=/dev/sde1 of=tee-test.img bs=1M skip=4 count=16 含义为从&#x2F;dev&#x2F;sde1设备起始位置，跳过4M，读取16M内容到tee-test.img中想要查看tee-test.img，可以使用hexdump命令 1hexdump -C tee-test.img 只查看部分内容，例如前100个字节： 1hexdump -C -n 100 tee-test.img 三、dd常用命令-写磁盘1dd if=/dev/zero of=/dev/sda bs=1k seek=8224 count=32 含义为从&#x2F;dev&#x2F;zero中也就是将后面的of目标文件写0，将&#x2F;dev&#x2F;sda设备的起始地址，跳过8224KB后，连续写入32KB 0数据 四、通过fdisk -l确认分区的实际起始地址使用fdisk -l显示磁盘分区情况 12345678# fdisk -lDisk /dev/sde: 19.16 GB, 20577255424 bytes, 5023744 sectorsSector size (logical/physical): 4096 bytes / 4096 bytes Device Start End/dev/sde1 256 131327 这里显示sde1的起始地址为256，那么实际地址为：256 ✖️ 4096 &#x3D; 1048576 &#x3D; 1024 ✖️ 1024 &#x3D; 1MB，所以sde1的位置为&#x2F;dev&#x2F;sde的起始地址偏移1M，其实起始1M，存放的应该是磁盘分区信息","tags":["Linux工具"],"categories":["Linux工具"]},{"title":"Makefile基础语法","path":"/posts/Makefile基础语法.html","content":"一、Makefile规则一个简单的 Makefile 文件包含一系列的“规则”，其样式如下： 12目标(target)…: 依赖(prerequiries)…&lt;tab&gt;命令(command) 目标(target)通常是要生成的文件的名称，可以是可执行文件或OBJ文件， 也可以是一个执行的动作名称，诸如‘ clean ’。依赖是用来产生目标的材料(比如源文件)，一个目标经常有几个依赖。命令是生成目标时执行的动作，一个规则可以含有几个命令，每个命令占一行。注意：每个命令行前面必须是一个 Tab 字符，即命令行第一个字符是 Tab。这是容易出错的地方。通常，如果一个依赖发生了变化，就需要规则调用命令以更新或创建目标。 但是并非所有的目标都有依赖，例如，目标“ clean ”的作用是清除文件，它有依赖。 一个 Makefile 文件可以包含规则以外的其他文本，但一个简单的 Makefile 文件仅仅需要包含规则。虽然真正的规则比这里展示的例子复杂，但格式是完全一样的 二、make命令介绍make 命令的使用： 执行 make 命令时，它会去当前目录下查找名为“Makefile”的文件，并根 据它的指示去执行操作，生成第一个目标。我们可以使用“ -f ”选项指定文件，不再使用名为“Makefile”的文件，比 如： 1make -f Makefile.build 我们可以使用“ -C ”选项指定目录，切换到其他目录里去，比如： 1make -C a/ -f Makefile.build 我们可以指定目标，不再默认生成第一个目标： 1make -C a/ -f Makefile.build other_target 三、Makefile变量介绍1234A = xxx // 延时变量B ?= xxx // 延时变量，只有第一次定义时赋值才成功；如果曾定义过，此赋值无效C := xxx // 立即变量D += yyy // 如果 D 在前面是延时变量，那么现在它还是延时变量；// 如果 D 在前面是立即变量，那么现在它还是立即变量 四、Makefile通配符&amp;一些符号%通配符 %.o：表示所用的.o文件%. %.c：表示所有的.c文件 $@：表示目标$&lt;：表示第一个依赖文件$^：表示所有依赖文件 五、Makefile假想目标我们的 Makefile 中有这样的目标： 123clean: rm -f $(shell find -name &quot;\\*.o&quot;) rm -f $(TARGET) 如果当前目录下恰好有名为“clean”的文件，那么执行“ make clean ”时它 就不会执行那些删除命令。这时我们需要把“ clean ”这个目标，设置为“假想目标”，这样可以确保执行“ make clean ”时那些删除命令肯定可以得到执行。 使用下面的语句把“clean”设置为假想目标： 1.PHONY : clean 六、Makefile常用函数1.$(foreach var,list,text)简单地说，就是 for each var in list, change it to text。对 list 中的每一个 元素，取出来赋给 var，然后把 var 改为 text 所描述的形式。 2.$(wildcard pattern)pattern 所列出的文件是否存在，把存在的文件都列出来。 3.$(filter pattern…,text)把 text 中符合 pattern 格式的内容，filter(过滤)出来、留下来。 4.$(filter-out pattern…,text)把 text 中符合 pattern 格式的内容，filter-out(过滤)出来、扔掉。 5.$(patsubst pattern,replacement,text)寻找’ text ‘中符合格式’ pattern ‘的字，用’ replacement ‘替换它们。 ‘ pattern ‘和’ replacement ‘中可以使用通配符。 七、Makefile的例子，包含子目录八、Makefile中的EXTRA_CFLAGSEXTRA_CFLAGS是Makefile中预定义的一个变量，作为CFLGAS，在make时可以传递给gcc一些编译选项等，如—O2 EXTRA_CFLAGS +&#x3D; -D等价于gcc -D，相当于在源代码中定义一个宏假如定义一个宏CONFIG_DEBUG在.c里面定义为：#define CONFIG_DEBUG在makefile里定义为: CONFIG_DEBUG&#x3D;y 假如说我们想在makefile里为.c文件进入一个宏定义，就用EXTRA_CFLAGS +&#x3D; DCONFIG_DEBUG( 等价于在.c文件里定义#define CONFIG_DEBUG) 这时CONFIG_DEBUG&#x3D;y与EXTRA_CFLAGS +&#x3D; DCONFIG_DEBUG的区别应该你已经看出来的，前者是对makefile编译时用的，比如说obj-(CONFIG_DEBUG) +&#x3D; test.o,而后者则是对.c源文件里的用的 九、Makefile编译内核驱动ko内核源代码中obj-m表示以模块ko的方式编译obj-y表示将源代码编译到内核源码中在工作的过程中，经常需要编译一些Ko模块，如果是单个的c文件编译直接在内核源码里面 obj-y&#x3D;xxx.o就好如果这个ko文件需要多个c文件共同编译生成的话，最好以如下的模板来完成编译较好 1234567891011121314151617181920212223242526272829303132#首先指定好编译链工具CROSS_COMPILE=/opt/gcc-linaro-7.3.1-2018.05-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-#指定用哪个内核去编译KDIR=/mnt/nfsroot/zhengshuai.zhu/IPCSDK/ipc-sdk-full-release/kernel-4.19#目标是编译成一个test.ko文件obj-m += test.o#test.o文件由当前目录下n个c文件编译成test-objs += ./*.o#包含当前目录下的头文件INCLUDE_DIRS := $(addprefix -I,$(shell find ../ -type d ))#包含当前目录下，内核目录下的头文件ccflags-y:= -I$(_KDIR)/include/linux/ -I$(PWD)/platform/#忽略一些编译警告，类如什么变量未使用ccflags-y += -Wno-declaration-after-statement#添加c文件中的环境变量，比如在代码中会有#ifdef CONFIG_ANDROID #xxxx#endififeq ($(SYSTEM_VERSION),) ccflags-y += -DCONFIG_LINUX_OSelse ccflags-y += -DCONFIG_ANDROIDendifall: make ARCH=$&#123;ARCH&#125; -C $(KDIR) M=$(PWD) modulesclean: make ARCH=$&#123;ARCH&#125; -C $(KDIR) M=$(PWD) clean make ARCH=$&#123;ARCH&#125; -C ( K D I R ) M = (KDIR) M=(KDIR)M=(PWD) modules如何理解这句话?-C的选项可以理解为:进入所指定的位置，$(KDIR)，也就是内核目录中，目的是什么？ 去读取内核目录顶层的Makefile文件，相当于编译的时候 选择一个内核，我要用这个内核去编译。因为你这个目录没有被配置到kernel config里面去，也就是说没有指定用哪个内核版本，有了 -C $(KDIR),就相当于选了内核，如果你选择了kernel-4.19目录下，或者 kernel-5.0目录下， M&#x3D;的选项可以理解为:当我选好内核版本后，我用这个 版本的内核 要去编译哪个目录，然后进入$(PWD)目录去编译当前指定的文件，将其编译成ko文件","tags":["Makefile"],"categories":["Makefile"]},{"title":"git提交流程","path":"//posts/1.html","content":"一、Git下载及配置我们第一次用git或者是新电脑上重新安装git工具的时候，都需要重新配置一下这个工具。 Windows安装git官网网址https://git-scm.com/downloads下载速度慢，且有可能安装不成功。 附快速下载地址（国内下载站）：https://github.com/waylau/git-for-win 。 下载完之后，Windows中你在桌面上或者文件管理器中鼠标右键就可以看见Git Bash here，就是用来打开git bash的。 Linux安装gitlinux在终端中，输入sudo apt-get install git 下载完可以用命令git --version打印当前的git版本验证是否成功。下面正式开始Git的配置。 配置git基本信息接下来就是不管我们是第一次使用git工具，还是后来换电脑了，还是换成linux系统了，要想使用git都按照下面的方法配置一遍，才可以使用。 安装成功之后，在命令行中敲下如下命令 git config --list,显示当前的配置信息。 接下来设置提交仓库时的用户名信息 git config --global user.name &quot;张三&quot; 设置提交仓库是的邮箱信息 git config --global user.email &quot;xxxxxxxx@qq.com&quot; git设置关闭自动换行git config --global core.autocrlf false 为了保证文件的换行符是以安全的方法，避免windows与unix的换行符混用的情况，最好也加上这么一句 git config --global core.safecrlf true 其实这些信息都在一个配置文件中，就在当前用户的主目录下边的**.gitconfig**文件中，也可以直接打开这个文件cd ~,vim .gitconfig进行编辑。 git协议及秘钥配置git有四种协议：Git协议，http协议，本地协议，ssh协议。使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https。大部分都是用ssh协议。这个不仅速度快，而且不用每次提交输入密码，可谓是省心省力。 下面就说一下ssh配置过程。(这个协议配置的过程不可缺少，不然就用不了这种协议。) 首先生成 RSA 密钥对 : ssh-keygen -t rsa -C &quot;xxxxxxxx@qq.com&quot;注意格式，一定要正确。 ssh和-keygen无空格 此时在用户主目录下就会有一个.ssh隐藏文件，进入该目录有一个id_rsa.pub文件，cat命令查看这个文件，复制下来然后在 github网站添加公钥 ，方法如下 在 Github 网站添加公钥：在右上角头像处点settings进入设置，然后点SSH and GPG keys,进入之后点击New SSH key 粘贴进去，随便给这个秘钥命个名，方便管理就行了。钥匙显示黑色即可。 此时配置就完成了。接下来就可以使用git了。 执行此命令验证是否成功ssh -T git@github.com 成功显示为：Hi XXX! You’ve successfully authenticated, but GitHub does not provide shell access. 二、先有本地库，后有远程库创建版本库可以理解为版本库就是本地文件的一个目录，也叫仓库。可以用git来管理和回退等 创建版本库：找到一个想被管理的文件夹，进入到文件夹里，输入命令git init,此时git就可以管理这个目录了，并且在文件夹下多出来了一个.git的隐藏文件夹。这个.git就是版本库。 Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。 工作区：就是你在电脑里能看到的目录，比如刚才的文件夹就是一个工作区 第一步：将文件添加到暂存区当我们想添加文件或者修改文件是需要添加到版本库中的，否则无法被git跟踪管理呀，所以当我们添加或者修改文件时，先要用git add filename添加到暂存区中，filename为.的时候代表当前目录下所有文件都添加到暂存区 第二步：将文件提交到分支git commit -m &quot;message&quot;，将文件提交到了分支。 添加远程库我们已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。 首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库，在Repository name填入项目名字，比如我们叫learngit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库 目前，在GitHub上的这个learngit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。 现在，我们根据GitHub的提示，在本地的learngit仓库下运行命令： git remote add origin git@github.com:mengchao666/learngit.git 请千万注意，把上面的mengchao666替换成你自己的GitHub账户名，否则，你在本地关联的就是我的远程库，你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。 添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。下一步，就可以把本地库的所有内容推送到远程库上： git push -u origin master把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样,从现在起，只要本地作了提交，就可以通过命令： git push origin master 三、先有远程库，后有本地库现在，远程库已经准备好了，下一步是用命令git clone克隆一个本地库： git clone git@github.com:mengchao666/learngit.git 可以使用git clone -b branch克隆指定的分支后续修改可以使用如下命令提交 123git add .git commit -m &quot;message&quot;git push 四、企业开发流程在公司中做项目，一般项目代码都在公共仓库中，我们将其称为远程仓，一般按照如下步骤开发1、将远程仓fork一份到个人仓2、git clone个人仓代码到本地3、使用git remote -v命令查看，此时本地关联的origin为个人仓4、将本地代码关联到公司的远程仓，方便拉取最新代码，命令如下： 1git remote add upstream 公共仓地址 此时再次使用git remote -v可以看到已经关联了upstream为远程仓5、在开发需求和问题单修改之前，一般使用git pull upstream命令将远程仓代码更新至本地6、修改代码后提交 123git add .git commit -m &quot;message&quot;git push origin branch 7、在github&#x2F;gitlab页面创建MR申请，一般此时就可以了，找人加分就合入了8、但是如果在创建MR申请时，提示冲突，此时需要解决冲突，解决如下： 1git pull upstream 此时会提示哪些文件有冲突，使用ctrl + F搜索&gt;&gt;&gt;,有此标志的即为冲突的地方，保留自己想要的代码，重新提交add commit push即可。 企业开发流程中，通常有远程仓新建了一个分支，个人远程仓没有此分支，需要更新，可按照如下步骤更新个人仓代码分支 123git checkout -b 新分支名称 upstream/新分支名称git pull upstream 新分支名称git push origin 新分支名称 五、代码回退等操作工作区的恢复(此时还没有add，代码回退)使用checkout恢复工作区 git checkout . （全部修改），git checkout --file改回一个文件,工作区—&gt;还没add add的撤销git reset就是回退到指定的commitID,,使用git commit –amend时追加，不会生成新的commitID,是在原来的commitID基础上进行修改的。 HEAD指向当前最新的commitID，所以仅仅add,没有commit，此时的最新的commitID还是之前的 12git reset --hard HEAD // 不保留本地修改，回退git reset --mixed HEAD //保留本地修改，可以重新git add 简单理解git reset –xxx HEAD命令，就是将代码回退到了最新的一次commitID的代码状态，hard不保留本地代码工作空间的修改，而mixed保留 commit后的撤销123git reset --hard HEAD^ // 不保留本地修改，回退到上一次的commitID状态git reset --mixed HEAD^ // 保留本地修改，撤销git commit,并且撤销git addgit reset --soft HEAD^ //保留本地修改，撤销commit,不撤销add 六、git的一些其他操作查看分支：git branch 创建分支：git branch &lt;name&gt; 切换分支：git checkout &lt;name&gt;或者git switch &lt;name&gt; 创建+切换分支：git checkout -b &lt;name&gt;或者git switch -c &lt;name&gt; 合并某分支到当前分支：git merge &lt;name&gt; 删除分支：git branch -d &lt;name&gt; 当代码仓有子仓情形下的一些命令：git submodule update --init --remotegit submodule foreach git checkout branchgit submodule foreach --recursive 七、同时提交两个MR当我们同时修改多个问题单，或者同时处理需求时，可能需要同时提交多分不同代码，此时处理方法如下： 1、本地创建一个新的分支来处理第一个MR 1git checkout -b mr1-branch 2、提交第一个MR。修改代码，git add、git commit，git push 1git push -u origin mr1-branch 3、切换回原来的分支，以main分支为例 1git checkout main 4、创建第二个分支处理第二个MR 1git checkout -b mr2-branch 5、提交第二个MR。修改代码，git add、git commit，git push 1git push -u origin mr2-branch","tags":["git"],"categories":["git"]},{"title":"addr2line","path":"/posts/addr2line.html","content":"addr2line是一个将地址转换为文件名和行号的工具。给定可执行文件(如exe&#x2F;a.out等)中的地址或可重定位对象(如so,ko等)部分中的偏移量，它会使用调试信息来确定与之相关的文件名和行数。 用户态coredump，一般使用gdb调试接口，gdb一般封装了addr2line，可以解析文件名和行号。如果环境配置了不生成coredump，可以使用addr2line调试。所以addr2line一般解析内核Call trace使用较多。 一、使用方法12基本用法：addr2line [选项] [地址] 常用选项如下： 选项 描述 -e 设置输入文件名称，默认为a.out -i 解析内联函数 -f 显示函数名 -C 解析函数名 -p 以好读的方式显示 需要注意的是使用addr2line的时候，可执行文件或重定位文件一定是要带调试信息的 二、用户态普通程序崩溃使用方法 1addr2line -e 进程名 IP指令地址 -f 用户态程序崩溃，当没有coredump产生时，可以使用如下方法假设我们的程序名称为segfault,当程序崩溃是，dmesg日志中会有报错信息: 123[root@localhost ~]# dmesg[134563.793925] segfault[53791]: segfault at 0 ip 0000000000400546 sp 00007fff7956af70 error 6 in segfault[400000+1000][134563.793946] Code: 01 5d c3 90 c3 66 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 f3 0f 1e fa eb 8a 55 48 89 e5 48 c7 45 f8 00 00 00 00 48 8b 45 f8 &lt;c7&gt; 00 00 00 00 00 b8 00 00 00 00 5d c3 66 2e 0f 1f 84 00 00 00 00 此时我们注意到IP指令地址为0000000000400546使用addr2line查看程序挂的位置： 1addr2line -e segfault 0x0000000000400546 -f 三、动态链接库程序崩溃使用方法 1addr2line -e 动态链接库名称 IP指令地址-基地址 -f 假设我们有一个程序名为test，链接了一个libfoo.so，程序运行时崩溃，dmesg查看日志如下： 123[root@localhost ~]# dmesg[70567.416655] test[27722]: segfault at 0 ip 00007ffa1f588580 sp 00007fffa964e698 error 6 in libfoo.so[7ffa1f588000+1000][70567.427374] Code: ff e8 64 ff ff ff c6 05 bd 0a 20 00 01 5d c3 0f 1f 00 c3 0f 1f 80 00 00 00 00 f3 0f 1e fa e9 77 ff ff ff 0f 1f 80 00 00 00 00 &lt;c7&gt; 04 25 00 00 00 00 00 00 00 00 0f 0b 00 00 00 f3 0f 1e fa 48 83 根据日志可知，段错误发生的位置是在test进程调用的libfoo.so库里，我们先使用ldd找到动态库的位置，如下： 12345[root@localhost 69]# ldd test linux-vdso.so.1 (0x00007ffd15b24000) libfoo.so =&gt; ./libfoo.so (0x00007f8c01879000) libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f8c014b4000) /lib64/ld-linux-x86-64.so.2 (0x00007f8c01a7b000) 00007ffa1f588580为程序崩溃点IP指令地址，使用dmesg消息中ip指令地址减去动态库基址值(00007ffa1f588580 -7ffa1f588000&#x3D;580), 差值0x580为错误点在动态库的地址，调用addr2line, 注意-e参数后文件名改为动态库名: 1addr2line -e libfoo.so 580 -f -p 四、内核驱动程序运行崩溃使用方法： 1addr2line -e xxx.ko 地址偏移量 -f 本人所用主机即属于一旦发生Oops，就会触发panic，因此总是无法查看Oops时的dmesg日志，经查阅资料，发现是内核参数panic_on_oops的原因导致的，因为该参数被设置为1，所以Oops会触发panic，从而导致机器总是死机重启，无法查看Oops时的dmesg日志。下面提供两种方法修改Oops内核参数，使其不会在Oops的时候触发panic导致死机重启。 方法一：修改 &#x2F;proc下内核参数文件内容，临时生效，重启后失效。 1echo 0 &gt; /proc/sys/kernel/panic_on_oops 方法二：修改&#x2F;etc&#x2F;sysctl.conf 文件的内核参数来永久更改。 1234567891011121314151617181920[root@localhost ~]# vi /etc/sysctl.conf[root@localhost ~]# cat /etc/sysctl.conf# sysctl settings are defined through files in# /usr/lib/sysctl.d/, /run/sysctl.d/, and /etc/sysctl.d/.## Vendors settings live in /usr/lib/sysctl.d/.# To override a whole file, create a new file with the same in# /etc/sysctl.d/ and put new settings there. To override# only specific settings, add a file with a lexically later# name in /etc/sysctl.d/ and put new settings there.## For more information, see sysctl.conf(5) and sysctl.d(5).kernel.panic_on_oops=0[root@localhost ~]# cat /proc/sys/kernel/panic_on_oops1 [root@localhost ~]# sysctl -pkernel.panic_on_oops = 0[root@localhost ~]#[root@localhost ~]# cat /proc/sys/kernel/panic_on_oops0 假设内核某ko运行后发生如下错误： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051[root@localhost ~]# dmesg[ 1039.918606] my_oops_init[ 1039.918616] BUG: unable to handle kernel NULL pointer dereference at 0000000000000000[ 1039.926442] PGD 0 P4D 0[ 1039.928979] Oops: 0002 [#1] SMP NOPTI[ 1039.932637] CPU: 34 PID: 3843 Comm: insmod Kdump: loaded Tainted: G OE --------- - - 4.18.0-394.el8.x86_64 #1[ 1039.943756] Hardware name: New H3C Technologies Co., Ltd. H3C UniServer R4950 G5/RS45M2C9SB, BIOS 5.37 09/30/2021[ 1039.954000] RIP: 0010:do_oops+0x5/0x11 [oops][ 1039.958364] Code: Unable to access opcode bytes at RIP 0xffffffffc02e6fdb.[ 1039.965231] RSP: 0018:ffffb9d40a8c7cb0 EFLAGS: 00010246[ 1039.970449] RAX: 000000000000000c RBX: 0000000000000000 RCX: 0000000000000000[ 1039.977573] RDX: 0000000000000000 RSI: ffff98942ee96758 RDI: ffff98942ee96758[ 1039.984697] RBP: ffffffffc02e7011 R08: 0000000000000000 R09: c0000000ffff7fff[ 1039.991822] R10: 0000000000000001 R11: ffffb9d40a8c7ad8 R12: ffffffffc02e9000[ 1039.998944] R13: ffffffffc02e9018 R14: ffffffffc02e91d0 R15: 0000000000000000[ 1040.006069] FS: 00007f1b8d93b740(0000) GS:ffff98942ee80000(0000) knlGS:0000000000000000[ 1040.014145] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033[ 1040.019884] CR2: ffffffffc02e6fdb CR3: 0000000145c02000 CR4: 0000000000350ee0[ 1040.027008] Call Trace:[ 1040.029454] my_oops_init+0x16/0x19 [oops][ 1040.033550] do_one_initcall+0x46/0x1d0[ 1040.037390] ? do_init_module+0x22/0x220[ 1040.041318] ? kmem_cache_alloc_trace+0x142/0x280[ 1040.046023] do_init_module+0x5a/0x220[ 1040.049777] load_module+0x14ba/0x17f0[ 1040.053530] ? __do_sys_finit_module+0xb1/0x110[ 1040.058059] __do_sys_finit_module+0xb1/0x110[ 1040.062411] do_syscall_64+0x5b/0x1a0[ 1040.066077] entry_SYSCALL_64_after_hwframe+0x65/0xca[ 1040.071130] RIP: 0033:0x7f1b8c8509bd[ 1040.074701] Code: ff c3 66 2e 0f 1f 84 00 00 00 00 00 90 f3 0f 1e fa 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 &lt;48&gt; 3d 01 f0 ff ff 73 01 c3 48 8b 0d 9b 54 38 00 f7 d8 64 89 01 48[ 1040.093446] RSP: 002b:00007ffc4df0a968 EFLAGS: 00000246 ORIG_RAX: 0000000000000139[ 1040.101004] RAX: ffffffffffffffda RBX: 00005653fb1997d0 RCX: 00007f1b8c8509bd[ 1040.108126] RDX: 0000000000000000 RSI: 00005653f980c8b6 RDI: 0000000000000003[ 1040.115251] RBP: 00005653f980c8b6 R08: 0000000000000000 R09: 00007f1b8cbd9760[ 1040.122375] R10: 0000000000000003 R11: 0000000000000246 R12: 0000000000000000[ 1040.129498] R13: 00005653fb1997b0 R14: 0000000000000000 R15: 0000000000000000[ 1040.136623] Modules linked in: oops(OE+) binfmt_misc xt_CHECKSUM ipt_MASQUERADE xt_conntrack ipt_REJECT nf_reject_ipv4 nft_compat nft_counter nft_chain_nat nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 nf_tables nfnetlink rpcsec_gss_krb5 auth_rpcgss nfsv4 dns_resolver nfs lockd grace fscache bridge stp llc intel_rapl_msr intel_rapl_common amd64_edac_mod edac_mce_amd amd_energy kvm_amd kvm irqbypass ipmi_ssif pcspkr crct10dif_pclmul crc32_pclmul ghash_clmulni_intel rapl joydev ccp sp5100_tco i2c_piix4 k10temp ptdma acpi_ipmi ipmi_si sunrpc vfat fat xfs libcrc32c sd_mod t10_pi sg crc32c_intel ast drm_vram_helper drm_kms_helper syscopyarea sysfillrect sysimgblt fb_sys_fops drm_ttm_helper ttm ahci drm libahci nfp(OE) igb libata dca i2c_algo_bit dm_mirror dm_region_hash dm_log dm_mod ipmi_devintf ipmi_msghandler[ 1040.208357] CR2: 0000000000000000[ 1040.211668] ---[ end trace b69c1e8998070273 ]---[ 1040.230185] RIP: 0010:do_oops+0x5/0x11 [oops][ 1040.234540] Code: Unable to access opcode bytes at RIP 0xffffffffc02e6fdb.[ 1040.241409] RSP: 0018:ffffb9d40a8c7cb0 EFLAGS: 00010246[ 1040.246626] RAX: 000000000000000c RBX: 0000000000000000 RCX: 0000000000000000[ 1040.253750] RDX: 0000000000000000 RSI: ffff98942ee96758 RDI: ffff98942ee96758[ 1040.260876] RBP: ffffffffc02e7011 R08: 0000000000000000 R09: c0000000ffff7fff[ 1040.267998] R10: 0000000000000001 R11: ffffb9d40a8c7ad8 R12: ffffffffc02e9000[ 1040.275124] R13: ffffffffc02e9018 R14: ffffffffc02e91d0 R15: 0000000000000000[ 1040.282247] FS: 00007f1b8d93b740(0000) GS:ffff98942ee80000(0000) knlGS:0000000000000000[ 1040.290323] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033[ 1040.296061] CR2: ffffffffc02e6fdb CR3: 0000000145c02000 CR4: 0000000000350ee0 Oops: 0002 – 错误码Oops: [#1] – Oops发生的次数CPU: 34 – 表示Oops是发生在CPU34上关键信息如下，这里提示在操作函数do_oops的时候出现异常，地址偏移量0x5： 1[ 1039.954000] RIP: 0010:do_oops+0x5/0x11 [oops] 为什么这条信息关键? 因为其含有指令指针RIP；指令指针IP&#x2F;EIP&#x2F;RIP的基本功能是指向要执行的下一条地址。在8080 8位微处理器上的寄存器名称是PC（program counter，程序计数器），从8086起，被称为IP（instruction pointer，指令指针）。主要区别在与PC指向正在执行的指令，而IP指向下一条指令。在64位模式下，指令指针是RIP寄存器。这个寄存器保存着下一条要执行的指令的64位地址偏移量。64位模式支持一种新的寻址模式，被称为RIP相对寻址。使用这个模式，有效地址的计算方式变为RIP（指向下一条指令）加上位移量。 由此可以看出内核执行到do_oops+0x5&#x2F;0x11这个地址的时候出现异常，我们只需要找到这个地址对应的代码即可。 do_oops指示了是在do_oops函数中出现的异常， 0x5表示出错的地址偏移量， 0x11表示do_oops函数的大小。 123打印格式：do_oops+0x5/0x11 [oops] 即：symbol+offset/size [module] symbol: 符号 offset：地址偏移量 size：函数的长度 module: 所属内核模块 使用如下命令解析 1addr2line -e oops.ko 0x5 -f -p","tags":["Linux工具"],"categories":["Linux工具"]},{"title":"个人博客网站部署&文章提交","path":"/posts/网站部署-写作.html","content":"一、网站部署1、首先在github上创建自己的一个仓库，仓库名字为mengchao666.github.io 2、将https://github.com/mengchao666/blog-demo代码下载到本地，用VScode打开 3、安装node.js，pnpm，hexo 123node.js官网安装：https://nodejs.cn/download/pnpm安装：npm install pnpm -ghexo安装：npm install hexo-cli -g 4、在Vscode打开的项目终端下执行如下命令： 12pnpm ipnpm dev 5、使用hexo deploy命令部署，打开mengchao666.github.io即可 6、新增文章使用如下命令新增 例如：hexo new post “网站部署” 1hexo new post &lt;title&gt; 7、新增文章后，使用命令部署提交到github 12hexo cleanhexo deploy 更多操作可以参考：https://xaoxuu.com/wiki/stellar/topic.html","tags":["网站"],"categories":["网站"]},{"title":"友链","path":"/about/index.html","content":"我的小伙伴们 github 如何交换友链？ 您的网站应满足以下全部条件： 安全合规：合法的、非营利性、无木马植入的 HTTPS 站点。 非空壳网站：网站内发布至少 五篇 原创文章，内容题材不限。 我们需要有一定的有效互动： 先友后链：与 我 有至少 半年 的有效互动"},{"path":"/static/js/snow.js","content":"const message = { toast: (msg, duration) => { const d = Number(isNaN(duration) ? 2000 : duration); var el = document.createElement('div'); el.classList.add('toast'); el.classList.add('show'); el.innerHTML = msg; document.body.appendChild(el); setTimeout(function () { document.body.removeChild(el) }, d); }, } const Config = { snow: ['❄️', '☃️', '❄', '※', '❅', '❆', '❈', '❉', '❊', '❋'], color: '#d9e2e7', speed: 10, dom: document.getElementsByTagName('body')[0], interval: 800, active: false }; // 从 localStorage 获取雪花模式状态 const storedSnowActive = localStorage.getItem('snowActive'); Config.active = storedSnowActive === 'true'; // 确保 DOM 元素存在 if (!Config.dom) { throw Error('请获取存在的DOM'); } const $canvas = document.createElement('div'); function useStyle(dom, style) { for (let sKey in style) { dom.style[sKey] = style[sKey]; } } useStyle($canvas, { width: '100%', height: '100%', position: 'fixed', top: 0, left: 0, pointerEvents: 'none', zIndex: 100 }); const matchDarkMode = window.matchMedia('(prefers-color-scheme: dark)'); function handleColorSchemeChange(e) { Config.color = e.matches ? 'rgb(255, 255, 255)' : 'rgb(149, 141, 186)'; } matchDarkMode.addEventListener('change', handleColorSchemeChange); handleColorSchemeChange(matchDarkMode); let snowInterval; function startSnowInterval() { return setInterval(() => { const $snow = document.createElement('div'); $snow.innerText = Config.snow[Math.floor(Math.random() * Config.snow.length)]; useStyle($snow, { display: 'inline-block', color: Config.color, fontSize: Math.floor(Math.random() * (25 - 14 + 1) + 14) + 'px', position: 'absolute', top: 0, left: Math.floor(Math.random() * 100) + '%', transition: 'transform ' + Config.speed + 's linear,opacity ' + Config.speed + 's linear', transform: 'translateY(-100%)', opacity: Math.random() + 0.3 }); setTimeout(() => { useStyle($snow, { transform: 'translate(0, ' + window.innerHeight + 'px) rotate(480deg)', opacity: 0 }); $snow.addEventListener('transitionend', () => { $snow.remove(); }); }, 100); $canvas.appendChild($snow); }, Config.interval); } function toggleSnow() { if (Config.active) { clearInterval(snowInterval); $canvas.innerHTML = ''; Config.active = false; message.toast(\"切换到晴天模式\"); } else { snowInterval = startSnowInterval() Config.active = true; message.toast(\"切换到下雪模式\"); } localStorage.setItem('snowActive', Config.active); } // 在页面加载时应用之前的状态 if (Config.active) { snowInterval = startSnowInterval() } Config.dom.appendChild($canvas);"},{"title":"牛客零基础入门前端","path":"/wiki/niuke/牛客零基础入门前端.html","content":"01 HTMLFED1 表单类型描述请依次写出以下类型的输入框。 类型为密码，默认值为 “nowcoder” 类型为复选框，且状态为已勾选 我的解答1234&lt;form&gt; &lt;input type=&quot;password&quot; value=&quot;nowcoder&quot; /&gt; &lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot; /&gt;&lt;/form&gt; 注意点： 类型为复选框，input 属性的 checked &#x3D; “checked” FED2 表格结构描述请写出具有表格标题为 “nowcoder” 的 2 行 3 列表格结构。 我的解答1234567891011121314151617&lt;table&gt; &lt;caption&gt; nowcoder &lt;/caption&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; mdn 示例 Council budget (in £) 2018 Items Expenditure Donuts 3,000 Stationery 18,000 Totals 21,000 FED3 图像标签属性描述请写出具有标题属性和代替文本属性的图片标签。 我的解答1&lt;img src=&quot;&quot; alt=&quot;&quot; title=&quot;&quot; /&gt; FED4 新窗口打开文档描述请写出可以在新窗口打开文档的 a 标签。 我的解答1&lt;a href=&quot;&quot; target=&quot;_blank&quot;&gt;&lt;/a&gt; 注意点target 规定在何处打开目标 URL。仅在 href 属性存在时使用 _blank：新窗口打开。 _parent：在父窗口中打开链接。 _self：默认，当前页面跳转。 _top：在当前窗体打开链接，并替换当前的整个窗体(框架页)。 FED5 自定义列表描述请写出列表项为 “nowcoder” 且列表项内容也为 “nowcoder” 的自定义列表。 我的解答1234&lt;dl&gt; &lt;dt&gt;nowcoder&lt;/dt&gt; &lt;dd&gt;nowcoder&lt;/dd&gt;&lt;/dl&gt; 注意点 html5 前用得多，普通列表标签，既不是 ul，也不是 ol FED6 语义化标签描述请使用语义化标签创建头部标签且包含导航标签。注意：只需在 html 模块填写标签结构，有且仅有一个头部标签和一个导航标签。 我的解答123&lt;header&gt; &lt;nav&gt;&lt;/nav&gt;&lt;/header&gt; 注意点 就普通嵌套，看报错才知道标签名 FED7 音频媒体标签属性描述请写出具有控件功能的音频媒体标签。 我的解答1&lt;audio src=&quot;&quot; controls&gt;&lt;/audio&gt; 注意点 controls：如果声明了该属性，浏览器将提供一个包含声音，播放进度，播放暂停的控制面板，让用户可以控制音频的播放。 FED8 视频媒体标签属性描述请写出具有当视频的媒体数据加载期间发生错误时执行某个方法事件的视频媒体标签。 我的解答1&lt;video src=&quot;&quot; onerror=&quot;fn()&quot; controls&gt;&lt;/video&gt;&lt;audio src=&quot;&quot; controls&gt;&lt;/audio&gt; 注意点 controls：如果存在该属性，浏览器会在视频底部提供一个控制面板，允许用户控制视频的播放，包括音量、拖动进度、暂停或恢复播放。 02 CSSFED9 CSS 选择器——标签、类、ID 选择器描述请将 html 模块中字体内容是 “红色” 的字体颜色设置为 “rgb(255, 0, 0)”，”绿色” 设置为 “rgb(0, 128, 0)”，”黑色” 设置为 “rgb(0, 0, 0)”，且字体大小都为 20px。 我的解答1234567891011121314&lt;style&gt; .green &#123; color: rgb(0, 128, 0); font-size: 20px; &#125; #black &#123; color: rgb(0, 0, 0); font-size: 20px; &#125;&lt;/style&gt;&lt;div style=&quot;color:rgb(255, 0, 0);font-size:20px&quot;&gt;红色&lt;/div&gt;&lt;div class=&quot;green&quot;&gt;绿色&lt;/div&gt;&lt;div id=&quot;black&quot;&gt;黑色&lt;/div&gt; 注意点 类选择器：. id 选择器：# FED10 CSS 选择器——伪类选择器描述请将 html 模块中 ul 列表的第 2 个 li 标签和第 4 个 li 标签的背景颜色设置成 “rgb(255, 0, 0)”。 我的解答1234567891011&lt;style&gt; li:nth-child(2n) &#123; background-color: rgb(255, 0, 0); &#125;&lt;/style&gt;&lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt;&lt;/ul&gt; 注意点 伪类选择器 nth-child(2n)：偶数个 nth-child(2n-1)：奇数个 FED11 CSS 选择器——伪元素描述请给 html 模块的 div 元素加一个后伪元素，且后伪元素的宽度和高度都是 20px，背景颜色为 “rgb(255, 0, 0)”。 我的解答12345678910&lt;style&gt; div::after &#123; content: &quot;&quot;; height: 20px; width: 20px; background-color: rgb(255, 0, 0); display: inline-block; &#125;&lt;/style&gt;&lt;div&gt;&lt;/div&gt; 注意点 ::after 会创建一个 伪元素，作为所选元素的最后一个子元素 包含 content，可以表示文字，图片等 display: inline-block; 要设置为块级元素才能给其设置宽高 FED12 按要求写一个圆描述请将 html 模块的 div 元素设置为一个半径是 50px 的圆，且边框为 1px 的黑色实线。要求： 圆角属性仅设置一个值 圆角属性单位请使用 px 注意：由于圆角属性设置广泛且都可以实现题目效果，所以请按照要求规范书写。 我的解答123456789&lt;style&gt; div &#123; width: 100px; height: 100px; border-radius: 50px; border: 1px solid black; &#125;&lt;/style&gt;&lt;div&gt;&lt;/div&gt; 注意点 border-radius 设置为 50%就是一个圆 FED13 设置盒子宽高描述请将 html 模块类为 “box” 的 div 元素宽度和高度都设置为 100px，且内间距为 20px、外间距为 10px。 我的解答123456789&lt;style&gt; .box &#123; width: 100px; height: 100px; padding: 20px; margin: 10px; &#125;&lt;/style&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt; 注意点 padding 内边距，margin 外边距 FED14 浮动和清除浮动描述请将类为 “left” 的 div 元素和类为 “right” 的 div 元素在同一行上向左浮动，且清除类为 “wrap” 的父级 div 元素内部的浮动。 我的解答123456789101112131415161718192021222324&lt;style&gt; .wrap::after &#123; content: &quot;&quot;; display: block; clear: both; &#125; .left &#123; width: 100px; height: 100px; background-color: red; float: left; &#125; .right &#123; width: 100px; height: 100px; background-color: yellow; float: left; &#125;&lt;/style&gt;&lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;&lt;/div&gt; 注意点 float 属性左右占位，上下不占位，所以下面的元素会浮动上来，所以可以在父类盒子加一个:: after 伪类元素，设置 clear:both 闭合父盒子的边界以达到清除浮动的目的。 css - 清除浮动（clearfix）的常见方法 - front-end development - SegmentFault 思否 FED15 段落标识描述请将下面这句话以段落的形式展示在浏览器中——“牛客网是一个专注于程序员的学习和成长的专业平台。” 我的解答1&lt;p&gt;牛客网是一个专注于程序员的学习和成长的专业平台。&lt;/p&gt; 注意点 考察 p 标签的使用方法 FED16 圣诞树描述圣诞节来啦！请用 CSS 给你的朋友们制作一颗圣诞树吧~这颗圣诞树描述起来是这样的： “topbranch”是圣诞树的上枝叶，该上枝叶仅通过边框属性、左浮动、左外边距即可实现。边框的属性依次是：宽度为 100px、是直线、颜色为 green（未显示的边框颜色都为透明） “middleBranch”是圣诞树的中枝叶，该上枝叶仅通过边框属性即可实现。边框的属性依次是：宽度为 200px、是直线、颜色为 green（未显示的边框颜色都为透明） “base”是圣诞树的树干，该树干仅通过左外边距实现居中于中枝叶。树干的宽度、高度分别为 70px、200px，颜色为 gray。 注意： 上枝叶、树干的居中都是通过左外边距实现的 没有显示的边框，其属性都是透明（属性） 仅通过 border 属性完成边框的所有属性设置 我的解答12345678910111213141516171819202122232425262728293031323334&lt;style&gt; .topbranch &#123; width: 0px; height: 0px; border-width: 100px; border-color: green; border-left-color: transparent; border-right-color: transparent; border-top-color: transparent; border-style: solid; float: left; margin-left: 100px; &#125; .middleBranch &#123; width: 0px; height: 0px; border-width: 200px; border-color: green; border-left-color: transparent; border-right-color: transparent; border-top-color: transparent; border-style: solid; &#125; .base &#123; width: 70px; height: 200px; background-color: grey; margin-left: 165px; &#125;&lt;/style&gt;&lt;section class=&quot;topbranch&quot;&gt;&lt;/section&gt;&lt;section class=&quot;middleBranch&quot;&gt;&lt;/section&gt;&lt;section class=&quot;base&quot;&gt;&lt;/section&gt; 注意点 1234border-color: green;border-left-color: transparent;border-right-color: transparent;border-top-color: transparent; 这样做会显示出三角形，把其他边颜色设置为 transparent 透明 FED17 固定定位描述请将 html 模块类为”box”的 div 元素固定在视口的左上角。 我的解答12345678&lt;style&gt; .box &#123; position: fixed; top: 0; left: 0; &#125;&lt;/style&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt; 注意点 position: fixed;可以让元素在浏览器某一个位置固定，不随滚动条而移动 FED18 CSS 单位（一）描述请将 html 模块中类为”box”的 div 元素的宽度和高度设置为自身字体大小的 4 倍。 我的解答1234567&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;style&gt; .box &#123; width: 4em; height: 4em; &#125;&lt;/style&gt; 注意点 em 指的相对父级的字体大小 FED19 CSS 单位（二）描述请将 html 模块 div 元素的宽度和高度设置为 html 根元素字体大小的 4 倍。注意：只需在 css 模块补全样式内容，请勿修改 html 模块。 我的解答1234567&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;style&gt; .box &#123; width: 4rem; height: 4rem; &#125;&lt;/style&gt; 注意点 rem 指的相对根级的字体大小(:root&#x2F;html) 03 JAVASCRIPTFED20 基本数据类型检测描述请补全 JavaScript 函数，要求以字符串的形式返回参数的类型。注意：只需检测基本数据类型。 我的解答12345&lt;script&gt; function _typeof(value) &#123; return typeof value; &#125;&lt;/script&gt; 注意点 typeof 可以返回数据类型 FED21 检测复杂数据类型描述请补全 JavaScript 函数，要求以 Boolean 的形式返回第一个参数是否属于第二个参数对象的实例。 我的解答12345&lt;script&gt; function _instanceof(left, right) &#123; return left instanceof right; &#125;&lt;/script&gt; 注意点 instanceof 可以检验参数是否为某个对象的实例 FED22 数据类型转换描述请补全 JavaScript 函数，要求以字符串的形式返回两个数字参数的拼接结果。示例： _splice(223,233) -&gt; “223233” _splice(-223,-233) -&gt; “-223-233” 我的解答123456&lt;script type=&quot;text/javascript&quot;&gt; // 填写JavaScript function _splice(left, right) &#123; return left.toString() + right.toString(); &#125;&lt;/script&gt; 注意点 使用toString把数字类型转为字符串类型，再相加 FED23 阶乘描述请补全 JavaScript 函数，要求返回数字参数的阶乘。注意：参数为大于等于 0 的整数。 我的解答1234567&lt;script type=&quot;text/javascript&quot;&gt; function _factorial(number) &#123; if (number &lt; 0) return; if (number == 1 || number == 0) return 1; return number * _factorial(number - 1); &#125;&lt;/script&gt; 注意点 使用递归完成阶乘更加简洁"},{"title":"探索者笔记","path":"/explore/notes/探索者笔记.html","content":"memos 说说 本页面数据来源于：memos"},{"title":"工具库","path":"/explore/sites/工具库.html","content":"工具库 VIP电影在线观看https://vip1280.net/文件格式转换https://convertio.co/zh/"}]