[{"title":"等待队列","path":"/posts/等待队列.html","content":"一、Linux等待队列概述Linux内核的等待队列（Wait Queue）是重要的数据结构，与进程调度机制紧密相关联，可以用来同步对系统资源的访问、异步事件通知、跨进程通信等。 在Linux中，等待队列以循环链表为基础结构，包括两种数据结构：等待队列头(wait queue head)和等待队列元素(wait queue)，整个等待队列由等待队列头进行管理。下文将用内核源码（基于Linux kernel 5.2）对等待队列进行介绍，详细说明采用等待队列实现进程阻塞和唤醒的方法。 二、等待队列头和等待队列元素等待队列以循环链表为基础结构，链表头和链表项分别为等待队列头和等待队列元素，分别用结构体 wait_queue_head_t 和 wait_queue_entry_t 描述（定义在 linux&#x2F;wait.h ）。 2.1 基本概念 12345struct wait_queue_head &#123; spinlock_t lock; struct list_head head;&#125;;typedef struct wait_queue_head wait_queue_head_t; 1234567891011121314151617typedef int (*wait_queue_func_t)(struct wait_queue_entry *wq_entry, unsigned mode, int flags, void *key);int default_wake_function(struct wait_queue_entry *wq_entry, unsigned mode, int flags, void *key);/* wait_queue_entry::flags */#define WQ_FLAG_EXCLUSIVE 0x01#define WQ_FLAG_WOKEN 0x02#define WQ_FLAG_BOOKMARK 0x04/* * A single wait-queue entry structure: */struct wait_queue_entry &#123; unsigned int flags; void *private; wait_queue_func_t func; struct list_head entry;&#125;;typedef struct wait_queue_entry wait_queue_entry_t; 等待队列头结构包括一个自旋锁和一个链表头。等待队列元素除了包括链表项，还包括： flags : 标识队列元素状态和属性 *private: 用于指向关联进程 task_struct 结构体的指针 func : 函数指针，用于指向等待队列被唤醒时的回调的唤醒函数 以进程阻塞和唤醒的过程为例，等待队列的使用场景可以简述为： 进程 A 因等待某些资源（依赖进程 B 的某些操作）而不得不进入阻塞状态，便将当前进程加入到等待队列 Q 中。进程 B 在一系列操作后，可通知进程 A 所需资源已到位，便调用唤醒函数 wake up 来唤醒等待队列上 Q 的进程，注意此时所有等待在队列 Q 上的进程均被置为可运行状态。 借助上述描述场景，说明等待队列元素属性 flags 标志的作用，下文也将结合源码进行详细解读。 (1) WQ_FLAG_EXCLUSIVE 上述场景中看到，当某进程调用 wake up 函数唤醒等待队列时，队列上所有的进程均被唤醒，在某些场合会出现唤醒的所有进程中，只有某个进程获得了期望的资源，而其他进程由于资源被占用不得不再次进入休眠。如果等待队列中进程数量庞大时，该行为将影响系统性能。 内核增加了”独占等待”(WQ_FLAG_EXCLUSIVE)来解决此类问题。一个独占等待的行为和通常的休眠类似，但有如下两个重要的不同： 等待队列元素设置 WQ_FLAG_EXCLUSIVE 标志时，会被添加到等待队列的尾部，而非头部。 在某等待队列上调用 wake up 时，执行独占等待的进程每次只会唤醒其中第一个（所有非独占等待进程仍会被同时唤醒）。 (2) WQ_FLAG_WOKEN 暂时还未理解，TODO (3) WQ_FLAG_BOOKMARK 用于 wake_up() 唤醒等待队列时实现分段遍历，减少单次对自旋锁的占用时间。 三、 等待队列的创建和初始化等待队列头的定义和初始化有两种方式： init_waitqueue_head(&amp;wq_head) 和宏定义 DECLARE_WAIT_QUEUE_HEAD(name) 。 123456789101112#define init_waitqueue_head(wq_head) \\ do &#123; \\ static struct lock_class_key __key; \\ __init_waitqueue_head((wq_head), #wq_head, &amp;__key); \\ &#125; while (0)void __init_waitqueue_head(struct wait_queue_head *wq_head, const char *name, struct lock_class_key *key)&#123; spin_lock_init(&amp;wq_head-&gt;lock); lockdep_set_class_and_name(&amp;wq_head-&gt;lock, key, name); INIT_LIST_HEAD(&amp;wq_head-&gt;head);&#125; 123456#define DECLARE_WAIT_QUEUE_HEAD(name) \\ struct wait_queue_head name = __WAIT_QUEUE_HEAD_INITIALIZER(name)#define __WAIT_QUEUE_HEAD_INITIALIZER(name) &#123; \\ .lock = __SPIN_LOCK_UNLOCKED(name.lock), \\ .head = &#123; &amp;(name).head, &amp;(name).head &#125; &#125; 四、等待队列元素的创建和初始化创建等待队列元素较为普遍的一种方式是调用宏定义 DECLARE_WAITQUEUE(name, task) ，将定义一个名为 name 的等待队列元素， private 数据指向给定的关联进程结构体 task ，唤醒函数为 default_wake_function() 。后文介绍唤醒细节时详细介绍唤醒函数的工作。 1234567#define DECLARE_WAITQUEUE(name, tsk) \\ struct wait_queue_entry name = __WAITQUEUE_INITIALIZER(name, tsk)#define __WAITQUEUE_INITIALIZER(name, tsk) &#123; \\ .private = tsk, \\ .func = default_wake_function, \\ .entry = &#123; NULL, NULL &#125; &#125; 内核源码中还存在其他定义等待队列元素的方式，调用宏定义 DEFINE_WAIT(name) 和 init_wait(&amp;wait_queue) 。 这两种方式都将当前进程(current)关联到所定义的等待队列上，唤醒函数为 autoremove_wake_function() ，注意此函数与上述宏定义方式时不同（上述定义中使用 default_wake_function() ）。 下文也将介绍 DEFINE_WAIT() 和 DECLARE_WAITQUEUE() 在使用场合上的不同。 1234567#define DEFINE_WAIT(name) DEFINE_WAIT_FUNC(name, autoremove_wake_function)#define DEFINE_WAIT_FUNC(name, function) \\ struct wait_queue_entry name = &#123; \\ .private = current, \\ .func = function, \\ .entry = LIST_HEAD_INIT((name).entry), \\ &#125; 1234567#define init_wait(wait) \\ do &#123; \\ (wait)-&gt;private = current; \\ (wait)-&gt;func = autoremove_wake_function; \\ INIT_LIST_HEAD(&amp;(wait)-&gt;entry); \\ (wait)-&gt;flags = 0; \\ &#125; while (0) 五、添加和移除等待队列内核提供了两个函数（定义在 kernel&#x2F;sched&#x2F;wait.c ）用于将等待队列元素 wq_entry 添加到等待队列 wq_head 中： add_wait_queue() 和 add_wait_queue_exclusive() 。 add_wait_queue() ：在等待队列头部添加普通的等待队列元素（非独占等待，清除 WQ_FLAG_EXCLUSIVE 标志）。 add_wait_queue_exclusive() ：在等待队列尾部添加独占等待队列元素（设置了 WQ_FLAG_EXCLUSIVE 标志）。 1234567891011121314void add_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)&#123; unsigned long flags; // 清除WQ_FLAG_EXCLUSIVE标志 wq_entry-&gt;flags &amp;= ~WQ_FLAG_EXCLUSIVE; spin_lock_irqsave(&amp;wq_head-&gt;lock, flags); __add_wait_queue(wq_head, wq_entry); spin_unlock_irqrestore(&amp;wq_head-&gt;lock, flags);&#125; static inline void __add_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)&#123; list_add(&amp;wq_entry-&gt;entry, &amp;wq_head-&gt;head);&#125; 1234567891011121314void add_wait_queue_exclusive(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)&#123; unsigned long flags; // 设置WQ_FLAG_EXCLUSIVE标志 wq_entry-&gt;flags |= WQ_FLAG_EXCLUSIVE; spin_lock_irqsave(&amp;wq_head-&gt;lock, flags); __add_wait_queue_entry_tail(wq_head, wq_entry); spin_unlock_irqrestore(&amp;wq_head-&gt;lock, flags);&#125;static inline void __add_wait_queue_entry_tail(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)&#123; list_add_tail(&amp;wq_entry-&gt;entry, &amp;wq_head-&gt;head);&#125; remove_wait_queue() 函数用于将等待队列元素 wq_entry 从等待队列 wq_head 中移除。 12345678910111213void remove_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)&#123; unsigned long flags; spin_lock_irqsave(&amp;wq_head-&gt;lock, flags); __remove_wait_queue(wq_head, wq_entry); spin_unlock_irqrestore(&amp;wq_head-&gt;lock, flags);&#125;static inline void__remove_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)&#123; list_del(&amp;wq_entry-&gt;entry);&#125; 添加和移除等待队列的示意图如下所示： 六、等待事件内核中提供了等待事件 wait_event() 宏（以及它的几个变种），可用于实现简单的进程休眠，等待直至某个条件成立，主要包括如下几个定义： wait_event(wq_head, condition)wait_event_timeout(wq_head, condition, timeout)wait_event_interruptible(wq_head, condition)wait_event_interruptible_timeout(wq_head, condition, timeout)io_wait_event(wq_head, condition) 上述所有形式函数中， wq_head 是等待队列头（采用”值传递“的方式传输函数）， condition 是任意一个布尔表达式。使用 wait_event ，进程将被置于非中断休眠，而使用 wait_event_interruptible 时，进程可以被信号中断。 另外两个版本 wait_event_timeout 和 wait_event_interruptible_timeout 会使进程只等待限定的时间（以jiffy表示，给定时间到期时，宏均会返回0，而无论 condition 为何值）。 详细介绍 wait_event() 函数的实现原理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#define wait_event(wq_head, condition) \\ do &#123; \\ might_sleep(); \\ // 如果condition满足，提前返回 \\ if (condition) \\ break; \\ __wait_event(wq_head, condition); \\ &#125; while (0)#define __wait_event(wq_head, condition) \\ (void)___wait_event(wq_head, condition, TASK_UNINTERRUPTIBLE, 0, 0, schedule())/* 定义等待队列元素，并将元素加入到等待队列中 * 循环判断等待条件condition是否满足，若条件满足，或者接收到中断信号，等待结束，函数返回 * 若condition满足，返回0；否则返回-ERESTARTSYS */#define ___wait_event(wq_head, condition, state, exclusive, ret, cmd) \\(&#123; \\ __label__ __out; \\ struct wait_queue_entry __wq_entry; \\ long __ret = ret; /* explicit shadow */ \\ \\ // 初始化等待队列元素__wq_entry，关联当前进程，根据exclusive参数初始化属性标志 \\ // 唤醒函数为autoremove_wake_function() \\ init_wait_entry(&amp;__wq_entry, exclusive ? WQ_FLAG_EXCLUSIVE : 0); \\ // 等待事件循环 \\ for (;;) &#123; \\ // 如果进程可被信号中断并且刚好有信号挂起，返回-ERESTARTSYS \\ // 否则，将等待队列元素加入等待队列，并且设置进程状态，返回0 \\ long __int = prepare_to_wait_event(&amp;wq_head, &amp;__wq_entry, state);\\ \\ // 当前进程让出调度器前，判断condition是否成立。若成立，提前结束，后续将返回0 \\ if (condition) \\ break; \\ \\ // 当前进程让出调度器前，判断当前进程是否接收到中断信号（或KILL信号） \\ // 如果成立，将提前返回-ERESTARTSYS \\ if (___wait_is_interruptible(state) &amp;&amp; __int) &#123; \\ __ret = __int; \\ goto __out; \\ &#125; \\ \\ // 此处实际执行schedule()，当前进程让出调度器 \\ cmd; \\ &#125; \\ // 设置进程为可运行状态，并且将等待队列元素从等待队列中删除 \\ finish_wait(&amp;wq_head, &amp;__wq_entry); \\ __out: __ret; \\&#125;) void init_wait_entry(struct wait_queue_entry *wq_entry, int flags) &#123; wq_entry-&gt;flags = flags; wq_entry-&gt;private = current; wq_entry-&gt;func = autoremove_wake_function; INIT_LIST_HEAD(&amp;wq_entry-&gt;entry);&#125;long prepare_to_wait_event(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry, int state)&#123; unsigned long flags; long ret = 0; spin_lock_irqsave(&amp;wq_head-&gt;lock, flags); // 返回非0值条件：可被信号中断并且确实有信号挂起 if (signal_pending_state(state, current)) &#123; // 将等待队列元素从等待队列中删除，返回-ERESTARTSYS list_del_init(&amp;wq_entry-&gt;entry); ret = -ERESTARTSYS; &#125; else &#123; // 判断wq_entry-&gt;entry是否为空，即等待队列元素是否已经被添加到等待队列中 if (list_empty(&amp;wq_entry-&gt;entry)) &#123; // WQ_FLAG_EXCLUSIVE标志被设置时，将等待队列元素添加到等待队列尾部（独占等待） // 否则，将等待队列元素添加到等待队列头部。同2.1中对WQ_FLAG_EXCLUSIVE标志介绍。 if (wq_entry-&gt;flags &amp; WQ_FLAG_EXCLUSIVE) __add_wait_queue_entry_tail(wq_head, wq_entry); else __add_wait_queue(wq_head, wq_entry); &#125; // 改变当前进程的状态 set_current_state(state); &#125; spin_unlock_irqrestore(&amp;wq_head-&gt;lock, flags); return ret;&#125;// 用state_value改变当前的进程状态，并且执行了一次内存屏障// 注意，只是改变了调度器处理该进程的方式，但尚未使该进程让出处理器#define set_current_state(state_value) \\ do &#123; \\ WARN_ON_ONCE(is_special_task_state(state_value));\\ current-&gt;task_state_change = _THIS_IP_; \\ smp_store_mb(current-&gt;state, (state_value)); \\ &#125; while (0)/* 设置进程为可运行状态，并且将等待队列元素从等待队列中删除 */void finish_wait(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)&#123; unsigned long flags; // 将当前进程状态改为可运行状态(TASK_RUNNING) // 类似set_current_state()，差别在于未进行内存屏障 __set_current_state(TASK_RUNNING); // 等待队列元素若仍在等待队列中，则将其删除 if (!list_empty_careful(&amp;wq_entry-&gt;entry)) &#123; spin_lock_irqsave(&amp;wq_head-&gt;lock, flags); list_del_init(&amp;wq_entry-&gt;entry); spin_unlock_irqrestore(&amp;wq_head-&gt;lock, flags); &#125;&#125; 经过源码分析可以看到， wait_event 使进程进入非中断休眠状态，循环等待直至特定条件满足，否则进程继续保持休眠状态。 可以简单总结出使用等待队列使进程休眠的一般步骤： 将当前进程关联的等待队列元素加入到等待队列中。 __add_wait_queue()&#x2F;__add_wait_queue_entry_tail() 设置当前进程状态（可中断 TASK_INTERRUPTIBLE 或不可中断 TASK_UNINTERRUPTIBLE）。 set_current_state() 判断资源是否得到，或是否捕获中断信号。 进程让出调度器，进入休眠状态。 schedule() 资源得到满足时，将等待队列元素从等待队列中移除。 七、等待队列唤醒前文已经简单提到， wake_up 函数可用于将等待队列上的所有进程唤醒，和 wait_event 相对应， wake_up 函数也包括多个变体。主要包括： wake_up(&amp;wq_head)wake_up_interruptible(&amp;wq_head)wake_up_nr(&amp;wq_head, nr)wake_up_interruptible_nr(&amp;wq_head, nr)wake_up_interruptible_all(&amp;wq_head) wake_up() wake_up() 可以用来唤醒等待队列上的所有进程，而 wake_up_interruptible() 只会唤醒那些执行可中断休眠的进程。因此约定， wait_event() 和 wake_up() 搭配使用，而 wait_event_interruptible() 和 wake_up_interruptible() 搭配使用。 前文提到，对于独占等待的进程， wake_up() 只会唤醒第一个独占等待进程。 wake_up_nr() 函数提供功能，它能唤醒给定数目nr个独占等待进程，而不是只有一个。 wake_up() 函数的实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#define TASK_NORMAL (TASK_INTERRUPTIBLE | TASK_UNINTERRUPTIBLE)// 可以看出wake_up函数将唤醒TASK_INTERRUPTIBLE和TASK_UNINTERRUPTIBLE的所有进程#define wake_up(x) __wake_up(x, TASK_NORMAL, 1, NULL)void __wake_up(struct wait_queue_head *wq_head, unsigned int mode, int nr_exclusive, void *key)&#123; __wake_up_common_lock(wq_head, mode, nr_exclusive, 0, key);&#125;static void __wake_up_common_lock(struct wait_queue_head *wq_head, unsigned int mode, int nr_exclusive, int wake_flags, void *key)&#123; unsigned long flags; wait_queue_entry_t bookmark; bookmark.flags = 0; bookmark.private = NULL; bookmark.func = NULL; INIT_LIST_HEAD(&amp;bookmark.entry); // 第一次尝试调用__wake_up_common()，如果需要进行BOOKMARK过程，bookmark.flags会被置为WQ_FLAG_BOOKMARK spin_lock_irqsave(&amp;wq_head-&gt;lock, flags); nr_exclusive = __wake_up_common(wq_head, mode, nr_exclusive, wake_flags, key, &amp;bookmark); spin_unlock_irqrestore(&amp;wq_head-&gt;lock, flags); // 如果还有需要处理的元素，那么bookmark.flags肯定置上WQ_FLAG_BOOKMARK；否则，在一个loop内便处理完成 while (bookmark.flags &amp; WQ_FLAG_BOOKMARK) &#123; spin_lock_irqsave(&amp;wq_head-&gt;lock, flags); nr_exclusive = __wake_up_common(wq_head, mode, nr_exclusive, wake_flags, key, &amp;bookmark); spin_unlock_irqrestore(&amp;wq_head-&gt;lock, flags); &#125;&#125;#define WAITQUEUE_WALK_BREAK_CNT 64static int __wake_up_common(struct wait_queue_head *wq_head, unsigned int mode, int nr_exclusive, int wake_flags, void *key, wait_queue_entry_t *bookmark)&#123; wait_queue_entry_t *curr, *next; int cnt = 0; // 判断自旋锁已经被持有 lockdep_assert_held(&amp;wq_head-&gt;lock); // 如果bookmark元素中标志`WQ_FLAG_BOOKMARK`已被设置，则curr被设置为bookmark下一个元素 // 同时将bookmark从等待队列中删除，bookmark-&gt;flags清零 // 否则，curr设置为等待队列wq_head的第一个元素（实际上为第一次调用__wake_up_common） if (bookmark &amp;&amp; (bookmark-&gt;flags &amp; WQ_FLAG_BOOKMARK)) &#123; curr = list_next_entry(bookmark, entry); list_del(&amp;bookmark-&gt;entry); bookmark-&gt;flags = 0; &#125; else curr = list_first_entry(&amp;wq_head-&gt;head, wait_queue_entry_t, entry); if (&amp;curr-&gt;entry == &amp;wq_head-&gt;head) return nr_exclusive; // 在等待队列头指向的链表上，从curr指向的元素开始依次遍历元素 list_for_each_entry_safe_from(curr, next, &amp;wq_head-&gt;head, entry) &#123; unsigned flags = curr-&gt;flags; int ret; // 跳过标记为WQ_FLAG_BOOKMARK的元素，等待队列元素被置上WQ_FLAG_BOOKMARK？ if (flags &amp; WQ_FLAG_BOOKMARK) continue; // 调用等待队列元素绑定的唤醒回调函数 // 注意，具体唤醒何种进程(TASK_INTERRUPTIBLE/TASK_UNINTERRUPTIBLE)，作为参数传递给唤醒函数处理 // 当进程不符合唤醒条件时，ret为0，详见try_to_wake_up() ret = curr-&gt;func(curr, mode, wake_flags, key); if (ret &lt; 0) break; // 如果当前等待队列元素为独占等待，并且独占等待个数已经等于nr_exclusive，提前退出循环 // 如2.1所述，独占等待进程被加入到等待队列的尾部，因此此时表明所有唤醒工作已经完成 if (ret &amp;&amp; (flags &amp; WQ_FLAG_EXCLUSIVE) &amp;&amp; !--nr_exclusive) break; // 连续唤醒的进程数目达到指定数目WAITQUEUE_WALK_BREAK_CNT（仍有进程元素需要处理）， // 标记bookmark-&gt;flags为WQ_FLAG_BOOKMARK，同时将下一个要处理的元素添加到bookmark作为头节点的链表尾部，并退出遍历循环 // 通过这种机制，实现了进程分批次唤醒，避免了等待队列中自旋锁被持有时间过长 if (bookmark &amp;&amp; (++cnt &gt; WAITQUEUE_WALK_BREAK_CNT) &amp;&amp; (&amp;next-&gt;entry != &amp;wq_head-&gt;head)) &#123; bookmark-&gt;flags = WQ_FLAG_BOOKMARK; list_add_tail(&amp;bookmark-&gt;entry, &amp;next-&gt;entry); break; &#125; &#125; return nr_exclusive;&#125; wake_up() 函数会遍历等待队列上的所有元素（包括TASK_INTERRUPTIBLE和TASK_UNINTERRUPTIBLE)），根据 nr_exclusive 参数的要求唤醒进程，同时实现了分批次唤醒工作。最终会回调等待队列元素所绑定的唤醒函数。 前文已经提到，定义等待队列元素时主要涉及到两种唤醒回调函数： default_wake_function() ：宏定义 DECLARE_WAITQUEUE(name, tsk) 使用的唤醒函数。 autoremove_wake_function() ： DEFINE_WAIT(name) ， init_wait(wait) 和 wait_event() 中调用的 init_wait_entry() 使用此唤醒函数。 default_wake_function()1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465int default_wake_function(wait_queue_entry_t *curr, unsigned mode, int wake_flags, void *key)&#123; return try_to_wake_up(curr-&gt;private, mode, wake_flags);&#125;static inttry_to_wake_up(struct task_struct *p, unsigned int state, int wake_flags)&#123; unsigned long flags; int cpu, success = 0; raw_spin_lock_irqsave(&amp;p-&gt;pi_lock, flags); smp_mb__after_spinlock(); // 此处对进程的状态进行筛选，跳过不符合状态的进程（TASK_INTERRUPTIBLE/TASK_UNINTERRUPTIBLE） if (!(p-&gt;state &amp; state)) goto out; trace_sched_waking(p); /* We&#x27;re going to change -&gt;state: */ success = 1; cpu = task_cpu(p); smp_rmb(); if (p-&gt;on_rq &amp;&amp; ttwu_remote(p, wake_flags)) goto stat; ... ... // Try-To-Wake-Up ttwu_queue(p, cpu, wake_flags);stat: ttwu_stat(p, cpu, wake_flags);out: raw_spin_unlock_irqrestore(&amp;p-&gt;pi_lock, flags); return success;&#125;static void ttwu_queue(struct task_struct *p, int cpu, int wake_flags)&#123; struct rq *rq = cpu_rq(cpu); struct rq_flags rf; ... ... rq_lock(rq, &amp;rf); update_rq_clock(rq); ttwu_do_activate(rq, p, wake_flags, &amp;rf); rq_unlock(rq, &amp;rf);&#125;static voidttwu_do_activate(struct rq *rq, struct task_struct *p, int wake_flags, struct rq_flags *rf)&#123; int en_flags = ENQUEUE_WAKEUP | ENQUEUE_NOCLOCK; lockdep_assert_held(&amp;rq-&gt;lock); ... ... activate_task(rq, p, en_flags); ttwu_do_wakeup(rq, p, wake_flags, rf);&#125;/* * Mark the task runnable and perform wakeup-preemption. */static void ttwu_do_wakeup(struct rq *rq, struct task_struct *p, int wake_flags, struct rq_flags *rf)&#123; check_preempt_curr(rq, p, wake_flags); p-&gt;state = TASK_RUNNING; trace_sched_wakeup(p); ... ...&#125; 从函数调用过程中可以看到， default_wake_function() 实现唤醒进程的过程为： default_wake_function() –&gt; try_to_wake_up() –&gt; ttwu_queue() –&gt; ttwu_do_activate() –&gt; ttwu_do_wakeup() 值得一提的是， default_wake_function() 的实现中并未将等待队列元素从等待队列中删除。因此，编写程序时不能忘记添加步骤将等待队列元素从等待队列元素中删除。 autoremove_wake_function()1234567int autoremove_wake_function(struct wait_queue_entry *wq_entry, unsigned mode, int sync, void *key)&#123; int ret = default_wake_function(wq_entry, mode, sync, key); if (ret) list_del_init(&amp;wq_entry-&gt;entry); return ret;&#125; autoremove_wake_function() 相比于 default_wake_function() ，在成功执行进程唤醒工作后，会自动将等待队列元素从等待队列中移除。","tags":["kernel"],"categories":["kernel"]},{"title":"module_init宏详解&insmod流程&THIS_MODULE","path":"/posts/module-init宏详解-insmod流程-THIS-MODULE.html","content":"一个模块可以编译进内核，和内核一起打包，也可以作为一个单独模块，单独加载，如ko，本节以ko为例 以最简单的例子讲解： 12345678910111213141516171819202122// //helloworld.c#include &lt;linux/kernel.h&gt;#include &lt;linux/module.h&gt;//内核模块初始化函数static int __init hello_init(void)&#123; printk(&quot;Hello World &quot;); return 0;&#125;//内核模块退出函数static void __exit hello_exit(void)&#123; printk(&quot;exit &quot;);&#125;module_init(hello_init);module_exit(hello_exit);MODULE_LICENSE(&quot;GPL&quot;); 一、一个特殊的段.gnu.linkonce.this_module section(THIS_MODULE定义)当我们编译生成.ko模块时，会在该目录下产生这样一个附加文件helloworld.mod.c，这个文件内容如下：其实THIS_MODULE在内核的定义就是__this_module，通过这个宏就能拿到本模块的一些信息 1234567891011// helloworld.mod.c__visible struct module __this_module__section(&quot;.gnu.linkonce.this_module&quot;) = &#123; .name = KBUILD_MODNAME, .init = init_module,#ifdef CONFIG_MODULE_UNLOAD .exit = cleanup_module,#endif .arch = MODULE_ARCH_INIT,&#125;; 这个后缀为.mod.c的文件会初始化模块 struct module 的这几个成员： 123456789101112131415struct module &#123; ...... /* Unique handle for this module */ char name[MODULE_NAME_LEN]; /* Startup function. */ int (*init)(void); /* Destruction function. */ void (*exit)(void); /* Arch-specific module values */ struct mod_arch_specific arch; ......&#125; 通过__section(“.gnu.linkonce.this_module”)我们可以知道将该struct module实例添加到内核模块ELF文件中“.gnu.linkonce.this_module”section中。 1readelf -S helloworld.ko 二、初始化和清理函数初始化和清理函数在这里我们发现.mod.c后缀文件的模块初始化函数和清理函数名字是init_module和cleanup_module，而我们编写的内核模块程序中是module_init和module_exit： 12.init = init_module,.exit = cleanup_module, 12module_init(hello_init);module_exit(hello_exit); 接下来咱们一起看看module_init源码实现细节： 三、module_init的定义其实module_init在内核中&lt;linux&#x2F;module.h&gt;中有两个定义，通过MODULE宏来区分，在咱们编译ko时，使用的命令通常如下： 1make -C $(KDIR) M=$(PWD) modules 这时会进入内核源码树的顶层Makefile下查找modules目标协助编译，MODULE宏的定义是由内核顶层的Makefile和script&#x2F;Makefile.lib配合实现的 Makefile 12KBUILD_AFLAGS_MODULE := -DMODULEKBUILD_CFLAGS_MODULE := -DMODULE scripts&#x2F;Makefile.lib 123456part-of-module = $(if $(filter $(basename $@).o, $(real-obj-m)),y)quiet_modtag = $(if $(part-of-module),[M], )modkern_cflags = \\ $(if $(part-of-module), \\ $(KBUILD_CFLAGS_MODULE) $(CFLAGS_MODULE), \\ $(KBUILD_CFLAGS_KERNEL) $(CFLAGS_KERNEL) $(modfile_flags)) $@ 表示正在编译的目标，如果是 module 的一部分，则使用 KBUILD_CFLAGS_MODULE 作为 cflags ，即 -DMODULE 被引入 gcc 命令行 此时module_init实现如下： 1234567891011121314// linux-4.10.1/include/linux/module.h/* Each module must use one module_init(). */#define module_init(initfn) \\ static inline initcall_t __inittest(void) \\ &#123; return initfn; &#125; \\ int init_module(void) __attribute__((alias(#initfn)));/* This is only required if you want to be unloadable. */#define module_exit(exitfn) \\ static inline exitcall_t __exittest(void) \\ &#123; return exitfn; &#125; \\ void cleanup_module(void) __attribute__((alias(#exitfn))); 这使用了gcc提供的别名属性（attribute(alias)）：将init_module函数的别名设置为initfn，而initfn就是我们模块程序中的初始化函数。将cleanup_module的别名设置为exitfn，而exitfn就是我们模块程序的清理函数。 四、__init函数和__exit函数定义如下： 12#define __init __section(.init.text) __cold notrace __latent_entropy#define __exit __section(.exit.text) __exitused __cold notrace 这两个前缀是为了将初始化函数和清理函数放置在ko二进制文件正确的section中。 五、insmod流程insmod对应的是busybox的一个命令，可以看busybox中的insmod_main函数中的具体实现，这里简单描述一下： insmod将ko文件使用mmap映射，获取到地址，然后通过系统调用SYSCALL_DEFINE3进入内核 1234SYSCALL_DEFINE3(init_module) --&gt;load_module() --&gt;layout_and_allocate() --&gt;setup_load_info() load_module中会把.gnu.linkonce.this_module section中的内容初始化给 struct module，然后通过一些列操作，重定位等，获取到.init_text中的位置，最后调用进去，也就是调用到了module_init中的函数，也就是本例中的hello_init。至此ko加载成功，hello_init函数执行","tags":["kernel"],"categories":["kernel"]},{"title":"Linux内核的initcall机制","path":"/posts/Linux内核的initcall机制.html","content":"从根文件系统的挂载说起吧，使能了initd小文件系统的OS，最终会调用到populate_rootfs执行解压挂载的操作，搜索populate最终看到是rootfs_initcall被执行到的，那就从此处开始说起吧，看看内核是如何执行到这个函数的 一、initcall函数调用流程调用链如下： 12345678910init/main.c调用链如下： start_kernel() ----&gt;arch_call_rest_init() ----&gt;rest_init() ----&gt;kernel_init() ----&gt;kernel_init_freeable() ----&gt;do_basic_setup() ----&gt;do_initcalls() 1234567891011121314151617181920 static initcall_entry_t *initcall_levels[] __initdata = &#123; __initcall0_start, __initcall1_start, __initcall2_start, __initcall3_start, __initcall4_start, __initcall5_start, __initcall6_start, __initcall7_start, __initcall_end,&#125;; static void __init do_initcalls(void)&#123; int level; for (level = 0; level &lt; ARRAY_SIZE(initcall_levels) - 1; level++) do_initcall_level(level);&#125; for 循环针对一个指针数组轮询，该数组是一个静态的 initcall_entry_t 类型，这些数据都存放在 __initdata 段。 指针数组的类型为 initcall_entry_t，是 initcall_t 的另一种叫法 继续来看下这个指针数组中的元素：__initcall0_start ~ __initcall_end，而这些元素的值在本c文件中已经声明： 123456789101112init/main.c extern initcall_entry_t __initcall_start[];extern initcall_entry_t __initcall0_start[];extern initcall_entry_t __initcall1_start[];extern initcall_entry_t __initcall2_start[];extern initcall_entry_t __initcall3_start[];extern initcall_entry_t __initcall4_start[];extern initcall_entry_t __initcall5_start[];extern initcall_entry_t __initcall6_start[];extern initcall_entry_t __initcall7_start[];extern initcall_entry_t __initcall_end[]; 不难看出，数组 initcall_levels 中元素存放的是这些函数指针数组的首地址。 那么这些实际的指针数组是在哪里呢？从上文得知，initcall 函数都会被定义成 static initcall_t 类型，并且保存在 .initcall##level##.init 段中，那么 initcall_levels 与其是怎么关联的呢？ 答案在 vmlinux.lds.h 中。 二、vmlinux.lds.h12345678910111213141516171819include/asm-generic/vmlinux.lds.h #define INIT_CALLS_LEVEL(level) \\ __initcall##level##_start = .; \\ KEEP(*(.initcall##level##.init)) \\ KEEP(*(.initcall##level##s.init)) \\#define INIT_CALLS \\ __initcall_start = .; \\ KEEP(*(.initcallearly.init)) \\ INIT_CALLS_LEVEL(0) \\ INIT_CALLS_LEVEL(1) \\ INIT_CALLS_LEVEL(2) \\ INIT_CALLS_LEVEL(3) \\ INIT_CALLS_LEVEL(4) \\ INIT_CALLS_LEVEL(5) \\ INIT_CALLS_LEVEL(rootfs) \\ INIT_CALLS_LEVEL(6) \\ INIT_CALLS_LEVEL(7) \\ __initcall_end = .; 在这里首先定义了__initcall_start，将其关联到”.initcallearly.init”段。 然后对每个level定义了INIT_CALLS_LEVEL(level)，将INIT_CALLS_LEVEL(level)展开之后的结果是定义__initcall##level##_start，并将__initcall##level##_start关联到”.initcall##level##.init”段和”.initcall##level##s.init”段。 12345678910111213141516__initcall_start = .; \\*(.initcallearly.init) \\__initcall0_start = .; \\*(.initcall0.init) \\*(.initcall0s.init) \\// 省略1、2、3、4、5__initcallrootfs_start = .; \\*(.initcallrootfs.init) \\*(.initcallrootfss.init) \\__initcall6_start = .; \\*(.initcall6.init) \\*(.initcall6s.init) \\__initcall7_start = .; \\*(.initcall7.init) \\*(.initcall7s.init) \\__initcall_end = .; 上面这些代码段最终在kernel.img中按先后顺序组织，也就决定了位于其中的一些函数的执行先后顺序。 在 kernel_init() 初始化完成后，会调用 free_initmem() 对内核 init 段的内存进行释放处理。即 .init 或者 .initcalls 段在内核启动完毕后，这个段中的内存会被释放掉。 三、do_initcall_leveldo_initcall_level函数定义如下： 1234567891011121314151617init/main.c static void __init do_initcall_level(int level)&#123; initcall_entry_t *fn; strcpy(initcall_command_line, saved_command_line); parse_args(initcall_level_names[level], initcall_command_line, __start___param, __stop___param - __start___param, level, level, NULL, &amp;repair_env_string); trace_initcall_level(initcall_level_names[level]); for (fn = initcall_levels[level]; fn &lt; initcall_levels[level+1]; fn++) do_one_initcall(initcall_from_entry(fn));&#125; do_initcall_level() 函数的参数 level 是之前是initcall_levels 数组的索引，从第0个开始。 这里再用一个 for 循环，跳到 initcall_levels 内部元素 (函数指针数组)进行轮询，fn 初始值为函数指针数组的起始地址，后面 fn++ 相当于函数指针 +1，即跳到下一个函数指针。 即for 循环中，根据传入的 level，确定需要轮询的 .initcall##level##.init 段的所有函数指针，一直到下一个 .intcall##(level+1)##.init 段。 另外，需要注意 do_one_initcall() 的参数就是获取函数指针的内容，而这个内容就是注册进来的 initcall 的实际初始化函数。 如上面的举例： 1rootfs_initcall(populate_rootfs); 这里最终就看成调用 do_one_initcall(populate_rootfs)； 12345678910init/main.c int __init_or_module do_one_initcall(initcall_t fn)&#123; ... ret = fn(); ... return ret;&#125; 四、initcall源码上文提到过 Linux 对驱动程序提供静态编译进内核和动态加载两种方式，Linux 的 initcall 机制也是根据静态编译和动态加载的两种方式选择不同的编译、运行流程。 1234567891011include/linux/init.h #ifndef MODULE ... //静态加载 #else ... //动态加载 #endif MODULE 是在编译的时候，通过编译器参数来传入。例如，在编译 ko 时会使用如下两个编译选项，如果是链接到内核，则不会使用： 1234//Makefile KBUILD_AFLAGS_MODULE := -DMODULEKBUILD_CFLAGS_MODULE := -DMODULE 通过 MODULE 的配置，选择静态编译还是动态加载。 本文将只分析静态编译流程 内核中定义的initcall如下： 1234567891011121314151617181920212223242526272829303132333435363738394041include/linux/init.h /* * Early initcalls run before initializing SMP. * * Only for built-in code, not modules. */#define early_initcall(fn) __define_initcall(fn, early) /* * A &quot;pure&quot; initcall has no dependencies on anything else, and purely * initializes variables that couldn&#x27;t be statically initialized. * * This only exists for built-in code, not for modules. * Keep main.c:initcall_level_names[] in sync. */#define pure_initcall(fn) __define_initcall(fn, 0) #define core_initcall(fn) __define_initcall(fn, 1)#define core_initcall_sync(fn) __define_initcall(fn, 1s)#define postcore_initcall(fn) __define_initcall(fn, 2)#define postcore_initcall_sync(fn) __define_initcall(fn, 2s)#define arch_initcall(fn) __define_initcall(fn, 3)#define arch_initcall_sync(fn) __define_initcall(fn, 3s)#define subsys_initcall(fn) __define_initcall(fn, 4)#define subsys_initcall_sync(fn) __define_initcall(fn, 4s)#define fs_initcall(fn) __define_initcall(fn, 5)#define fs_initcall_sync(fn) __define_initcall(fn, 5s)#define rootfs_initcall(fn) __define_initcall(fn, rootfs)#define device_initcall(fn) __define_initcall(fn, 6)#define device_initcall_sync(fn) __define_initcall(fn, 6s)#define late_initcall(fn) __define_initcall(fn, 7)#define late_initcall_sync(fn) __define_initcall(fn, 7s) #define __initcall(fn) device_initcall(fn) #define __exitcall(fn) \\ static exitcall_t __exitcall_##fn __exit_call = fn #define console_initcall(fn) ___define_initcall(fn, con, .con_initcall) 对于静态编译 initcall 接口如上，其中 pure_initcall() 只能在静态编译中存在。 当然，对于静态编译的驱动也可以调佣 module_init() 接口： 12345include/linux/module.h #define module_init(x) __initcall(x); #define module_exit(x) __exitcall(x); module_init在内核中是有两种定义的，module_init定义在&lt;linux&#x2F;module.h&gt;中，当包含此头文件的代码中，没有定义MODULE宏时，module_init定义为initcall形式 五、initcall级别1234567891011early--&gt;0--&gt;0s--&gt;1--&gt;1s--&gt;2--&gt;2s--&gt;3--&gt;3s--&gt;4--&gt;4s--&gt;5--&gt;5s--&gt;rootfs--&gt;6--&gt;6s--&gt;7--&gt;7s--&gt;console __define_initcall实现： 123456789101112131415161718192021222324252627282930include/linux/init.h #ifdef CONFIG_LTO_CLANG /* * With LTO, the compiler doesn&#x27;t necessarily obey link order for * initcalls, and the initcall variable needs to be globally unique * to avoid naming collisions. In order to preserve the correct * order, we add each variable into its own section and generate a * linker script (in scripts/link-vmlinux.sh) to ensure the order * remains correct. We also add a __COUNTER__ prefix to the name, * so we can retain the order of initcalls within each compilation * unit, and __LINE__ to make the names more unique. */ #define ___lto_initcall(c, l, fn, id, __sec) \\ static initcall_t __initcall_##c##_##l##_##fn##id __used \\ __attribute__((__section__( #__sec \\ __stringify(.init..##c##_##l##_##fn)))) = fn; #define __lto_initcall(c, l, fn, id, __sec) \\ ___lto_initcall(c, l, fn, id, __sec) #define ___define_initcall(fn, id, __sec) \\ __lto_initcall(__COUNTER__, __LINE__, fn, id, __sec)#else #define ___define_initcall(fn, id, __sec) \\ static initcall_t __initcall_##fn##id __used \\ __attribute__((__section__(#__sec &quot;.init&quot;))) = fn;#endif#endif #define __define_initcall(fn, id) ___define_initcall(fn, id, .initcall##id) 下文会继续细化分析，这里提前提示： __define_initcall() 其实就是定义了一个 static initcall_t 的函数指针 1234include/linux/init.h typedef int (*initcall_t)(void);typedef void (*exitcall_t)(void); 六、attribute详解(1)、__used 123include/linux/compiler_attributes.h#define __used __attribute__((__used__)) 这是一种 attribute 修饰属性的一种，意思是告诉编译器：这个静态符号在编译的时候，即使没有使用也要保留，不能优化掉。 (2)、__attribute__ ((section(…)))attribute 是 GNU C 的一大特色，可以用来修饰对象、函数、结构体类型等等。 这里用来修改 section，意思是将作用的函数放入指定的 section name 对应的段中。 (3)、 __stringify() 1234include/linux/stringify.h #define __stringify_1(x...) #x#define __stringify(x...) __stringify_1(x) 将 __stringify() 中内容字符串化。 七、例子以静态的module_init定义为例： 假如，我们在驱动使用如下接口： 1module_init(hello_init); 那么，在编译的时候编译器会通过 initcall 接口产生： 12static initcall_t __initcall_1_23_hello_init6 __attribute__(__used) \\ __attribute__((__section__(&quot;.initcall6.init..1_23_hello_init&quot;))) = hello_init; linux 编译后的initcall 函数查看编译好的 System.map： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152...ffffffc012032ee0 d __initcall_223_42_trace_init_flags_sys_enterearlyffffffc012032ee0 D __initcall_startffffffc012032ee0 D __setup_endffffffc012032ee8 d __initcall_224_66_trace_init_flags_sys_exitearlyffffffc012032ef0 d __initcall_163_146_cpu_suspend_initearlyffffffc012032ef8 d __initcall_151_267_asids_initearlyffffffc012032f00 d __initcall_167_688_spawn_ksoftirqdearlyffffffc012032f08 d __initcall_343_6656_migration_initearly...ffffffc012032f90 d __initcall_312_768_initialize_ptr_randomearlyffffffc012032f98 D __initcall0_startffffffc012032f98 d __initcall_241_771_bpf_jit_charge_init0ffffffc012032fa0 d __initcall_141_53_init_mmap_min_addr0ffffffc012032fa8 d __initcall_209_6528_pci_realloc_setup_params0ffffffc012032fb0 d __initcall_339_1143_net_ns_init0ffffffc012032fb8 D __initcall1_startffffffc012032fb8 d __initcall_160_1437_fpsimd_init1ffffffc012032fc0 d __initcall_181_669_tagged_addr_init1...ffffffc012033178 d __initcall_347_1788_init_default_flow_dissectors1ffffffc012033180 d __initcall_360_2821_netlink_proto_init1ffffffc012033188 D __initcall2_startffffffc012033188 d __initcall_165_139_debug_monitors_init2ffffffc012033190 d __initcall_141_333_irq_sysfs_init2...ffffffc0120332b8 d __initcall_304_814_kobject_uevent_init2ffffffc0120332c0 d __initcall_184_1686_msm_rpm_driver_init2sffffffc0120332c8 D __initcall3_startffffffc0120332c8 d __initcall_173_390_debug_traps_init3ffffffc0120332d0 d __initcall_161_275_reserve_memblock_reserved_regions3...ffffffc012033370 d __initcall_132_5273_gsi_init3ffffffc012033378 d __initcall_149_547_of_platform_default_populate_init3sffffffc012033380 D __initcall4_start...ffffffc012033878 D __initcall5_start...ffffffc0120339d8 d __initcall_317_1188_xsk_init5ffffffc0120339e0 d __initcall_211_194_pci_apply_final_quirks5sffffffc0120339e8 d __initcall_168_680_populate_rootfsrootfsffffffc0120339e8 D __initcallrootfs_startffffffc0120339f0 D __initcall6_start...ffffffc012034b30 D __initcall7_start...ffffffc012034c88 d __initcall_150_554_of_platform_sync_state_init7sffffffc012034c90 d __initcall_123_29_alsa_sound_last_init7sffffffc012034c98 D __con_initcall_startffffffc012034c98 d __initcall_151_246_hvc_console_initconffffffc012034c98 D __initcall_endffffffc012034ca0 D __con_initcall_end 从 System.map 得知： 从 __initcall_start ~ __initcall_end 所有函数指针都是连续的，相差8 个字节； __initcall_start 就是第一个 early 级别的 initcall 函数指针，同理 __initcall0_start 就是第一个 level 0 级别的initcall 函数指针，以此类推； rootfs 级别的 initcall 函数是插在 level 5s 之后，level 6 级别之前； console 级别的函数在 level 7s 之后，__initcall_end 之前；当然通过命令 readelf 或者 objdump (objdump -h vmlinux.o)都能看到各个字段 12345678910111213141516171819202122232425262728293031323334Sections:Idx Name Size VMA LMA File off Algn 0 .initcall0.init 00000020 0000000000000000 0000000000000000 00000040 2**3 CONTENTS, ALLOC, LOAD, RELOC, DATA 1 .initcall1.init 000001d0 0000000000000000 0000000000000000 00000060 2**3 CONTENTS, ALLOC, LOAD, RELOC, DATA 2 .initcall2.init 00000138 0000000000000000 0000000000000000 00000230 2**3 CONTENTS, ALLOC, LOAD, RELOC, DATA 3 .initcall2s.init 00000008 0000000000000000 0000000000000000 00000368 2**3 CONTENTS, ALLOC, LOAD, RELOC, DATA 4 .initcall3.init 000000b0 0000000000000000 0000000000000000 00000370 2**3 CONTENTS, ALLOC, LOAD, RELOC, DATA 5 .initcall3s.init 00000008 0000000000000000 0000000000000000 00000420 2**3 CONTENTS, ALLOC, LOAD, RELOC, DATA 6 .initcall4.init 000004f0 0000000000000000 0000000000000000 00000428 2**3 CONTENTS, ALLOC, LOAD, RELOC, DATA 7 .initcall4s.init 00000008 0000000000000000 0000000000000000 00000918 2**3 CONTENTS, ALLOC, LOAD, RELOC, DATA 8 .initcall5.init 00000168 0000000000000000 0000000000000000 00000920 2**3 CONTENTS, ALLOC, LOAD, RELOC, DATA 9 .initcall5s.init 00000008 0000000000000000 0000000000000000 00000a88 2**3 CONTENTS, ALLOC, LOAD, RELOC, DATA 10 .initcall6.init 00001140 0000000000000000 0000000000000000 00000a90 2**3 CONTENTS, ALLOC, LOAD, RELOC, DATA 11 .initcall7.init 00000140 0000000000000000 0000000000000000 00001bd0 2**3 CONTENTS, ALLOC, LOAD, RELOC, DATA 12 .initcall7s.init 00000028 0000000000000000 0000000000000000 00001d10 2**3 CONTENTS, ALLOC, LOAD, RELOC, DATA 13 .con_initcall.init 00000008 0000000000000000 0000000000000000 00001d38 2**3 CONTENTS, ALLOC, LOAD, RELOC, DATA 14 .initcallearly.init 000000b8 0000000000000000 0000000000000000 00001d40 2**3 CONTENTS, ALLOC, LOAD, RELOC, DATA 15 .initcallrootfs.init 00000008 0000000000000000 0000000000000000 00001df8 2**3 CONTENTS, ALLOC, LOAD, RELOC, DATA","tags":["kernel"],"categories":["kernel"]},{"title":"内核调试","path":"/posts/内核调试.html","content":"echo 7 4 1 7 &gt; &#x2F;proc&#x2F;kernel&#x2F;printk","tags":["kernel"],"categories":["kernel"]},{"title":"使用proc和sysfs文件系统","path":"/posts/使用proc和sysfs文件系统.html","content":"proc目录详解：https://blog.csdn.net/qq_39974998/article/details/130536491 一、DEVICE_ATTR在调试驱动的时候我们一般会对于驱动中某一个属性或者变量进行操作，或者是控制gpio口，这个时候我们可以在驱动中创建对应的属性，从而在应用程序或者控制台对驱动的属性进行设置,sysfs可以通过sysfs_create_files和sysfs_create_group()来创建，其中使用DEVICE_ATTR来创建属性文件 这个宏定义在kernel&#x2F;include&#x2F;linux&#x2F;device.h中，函数定义为： 123456789#define DEVICE_ATTR(_name, _mode, _show, _store) \\ struct device_attribute dev_attr_##_name = __ATTR(_name, _mode, _show, _store)#define __ATTR(_name, _mode, _show, _store) &#123; \\ .attr = &#123;.name = __stringify(_name), \\ .mode = VERIFY_OCTAL_PERMISSIONS(_mode) &#125;, \\ .show\t= _show, \\ .store\t= _store, \\&#125; mode为文件的权限，定义在kernel&#x2F;include&#x2F;uapi&#x2F;linux&#x2F;stat.h 1234567891011121314#define S_IRWXU 00700 //用户可读写和执行#define S_IRUSR 00400//用户可读#define S_IWUSR 00200//用户可写#define S_IXUSR 00100//用户可执行 #define S_IRWXG 00070//用户组可读写和执行#define S_IRGRP 00040//用户组可读#define S_IWGRP 00020//用户组可写#define S_IXGRP 00010//用户组可执行 #define S_IRWXO 00007//其他可读写和执行#define S_IROTH 00004//其他可读#define S_IWOTH 00002//其他可写#define S_IXOTH 00001//其他可执行 二、device_attribute12345678/* interface for exporting device attributes */struct device_attribute &#123; struct attribute attr; ssize_t (*show)(struct device *dev, struct device_attribute *attr, char *buf); ssize_t (*store)(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);&#125;; 三、创建sysfs文件法1：sysfs_create_files123456789101112131415161718192021222324static ssize_t led_store(struct device *dev,struct device_attribute *attr, const char *buf, size_t len)&#123; printk(&quot;led_store() &quot;); return len;//必须返回传入的长度&#125; //下面的show和store只是简单举例static ssize_t led_show(struct device *dev, struct device_attribute*attr, char *buf)&#123; printk(&quot;led_show() &quot;); returnpr_info(&quot;store &quot;); &#125;//用DEVICE_ATTR宏创建属性led_sysfs文件，如果show()或是store()没有功能，就以NULL代替static DEVICE_ATTR(led_sysfs, S_IWUSR, led_show,led_store);//最后一项必须以NUll结尾static const struct attribute *atk_imx6ul_led_sysfs_attrs[] = &#123; &amp;dev_attr_led_sysfs.attr, NULL,&#125;;sysfs_create_files(&amp;led_device.device-&gt;kobj,atk_imx6ul_led_sysfs_attrs);sysfs_remove_file(&amp;led_device.device-&gt;kobj, atk_imx6ul_led_sysfs_attrs);//驱动退出时释放结点 其中kobj的定义为 1234kobject在设备结构体中的描述：struct platform_device —&gt;struct device dev —&gt;struct kobject kobj 法2(推荐)：sysfs_create_group()使用：将上面的attribute结构体再进行封装 123456789101112131415161718192021222324252627static ssize_t led_store(struct device *dev,struct device_attribute *attr, const char *buf, size_t len)&#123; printk(&quot;led_store() &quot;); return len;//必须返回传入的长度&#125; //下面的show和store只是简单举例static ssize_t led_show(struct device *dev, struct device_attribute*attr, char *buf)&#123; printk(&quot;led_show() &quot;); returnpr_info(&quot;store &quot;); &#125;//用DEVICE_ATTR宏创建属性led_sysfs文件，如果show()或是store()没有功能，就以NULL代替static DEVICE_ATTR(led_sysfs, S_IWUSR, led_show,led_store);//最后一项必须以NUll结尾static struct attribute *atk_imx6ul_led_sysfs_attrs[] = &#123; &amp;dev_attr_led_sysfs.attr, NULL,&#125;;static const struct attribute_group dev_attr_grp = &#123; .attrs = atk_imx6ul_led_sysfs_attrs,&#125;;sysfs_create_group(&amp;led_device.device.kobj, &amp;dev_attr_grp) //创建接口sysfs_remove_group(&amp;client-&gt;dev.kobj, &amp;dev_attr_group); //接口移除，在调用remove函数时调用 四、验证直接在终端下通过find命令查找结点，这里只是一个示例，并不是上面举的例子 实验echo命令调用store函数 这里cat没有写出，实际上直接将上述的echo 1或者echo 0 写成cat就okay了 五、device_create_file可以在创建驱动时，在创建出来的设备目录下&#x2F;sys&#x2F;class&#x2F;xxx&#x2F;xxx，新建sysfs文件 12345678910111213/** \\* device_create_file - create sysfs attribute file for device. \\* @dev: device. \\* @attr: device attribute descriptor. */int device_create_file(struct device *dev, const struct device_attribute *attr)&#123; int error = 0; if (dev) error = sysfs_create_file(&amp;dev-&gt;kobj, &amp;attr-&gt;attr); return erro&#125;","tags":["kernel"],"categories":["kernel"]},{"title":"内核定时器&hrtime高精度定时器","path":"/posts/内核定时器-hrtime高精度定时器.html","content":"一、定时器初始化void hrtimer_init(struct hrtimer *timer, clockid_t clock_id, enum hrtimer_mode mode)； 12345678910参数timer是hrtimer指针，参数clock_id有如下常用几种选项： CLOCK_REALTIME //实时时间，如果系统时间变了，定时器也会变 CLOCK_MONOTONIC //递增时间，不受系统影响参数mode有如下几种选项： HRTIMER_MODE_ABS = 0x0, /* 绝对模式 */HRTIMER_MODE_REL = 0x1, /* 相对模式 */HRTIMER_MODE_PINNED = 0x02, /* 和CPU绑定 */HRTIMER_MODE_ABS_PINNED = 0x02, /* 第一种和第三种的结合 */HRTIMER_MODE_REL_PINNED = 0x03, /* 第二种和第三种的结合 */ 二、启动定时器hrtimer_start(struct hrtimer *timer, ktime_t tim, const enum hrtimer_mode mode)； 123参数timer是hrtimer指针参数tim是时间，可以使用ktime_set()函数设置时间，参数mode和初始化的mode参数一致 三、设置超时时间1234567/* * 单位为秒和纳秒组合 */ktime_t ktime_set(const long secs, const unsigned long nsecs)； /* 设置超时时间，当定时器超时后可以用该函数设置下一次超时时间 */hrtimer_forward_now(struct hrtimer *timer, ktime_t interval) 四、设置回调函数12struct hrtimer timer;timer.function = hr_callback; 五、关闭定时器int hrtimer_cancel(struct hrtimer *timer)； 使用例子：hrtimer.c 12345678910111213141516171819202122232425262728293031323334353637#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/hrtimer.h&gt;#include &lt;linux/jiffies.h&gt; //定义一个hrtimerstatic struct hrtimer timer;ktime_t kt; //定时器回调函数static enum hrtimer_restart hrtimer_hander(struct hrtimer *timer)&#123; printk(&quot;I am in hrtimer hander\\r &quot;); hrtimer_forward(timer,timer-&gt;base-&gt;get_time(),kt);//hrtimer_forward(timer, now, tick_period); return HRTIMER_RESTART; //重启定时器&#125; static int __init test_init(void)&#123; printk(&quot;---------%s-----------\\r &quot;,__func__); kt = ktime_set(0,1000000);// 0s 1000000ns = 1ms 定时 hrtimer_init(&amp;timer,CLOCK_MONOTONIC,HRTIMER_MODE_REL); hrtimer_start(&amp;timer,kt,HRTIMER_MODE_REL); timer.function = hrtimer_hander; //此处设置了定时器到时间后的回调函数 return 0;&#125; static void __exit test_exit(void)&#123; hrtimer_cancel(&amp;timer); printk(&quot;------------test over---------------\\r &quot;);&#125; module_init(test_init);module_exit(test_exit);MODULE_LICENSE(&quot;GPL&quot;);","tags":["kernel"],"categories":["kernel"]},{"title":"系统调用流程","path":"/posts/系统调用流程.html","content":"用户态代码通过系统调用可以进入内核态，通过系统调用进入内核态，同时会切换CPU运行模式，保证了用户空间和内核空间不影响。 程序可以请求操作系统提供服务，‌如设备IO操作、‌进程间通信等。‌系统调用运行在内核空间，‌需要更高的执行权限，‌而普通的库函数调用则运行在用户态。‌ Linux系统调用的实现机制涉及多个层面，‌包括用户空间和内核空间的划分、‌系统调用号、‌中断处理、‌以及内核函数的具体实现等。‌在x86架构上，‌系统调用通常通过int 80h指令实现，‌利用系统调用号来区分不同的入口函数。‌在Intel CPU中，‌这个指令由中断0x80实现，‌而在ARM架构中，‌则是通过SWI指令实现。‌ 系统调用的基本流程包括：‌ 用户空间的程序通过库函数或者直接的系统调用请求服务。‌ 这些请求通过软件中断（‌在x86上是int $0x80，‌在ARM上是SWI指令）‌陷入内核空间。‌ 内核接收到请求后，‌根据系统调用号查找系统调用表（‌sys_call_table）‌，‌找到对应的内核函数入口地址。‌ 执行内核函数，‌完成请求的服务后，‌返回结果到用户空间。‌ 系统调用的优点包括：‌ 提供了一种标准化的接口，‌使得用户空间的程序可以以一致的方式请求操作系统服务。‌ 由于系统调用在内核空间执行，‌因此可以访问硬件设备等低级资源，‌提供了对硬件的直接控制。‌ 通过内核的权限检查，‌提高了系统的安全性。‌ 总的来说，‌Linux系统调用是操作系统内核与用户空间程序交互的重要机制，‌它允许用户空间的程序请求操作系统提供各种服务，‌如文件操作、‌进程管理、‌网络通信等，‌从而实现了操作系统的基本功能‌","tags":["kernel"],"categories":["kernel"]},{"title":"互斥锁、信号量、原子操作、自旋锁","path":"/posts/互斥锁、信号量、原子操作、自旋锁.html","content":"linux并发产生的原因（1）多线程并发访问，（2）抢占式并发访问，进程调度可以在任意时刻抢占正在运行的线程，从而运行其他的线程（3）终端程序并发访问（4）SMP(多核)间并发访问 并发访问的后果就是竞争，一般像全局变量，设备结构体这些肯定是要保护的，至于其他的数据就要根据实际的驱动程序而定了。 一、原子操作（1）原子操作的原因 对于c语言来说，a&#x3D;3，编译为汇编语言时可能被翻译成如下汇编（仅作为理解） 123ldr r0, =0X30000000 /* 变量 a 地址 */ldr r1, = 3 /* 要写入的值 */str r1, [r0] /* 将 3 写入到 a 变量中 */ 当并发出现时可能出现这种情况： (2)原子操作api 为避免上述情况，Linux 内核定义了叫做 atomic_t 的结构体来完成整形数据的原子操作，在使用中用原子变量来代替整形变量，此结构体定义在 include&#x2F;linux&#x2F;types.h 文件中， 1234567 typedef struct &#123; int counter; &#125; atomic_t; typedef struct &#123; long long counter;&#125; atomic64_t;//64操作系统 声明变量可以这样，atomic_t a;linux提供了多个可以对原子变量进行操作的函数， 二、自旋锁原子操作只能对整形变量或者位进行保护，但是，在实际的使用环境中怎么可能只有整形变量或位这么简单的临界区。举个最简单的例子，设备结构体变量就不是整型变量，我们对于结构体中成员变量的操作也要保证原子性，在线程 A 对结构体变量使用期间，应该禁止其他的线程来访问此结构体变量，这些工作原子操作都不能胜任，需要锁机制，在 Linux内核中就是自旋锁。 当一个线程要访问某个共享资源的时候首先要先获取相应的锁，锁只能被一个线程持有，只要此线程不释放持有的锁，那么其他的线程就不能获取此锁。对于自旋锁而言，如果自旋锁正在被线程 A 持有，线程 B 想要获取自旋锁，那么线程 B 就会处于忙循环-旋转-等待状态，线程 B 不会进入休眠状态或者说去做其他的处理，而是会一直傻傻的在那里“转圈圈”的等待锁可用。 从这里我们可以看到自旋锁的一个缺点：那就等待自旋锁的线程会一直处于自旋状态，这样会浪费处理器时间，降低系统性能，所以自旋锁的持有时间不能太长。所以自旋锁适用于短时期的轻量级加锁。 12345678910111213typedef struct spinlock &#123; union &#123; struct raw_spinlock rlock; #ifdef CONFIG_DEBUG_LOCK_ALLOC# define LOCK_PADSIZE (offsetof(struct raw_spinlock, dep_map)) struct &#123; u8 __padding[LOCK_PADSIZE]; struct lockdep_map dep_map; &#125;;#endif &#125;;&#125; spinlock_t; 自旋锁接口函数 自旋锁保护的临界区一定不能调用任何能够引起睡眠和阻塞的API 函数，否则的话会可能会导致死锁现象的发生，经典死锁的发生例子： 线程a在持有锁期间进入了休眠，被调度出去，此时线程b想要获取锁，但是锁被线程a持有，并且内核抢占被禁止了，线程b无法调度出去一直等待锁被释放，而线程a此时也无法再次被调度运行，死锁就发生了。 还有就是中断里使用锁的时候也一定注意死锁的发生，例如 线程 A 先运行，并且获取到了 lock 这个锁，当线程 A 运行 functionA 函数的时候中断发生了，中断抢走了 CPU 使用权。右边的中断服务函数也要获取 lock 这个锁，但是这个锁被线程 A 占有着，中断就会一直自旋，等待锁有效。 最好的解决方法就是获取锁之前关闭本地中断 12345678910111213141516DEFINE_SPINLOCK(lock) /* 定义并初始化一个锁 */ /* 线程 A */ void functionA ()&#123; unsigned long flags; /* 中断状态 */ spin_lock_irqsave(&amp;lock, flags) /* 是在这里禁止本地中断，并获取锁 */ /* 临界区 */ spin_unlock_irqrestore(&amp;lock, flags) /* 释放锁 */ &#125; /* 中断服务函数 */ void irq() &#123; spin_lock(&amp;lock) /* 获取锁 */ /* 临界区 */ spin_unlock(&amp;lock) /* 释放锁 */ &#125; 自旋锁的使用注意事项； （1）因为在等待自旋锁的时候处于“自旋”状态，因此锁的持有时间不能太长，一定要短，否则的话会降低系统性能。如果临界区比较大，运行时间比较长的话要选择其他的并发处理方式，比如信号量和互斥体。 （2）自旋锁保护的临界区内不能调用任何可能导致线程休眠的 API 函数，否则的话可能导致死锁. （3）不能递归申请自旋锁，因为一旦通过递归的方式申请一个你正在持有的锁，那么你就必须“自旋” 三、信号量相比较自旋锁，信号量可以使线程进入休眠状态，比如 A 与 B、C 合租了一套房子，这个房子只有一个厕所，一次只能一个人使用。某一天早上 A 去上厕所了，过了一会 B 也想用厕所，因为 A 在厕所里面，所以 B 只能等到 A 用来了才能进去。B 要么就一直在厕所门口等着，等 A 出来，这个时候就相当于自旋锁。B 也可以告诉 A，让 A 出来以后通知他一下，然后 B 继续回房间睡觉，这个时候相当于信号量。使用信号量会提高处理器的使用效率，但是，信号量的开销要比自旋锁大，因为信号量使线程进入休眠状态以后会切换线程，切换线程就会有开销。 信号量的特点： （1）因为信号量可以使等待资源线程进入休眠状态，因此适用于那些占用资源比较久的场合。（2）信号量不能用于中断中，因为信号量会引起休眠，中断不能休眠。（3）如果共享资源的持有时间比较短，那就不适合使用信号量了，因为频繁的休眠、切换线程引起的开销要远大于信号量带来的那点优势。 信号量一般有一个信号量值，可通过信号量值控制方位共享资源的访问数量。例如一个房间有10吧钥匙，相当于信号量值为10，如果想要进入房间，那就需要先获取一把钥匙，信号量值减1，直到10把钥匙都被拿走，信号量为0，此时就不允许人进入房间了，如果有人出来，那么就可以在允许一个人进入。 12345struct semaphore &#123; raw_spinlock_t lock; unsigned int count; struct list_head wait_list;&#125;; 信号量的 API 函数： 12345struct semaphore sem; /* 定义信号量 */sema_init(&amp;sem, 1)； /* 初始化信号量 */down(&amp;sem); /* 申请信号量 *//* 临界区 */up(&amp;sem); /* 释放信号量 */ 四、互斥体将信号量的值设置为 1 就可以使用信号量进行互斥访问，但是互斥体有专门的结构体， 12345struct mutex &#123; /* 1: unlocked, 0: locked, negative: locked, possible waiters */ atomic_t count; spinlock_t wait_lock;&#125;; 特点：（1）mutex 可以导致休眠，因此不能在中断中使用 mutex，中断中只能使用自旋锁。（2）和信号量一样，mutex 保护的临界区可以调用引起阻塞的 API 函数。（3）因为一次只有一个线程可以持有 mutex，因此，必须由 mutex 的持有者释放 mutex。并且 mutex 不能递归上锁和解锁. 互斥体的接口函数： 123456struct mutex lock; /* 定义一个互斥体 */mutex_init(&amp;lock); /* 初始化互斥体 */mutex_lock(&amp;lock); /* 上锁 *//* 临界区 */mutex_unlock(&amp;lock); /* 解锁 */ 五、RCURCU(Read-Copy Update)，是 Linux 中比较重要的一种同步机制。顾名思义就是“读，拷贝更新”，再直白点是“随意读，但更新数据的时候，需要先复制一份副本，在副本上完成修改，再一次性地替换旧数据”。这是 Linux 内核实现的一种针对“读多写少”的共享数据的同步机制。 适用的场景：我们前面说过，每种锁都有自己的适用的场景：spin lock不区分reader和writer，对于那些读写强度不对称的是不适合的，RW spin lcok和seq lock解决了这个问题，不过seq lock倾向writer，而RW spin lock更照顾reader。看起来一切都已经很完美了，但是，随着计算机硬件技术的发展，CPU的运算速度越来越快，相比之下，存储器件的速度发展较为滞后。在这种背景下，获取基于counter（需要访问存储器件）的锁（例如spin lock，rwlock）的机制开销比较大。而且，目前的趋势是：CPU和存储器件之间的速度差别在逐渐扩大。因此，那些基于一个multi-processor之间的共享的counter的锁机制已经不能满足性能的需求，在这种情况下，RCU机制应运而生（当然，更准确的说RCU一种内核同步机制，但不是一种lock，本质上它是lock-free的），它克服了其他锁机制的缺点，但是，甘蔗没有两头甜，RCU的使用场景比较受限，主要适用于下面的场景： （1）RCU只能保护动态分配的数据结构，并且必须是通过指针访问该数据结构 （2）受RCU保护的临界区内不能sleep（SRCU不是本文的内容） （3）读写不对称，对writer的性能没有特别要求，但是reader性能要求极高。 （4）reader端对新旧数据不敏感。 常用函数为： 12rcu_read_lock();rcu_read_unlock();","tags":["kernel"],"categories":["kernel"]},{"title":"DTS设备树","path":"/posts/DTS设备树.html","content":"设备树(Device Tree)，将这个词分开就是“设备”和“树”，描述设备树的文件叫做 DTS(Device Tree Source)，这个 DTS 文件采用树形结构描述板级设备，也就是开发板上的设备信息，比如 CPU 数量、 内存基地址、IIC 接口上接了哪些设备、SPI 接口上接了哪些设备等等 树的主干就是系统总线，IIC 控制器、GPIO 控制器、SPI 控制器等都是接到系统主线上的分支。IIC 控制器有分为 IIC1 和 IIC2 两种，其中 IIC1 上接了 FT5206 和 AT24C02 这两个 IIC 设备，IIC2 上只接了 MPU6050 这个设备。DTS 文件的主要功能就是按照图所示的结构来描述板子上的设备信息，DTS 文件描述设备信息是有相应的语法规则要求的，稍后我们会详细的讲解 DTS 语法规则。 设备树由一系列的节点和属性组成，节点可包含子节点。在设备树中，可描述的信息包括： CPU数量和类型 内存基地址和大小 总线和桥 外设连接 中断控制器和中断使用情况 GPIO控制器和GPIO使用情况 时钟控制器和时钟使用情况 bootload 会将这些信息传递给内核，内核开始识别这些树，并解析成 Linux 内核中 platform_device, i2c_client, spi_device等设备，而这些设备使用的内存资源，中断等信息也传递给内核。内核会将这些资源绑定给相应的设备。 一、设备树例子设备树相关的包含 3 部分：DTS、DTC、DTB DTS 是设备树源码文件， DTB 是将 DTS 编译以后得到的二进制文件。那么将 .dts 编译为 .dtbn 需要什么工具呢？需要用到 DTC 工具 dts的一个例子如下：比如 imx6ull.dtsi 就是描述 I.MX6ULL 这颗 SOC 内部外设情况信息。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;dt-bindings/gpio/gpio.h&gt;#include &lt;dt-bindings/interrupt-controller/arm-gic.h&gt;#include &quot;imx6ull-pinfunc.h&quot;#include &quot;imx6ull-pinfunc-snvs.h&quot;#include &quot;skeleton.dtsi&quot; / &#123; aliases &#123; can0 = &amp;flexcan1; ... &#125;; cpus &#123; #address-cells = &lt;1&gt;; #size-cells = &lt;0&gt;; cpu0: cpu@0 &#123; compatible = &quot;arm,cortex-a7&quot;; device_type = &quot;cpu&quot;; reg = &lt;0&gt;; clock-latency = &lt;61036&gt;; /* two CLK32 periods */ operating-points = &lt; /* kHz\tuV */ 996000\t1275000 792000\t1225000 528000\t1175000 396000\t1025000 198000\t950000 &gt;; /* kHz\tuV */ 996000\t1275000 792000\t1225000 528000\t1175000 396000\t1025000 ... &#125;; intc: interrupt-controller@00a01000 &#123; compatible = &quot;arm,cortex-a7-gic&quot;; #interrupt-cells = &lt;3&gt;; interrupt-controller; reg = &lt;0x00a01000 0x1000&gt;, &lt;0x00a02000 0x100&gt;; &#125;; ... 文件描述了 CPU arm,cortex-a7 ，支持 996MHz、 792MHz等频率， 时钟一些信息。 “&#x2F;”是根节点，每个设备树文件只有一个根节点 1node-name@unit-address 其中 “node-name” 是节点名字，为 ASCII 字符串，节点名字应该能够清晰的描述出节点的功能，比如 “uart1” 就表示这个节点是 UART1 外设。“unit-address” 一般表示设备的地址或寄存器首地址，如果某个节点没有地址或者寄存器的话 “unit-address” 可以不要，比如 “cpu@0”、“interrupt-controller@00a01000”。 1label: node-name@unit-address 引入 label 的目的就是为了方便访问节点，可以直接通过 &amp;label 来访问这个节点，比如通过&amp;cpu0 就可以访问 “cpu@0” 这个节点。很明显通过 &amp;intc 来访问 “interrupt-controller@00a01000” 这个节点要方便很多！ 每个节点都有不同属性，不同的属性又有不同的内容，属性都是键值对，值可以为空或任意的字节流。设备树源码中常用的几种数据形式如下所示： 1、字符串 1compatible = &quot;fairchild,74hc595&quot;; 2、32 位无符号整数 1reg = &lt;0 0x123456 100&gt;; 3、字符串列表 1compatible = &quot;fsl,imx6ul-pxp-v4l2&quot;, &quot;fsl,imx6sx-pxp-v4l2&quot;, &quot;fsl,imx6sl-pxp-v4l2&quot;; 二、设备树详解(1)、标准属性1、compatible 属性 compatible 属性也叫做“兼容性”属性，这是非常重要的一个属性！ compatible 属性的值是一个字符串列表， compatible 属性用于将设备和驱动绑定起来。字符串列表用于选择设备所要使用的驱动程序，compatible 属性的值格式如下所示： 1&quot;manufacturer,model&quot; 其中 manufacturer 表示厂商，model 一般是模块对应的驱动名字。比如 imx6ull-alientek-emmc.dts 中 sound 节点是 I.MX6U-ALPHA 开发板的音频设备节点，I.MX6U-ALPHA 开发板上的音频芯片采用的欧胜(WOLFSON)出品的 WM8960，sound 节点的 compatible 属性值如下： 1compatible = &quot;fsl,imx6ul-evk-wm8960&quot;,&quot;fsl,imx-audio-wm8960&quot;; 其中 “fsl” 表示厂商是飞思卡尔，“imx6ul-evk-wm8960” 和 “imx-audio-wm8960” 表示驱动模块名字。设备首先使用第一个兼容值在 Linux 内核里面查找，如果没有找到的话就使用第二个兼容值查。 2、 model 属性 model 属性值也是一个字符串，一般 model 属性描述设备模块信息，比如名字什么的，比如： 1model = &quot;wm8960-audio&quot;; 3、status 属性 status 属性看名字就知道是和设备状态有关的，status 属性值也是字符串，字符串是设备的状态信息，可选的状态如下表所示： 4、★#address-cells 和#size-cells 属性 #address-cells# 属性值决定了子节点 reg 属性中地址信息所占用的字长(32 位)#size-cells# 属性值决定了子节点 reg 属性中长度信息所占的字长(32 位)#address-cells# 和 #size-cells# 表明了子节点应该如何编写 reg 属性值，一般 reg 属性都是和地址有关的内容，和地址相关的信息有两种：起始地址和地址长度， reg 属性的格式一为： reg &#x3D; &lt;address1 length1 address2 length2 address3 length3……&gt; 每个 “address length” 组合表示一个地址范围，其中 address 是起始地址， length 是地址长度.#address-cells# 表明 address 这个数据所占用的字长， #size-cells# 表明 length 这个数据所占用的字长 12345678910aips3: aips-bus@02200000 &#123; compatible = &quot;fsl,aips-bus&quot;, &quot;simple-bus&quot;; #address-cells = &lt;1&gt;; #size-cells = &lt;1&gt;; dcp: dcp@02280000 &#123; compatible = &quot;fsl,imx6sl-dcp&quot;; reg = &lt;0x02280000 0x4000&gt;; &#125;;&#125;; 说明 aips3: aips-bus@02200000 节点起始地址长度所占用的字长为 1，地址长度所占用的字长也为 1子节点 dcp: dcp@02280000 的 reg 属性值为&lt;0x02280000 0x4000&gt;相当于设置了起始地址为 0x02280000，地址长度为 0x40000，但是 dcp的地址长度(范围)并没有 0x4000 这么多 5、 ★reg 属性 reg 属性一般用于描述设备地址空间资源信息，一般都是某个外设的寄存器地址范围信息,一般是(address， length)组成，详情如上所述！ 6、ranges 属性 ranges 属性值可以为空或者按照 (child-bus-address,parent-bus-address,length) 格式编写的数字矩阵， ranges 是一个地址映射&#x2F;转换表， ranges 属性每个项目由子地址、父地址和地址空间长度这三部分组成： child-bus-address：子总线地址空间的物理地址，由父节点的 #address-cells# 确定此物理地址所占用的字长。parent-bus-address：父总线地址空间的物理地址，同样由父节点的 #address-cells# 确定此物理地址所占用的字长。length：子地址空间的长度，由父节点的 #size-cells# 确定此地址长度所占用的字长。 如果 ranges 属性值为空值，说明子地址空间和父地址空间完全相同，不需要进行地址转换，例程如下： 123456soc &#123; #address-cells = &lt;1&gt;; #size-cells = &lt;1&gt;; compatible = &quot;simple-bus&quot;; interrupt-parent = &lt;&amp;gpc&gt;; ranges;//为空 ranges 属性不为空的示例代码如下所示： 123456789101112131415soc &#123; compatible = &quot;simple-bus&quot;; #address-cells = &lt;1&gt;; #size-cells = &lt;1&gt;; ranges = &lt;0x0 0xe0000000 0x00100000&gt;; serial &#123; device_type = &quot;serial&quot;; compatible = &quot;ns16550&quot;; reg = &lt;0x4600 0x100&gt;; clock-frequency = &lt;0&gt;; interrupts = &lt;0xA 0x8&gt;; interrupt-parent = &lt;&amp;ipic&gt;; &#125;;&#125;; 节点 soc 定义的 ranges 属性，值为 &lt;0x0 0xe0000000 0x00100000&gt;，此属性值指定了一个 1024KB(0x00100000)的地址范围，子地址空间的物理起始地址为 0x0，父地址空间的物理起始地址为 0xe0000000。 serial 是串口设备节点，reg 属性定义了 serial 设备寄存器的起始地址为 0x4600，寄存器长度为 0x100。经过地址转换，serial 设备可以从 0xe0004600 开始进行读写操作，0xe0004600&#x3D;0x4600+0xe0000000。 三、向节点追加或修改内容imx6ull.dtsi 有以下内容，表示 I2C 节点。不同的 I2C 设备有不通的详细属性，采用追加节点方法不会对共有信息带来污染。 123456789i2c1: i2c@021a0000 &#123; #address-cells = &lt;1&gt;; #size-cells = &lt;0&gt;; compatible = &quot;fsl,imx6ul-i2c&quot;, &quot;fsl,imx21-i2c&quot;; reg = &lt;0x021a0000 0x4000&gt;; interrupts = &lt;GIC_SPI 36 IRQ_TYPE_LEVEL_HIGH&gt;; clocks = &lt;&amp;clks IMX6UL_CLK_I2C1&gt;; status = &quot;disabled&quot;;&#125;; 现在要在 i2c1 节点下创建一个子节点，这个子节点就是 fxls8471，最简单的方法就是在 i2c1 下直接添加一个名为 fxls8471 的子节点，如下所示： 12345678910111213&amp;i2c1 &#123; clock-frequency = &lt;100000&gt;; pinctrl-names = &quot;default&quot;; pinctrl-0 = &lt;&amp;pinctrl_i2c1&gt;; status = &quot;okay&quot;; fxls8471@1e &#123; compatible = &quot;fsl,fxls8471&quot;; reg = &lt;0x1e&gt;; position = &lt;0&gt;; interrupt-parent = &lt;&amp;gpio5&gt;; interrupts = &lt;0 8&gt;;&#125;; 子节点可以修改增加一些属性；比如子节点中 clock-frequency 新增加的属性。status 状态由disabled变成 okay 四、设备树在目录中的体现运行 cd &#x2F;proc&#x2F;device-tree 后，ls -a 查询当前目录下的文本情况 1、在当前目录下执行 cat model model 的内容是 “Freescale i.MX6 ULL 14x14 EVK Board”compatible 的内容为 “fsl,imx6ull-14x14-evkfsl,imx6ull” 打开文件 imx6ull-alientek-emmc.dts 查看一下，这正是根节点 “&#x2F;” 的 model 和 compatible 属性值 2、soc子节点 3、aliases 子节点 与imx6ull.dtsi中的 aliases一致 4、chosen 子节点 chosen 并不是一个真实的设备， chosen 节点主要是为了 uboot 向 Linux 内核传递数据，重点是 bootargs 参数，一般.dts 文件中 chosen 节点通常为空或者内容很少， imx6ull-alientekemmc.dts 中 chosen 节点内容如下所示： 123chosen &#123; stdout-path = &amp;uart1;&#125; chosen 节点仅仅设置了属性 “stdout-path”，表示标准输出使用 uart1。 12root@ATK-IMX6U:/proc/device-tree/chosen# lsbootargs name stdout-path 我们可以发现 chosen 内存在 boot 的启动参数 bootargs！ cat 查看确实是启动信息1，我们并没有在设备树中设置 chosen 节点的 bootargs 属性，那么 bootargs这个属性是怎么产生的如何关联起来的呢？2，为什么和 uboot 中的参数不一致？ chosen 节点的 bootargs 属性不是我们在设备树里面设置的，那么只有一种可能，那就是 uboot 自己在 chosen 节点里面添加了 bootargs 属性，并且设置 bootargs 属性的值为 bootargs环境变量的值。 uboot 源码中搜索 “chosen”，在文件 common&#x2F;fdt_support.c 中 12345678910int fdt_chosen(void *fdt)&#123; //寻找chosen节点 nodeoffset = fdt_find_or_add_subnode(fdt, 0, &quot;chosen&quot;); if (nodeoffset &lt; 0) return nodeoffset; //读取bootargs环境 str = getenv(&quot;bootargs&quot;);&#125; 五、Linux 内核解析 DTB 文件启动内核流程函数 start_kernel 函数中最终调用了函数为 unflatten_dt_node（很多初始化操作都在start_kernel ）！ 六、设备树节点的操作函数Linux 驱动程序往往需要去读取到 Linux 内核中附带的 dts 文件，并操作设备树 DTS 的相关节点！接下来我们来学习一下，如何进行设备树节点操作！ 1、查找节点的 of 函数Linux 内核使用 device_node 结构体来描述一个节点 1、 of_find_node_by_name 函数 1234//通过节点名字查找指定的节点struct device_node *of_find_node_by_name(struct device_node *from, const char *name);//from：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。//name：要查找的节点名字 2、of_find_node_by_type 函数 12//通过device_type查找指定的节点struct device_node *of_find_node_by_type(struct device_node *from, const char *type) 3、 of_find_compatible_node 函数 1234device_type 和 compatible 这两个属性查找指定的节点struct device_node *of_find_compatible_node(struct device_node *from, const char *type, const char *compatible) 4、of_find_matching_node_and_match 函数 1234//通过 of_device_id 匹配表来查找指定的节点struct device_node *of_find_matching_node_and_match(struct device_node *from, const struct of_device_id *matches, const struct of_device_id **match) 5、of_find_node_by_path 函数 12struct device_node *of_get_parent(const struct device_node *node)//node 要查找的父节点的节点 七、查找父&#x2F;子节点的 OF 函数1、of_get_parent 函数用于获取指定节点的父节点 12struct device_node *of_get_parent(const struct device_node *node)//node 要查找的父节点的节点 2、of_get_next_child 函数 123456//用迭代的查找子节点struct device_node *of_get_next_child(const struct device_node *node, struct device_node *prev)//node：父节点。//prev：前一个子节点，也就是从哪一个子节点开始迭代的查找下一个子//节点。可以设置为NULL，表示从第一个子节点开始。//返回 找到的下一个子节点。 八、提取属性值的 OF 函数property 结构体，此结构体定义在文件 include&#x2F;linux&#x2F;of.h 中 123456789struct property &#123; char *name; /* 属性名字 */ int length; /* 属性长度 */ void *value; /* 属性值 */ struct property *next; /* 下一个属性 */ unsigned long _flags; unsigned int unique_id; struct bin_attribute attr;&#125;; 1、 of_find_property 函数 1234567property *of_find_property(const struct device_node *np, const char *name, int *lenp)//np：设备节点。//name： 属性名字。//lenp：属性值的字节数//返回找到的属性 2、 of_property_count_elems_of_size 函数用于获取属性中元素的数量，比如 reg 属性值是一个数组，那么使用此函数可以获取到这个数组的大小 1234567int of_property_count_elems_of_size(const struct device_node *np, const char *propname, int elem_size)//np：设备节点。//proname： 需要统计元素数量的属性名字。//elem_size：元素长度。//返回 得到的属性元素数量 3、 of_property_read_u32_index 函数从属性中获取指定标号的 u32 类型数据值(无符号 32 位)，比如某个属性有多个 u32 类型的值，那么就可以使用此函数来获取指定标号的数据值 1234int of_property_read_u32_index(const struct device_node *np, const char *propname, u32 index, u32 *out_value) 4、of_property_read_u8_array 函数of_property_read_u16_array 函数of_property_read_u32_array 函数of_property_read_u64_array 函数 分别是读取属性中 u8、 u16、 u32 和 u64 类型的数组数据，比如大多数的 reg 属性都是数组数据，可以使用这 4 个函数一次读取出 reg 属性中的所有数据 5、 of_property_read_string 函数 1234//用于读取属性中字符串值int of_property_read_string(struct device_node *np, const char *propname, const char **out_string) 6、 of_n_addr_cells 函数用于获取#address-cells 属性值 7、 of_n_size_cells 函数of_size_cells 函数用于获取#size-cells 属性值 8、of_iomap 函数采用设备树以后就可以直接通过 of_iomap 函数来获取内存地址所对应的虚拟地址，不需要使用 ioremap 函数了","tags":["kernel"],"categories":["kernel"]},{"title":"内核线程","path":"/posts/内核线程.html","content":"一、kthread_create &amp; kthread_run内核线程是工作在内核空间的，不属于任何一个进程，可以发生睡眠。可以用内核线程来进行一些循环的动作，比如通过循环拉高拉低gpio设置成方波输出的信号来模拟pwm信号，比如循环控制led的闪灯效果等等都可以使用到内核线程kthread_create接口函数。 内核线程的相关代码目录： 12include/linux/kthread.h kernel/kthread.c 创建并启动一个内核线程 12345678910111213141516171819202122struct task_struct *kthread_create(int (*threadfn)(void *data), void *data, const char namefmt[], ...);_/**_ _* kthread_run - create and wake a thread._ _* @threadfn: the function to run until signal_pending(current)._ _* @data: data ptr for @threadfn._ _* @namefmt: printf-style name for the thread._ _*_ _* Description: Convenient wrapper for kthread_create() followed by_ _* wake_up_process(). Returns the kthread or ERR_PTR(-ENOMEM)._ _*/_#define kthread_run(threadfn, data, namefmt, ...) \\(&#123; \\ struct task_struct *__k \\ = kthread_create(threadfn, data, namefmt, ## __VA_ARGS__); \\ if (!IS_ERR(__k)) \\ wake_up_process(__k); \\ __k; \\&#125;) 其中kthread_create()只是创建一个内核线程，但并没有启动，需要调用wake_up_process()来启动线程，所以内核又帮我们定义了一个宏kthread_run来帮我们搞定。内核线程创建成功后，会返回一个struct task_struct对象指针，方便我们的后续操作。 二、关闭一个内核线程1int kthread_stop(struct task_struct *k); 这个调用是会阻塞等待，直到内核线程k退出为止。原因为此函数内部会调用wait_for_completion(）的方法（通过等待队列来实现），阻塞等待内核线程自身的退出。 三、内核线程函数，如何判断自身需要退出1int kthread_should_stop(void); 如果该内核线程已经被设置stop标志了，则会返回1，否则返回0。 举例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;linux/module.h&gt;#include &lt;linux/kthread.h&gt;#include &lt;linux/delay.h&gt;#define ENTER() printk(KERN_DEBUG &quot;%s() Enter&quot;, __func__)#define EXIT() printk(KERN_DEBUG &quot;%s() Exit&quot;, __func__)#define ERR(fmt, args...) printk(KERN_ERR &quot;%s()-%d: &quot; fmt &quot; &quot;, __func__, __LINE__, ##args)#define DBG(fmt, args...) printk(KERN_DEBUG &quot;%s()-%d: &quot; fmt &quot; &quot;, __func__, __LINE__, ##args)static struct task_struct *test_kthread = NULL; //_定义一个_task_struct_结构体指针，赋值为_NULLstatic int kthread_test_func(void) //定义一个内核线程要执行的函数&#123; ENTER(); while (!kthread_should_stop()) &#123; DBG(&quot;kthread is running&quot;); msleep(5000); &#125; EXIT(); return 0;&#125;static __init int kthread_test_init(void)&#123; ENTER(); test_kthread = kthread_run(kthread_test_func, NULL, &quot;kthread-test&quot;); _//_创建线程_kthread-test_，并且运行 if (!test_kthread) &#123; ERR(&quot;kthread_run fail&quot;); return -ECHILD; &#125; EXIT(); return 0;&#125;static __exit void kthread_test_exit(void)&#123; ENTER(); if (test_kthread) &#123; DBG(&quot;kthread_stop&quot;); kthread_stop(test_kthread); _//_停止内核线程 test_kthread = NULL; &#125; EXIT();&#125;module_init(kthread_test_init);module_exit(kthread_test_exit);MODULE_AUTHOR(&quot;czd,214241976@qq.com&quot;);MODULE_DESCRIPTION(&quot;Device_create Driver&quot;);MODULE_LICENSE(&quot;GPL&quot;);","tags":["kernel"],"categories":["kernel"]},{"title":"中断下半部-workqueue","path":"/posts/中断下半部-workqueue.html","content":"工作队列（work queue）是中断下半部的一种实现机制，主要用于耗时任务处理，由内核线程代表进程执行。工作队列运行于进程上下文，因此允许阻塞。 运行工作队列的内核线程，称为工作者线程（worker thread），可以使用系统默认的，也可以自行创建（通常无必要理由不推荐）。 使用工作队列方式：1）初始化工作队列；2）将“工作”（work）放入“工作队列中”。这样，对应的内核线程就会取出“工作”，执行其中的函数。 工作队列缺点：多个工作挤在某个内核线程中依次序执行，前面的函数如果执行得很慢，就会影响到后面的函数。 一、内核数据结构与函数work queue有关数据结构和函数，都位于&lt;linux&#x2F;workqueue.h&gt;。 二、work_struct结构体一个work_struct实例代表一个“工作”，工作包含了用户想要要执行的任务。 work_struct结构体定义： 12345678910struct work_struct &#123; atomic_long_t data; struct list_head entry; work_func_t func; // 处理函数#ifdef CONFIG_LOCKDEP struct lockdep_map lockdep_map;#endif&#125;;typedef void (*work_func_t)(struct work_struct *work); 使用work queue时，步骤如下：1）构造一个work_struct实例，设置处理函数。2）把work_struct放入工作队列，内核线程会运行work中的函数（func）。 三、使用work queue创建work静态创建宏DECLARE_WORK用来定义一个work_struct结构体，需要指定它的处理函数。宏DECLARE_DELAYED_WORK用来定义一个delayed_work结构体，也需要指定它的处理函数。“delayed”指延时，意思是要让该“工作”运行时，可以通过该宏指定延时的时间。 12345#define DECLARE_WORK(n, f) \\ struct work_struct n = __WORK_INITIALIZER(n, f)#define DECLARE_DELAYED_WORK(n, f) \\ struct delayed_work n = __DELAYED_WORK_INITIALIZER(n, f, 0) delayed_work结构体，其实是一个work_struct和一个timer_list等成员的复合结构。 12345678struct delayed_work &#123; struct work_struct work; // 工作队列的工作 struct timer_list timer; // 超时时间 /* target workqueue and CPU -&gt;timer uses to queue -&gt;work */ struct workqueue_struct *wq; int cpu;&#125;; 动态创建宏INIT_WORK用来初始化work_struct结构体： 12#define INIT_WORK(_work, _func) \\ __INIT_WORK((_work), (_func), 0) 四、创建工作队列Linux系统中已有现成的system_wq等工作队列，使用工作队列时，通常推荐用现成的。 123456789// Linux中现成的工作队列extern struct workqueue_struct *system_wq;extern struct workqueue_struct *system_highpri_wq;extern struct workqueue_struct *system_long_wq;extern struct workqueue_struct *system_unbound_wq;extern struct workqueue_struct *system_freezable_wq;extern struct workqueue_struct *system_power_efficient_wq;extern struct workqueue_struct *system_freezable_power_efficient_wq; 如果需要自行创建，也有办法，可以使用create_workqueue或create_singlethread_workqueue。create_workqueue会在SMP系统中，针对每个CPU，都创建一个内核线程和创建的工作队列对应。create_singlethread_workqueue 只会有一个内核线程与工作队列对应。 五、销毁工作队列与创建工作队列相对的，是销毁工作队列，可以调用destroy_workqueue来执行该操作。 1void destroy_workqueue(struct workqueue_struct *wq); 六、调度执行workschedule_work调度执行一个具体的work，执行的work将会被挂入Linux提供的（默认system_wq）工作队列。 1static inline bool schedule_work(struct work_struct *work); 如果想延迟执行work，可以调用schedule_delayed_work ，其功能类似于schedule_work，不过多了一个延迟。 12static inline bool schedule_delayed_work(struct delayed_work *dwork, unsigned long delay); queue_work 跟schedule_work类似，区别在于schedule_work是在系统默认的工作队列上执行一个work，而queue_work 需要自行指定工作队列。 其实，schedule_work是利用queue_work实现的，例如系统默认的工作队列system_wq： 1234static inline bool schedule_work(struct work_struct *work)&#123; return queue_work(system_wq, work);&#125; queue_delayed_work 跟schedule_delayed_work 类似，区别在于schedule_delayed_work 是在系统默认的工作队列上执行一个work，queue_delayed_work需要自行指定工作队列。类似地，schedule_delayed_work也是依赖于queue_delayed_work实现的。 12345static inline bool schedule_delayed_work(struct delayed_work *dwork, unsigned long delay)&#123; return queue_delayed_work(system_wq, dwork, delay);&#125; 七、等待workflush_work 等待一个work执行完毕。如果该work已经被放入队列，那么本函数等它执行完毕，并且返回true；如果该work已经执行完毕才调用本函数，那么直接返回false。 1bool flush_work(struct work_struct *work); flush_delayed_work 等待一个delayed_work执行完毕。如果这个delayed_work已经被放入队列，那么本函数等它执行完毕，并且返回true；如果这个delayed_work已经执行完毕才调用本函数，那么直接返回false。 1bool flush_delayed_work(struct delayed_work *dwork); TIPS：前面提到过，delayed_work是一个复合了work_struct，timer_list等成员的结构体。 八、等待work queueflush_work是等待一个work执行完毕，而flush_workqueue是等待一个工作队列上所有work执行完毕。 1void flush_workqueue(struct workqueue_struct *wq) 九、work queue的内部机制Linux内核2.x 版本中，创建workqueue时会同步创建内核线程；Linux内核4.x 版本中，内核线程和workqueue分开创建，较为复杂。 Linux 2.x的工作队列创建过程kernel&#x2F;workqueue： 123456init_workqueueskeventd_wq = create_workqueue(&quot;events&quot;); // 创建名为&quot;events&quot;的工作队列 __create_workqueue((name), 0, 0) for_each_possible_cpu(cpu) &#123; err = create_workqueue_thread(cwq, cpu); // 创建用于工作队列的内核线程 p = kthread_create(worker_thread, cwq, fmt, wq-&gt;name, cpu); // 创建内核线程 对于每个CPU，都创建一个名为“events&#x2F;n”的内核线程，n是处理器编号，从0开始。 创建workqueue的同时，创建内核线程。 每个CPU上都有一个cpu_workqueue_struct，而每个cpu_workqueue_struct下只有1个线程用于work queue执行work。所有内核线程可以从同一个work queue取work。 Linux 4.x的工作队列创建过程12345678910111213141516init_workqueues/* initialize CPU pools */for_each_possible_cpu(cpu) &#123; for_each_cpu_worker_pool(pool, cpu) &#123; /* 对每一个CPU都创建2个worker_pool结构体，它是含有ID的 */ /* 一个worker_pool对应普通优先级的work，第2个对应高优先级的work */&#125;/* create the initial worker */for_each_online_cpu(cpu) &#123; for_each_cpu_worker_pool(pool, cpu) &#123; /* 对每一个CPU的每一个worker_pool，创建一个worker *//* 每一个worker对应一个内核线程 */ BUG_ON(!create_worker(pool)); &#125;&#125; create_worker： 1234567891011121314151617181920212223242526272829static struct worker *create_worker(struct worker_pool *pool)&#123; struct worker *worker = NULL; int id = -1; char id_buf[16]; /* ID is needed to determine kthread name */ id = ida_simple_get(&amp;pool-&gt;worker_ida, 0, 0, GFP_KERNEL); if (id &lt; 0) goto fail; worker = alloc_worker(pool-&gt;node); if (!worker) goto fail; worker-&gt;pool = pool; worker-&gt;id = id; if (pool-&gt;cpu &gt;= 0) snprintf(id_buf, sizeof(id_buf), &quot;%d:%d%s&quot;, pool-&gt;cpu, // 在哪个CPU上运行 id, // poll中第几个线程 pool-&gt;attrs-&gt;nice &lt; 0 ? &quot;H&quot; : &quot;&quot;); // H: 高优先级 else snprintf(id_buf, sizeof(id_buf), &quot;u%d:%d&quot;, pool-&gt;id, id); worker-&gt;task = kthread_create_on_node(worker_thread, worker, pool-&gt;node, &quot;kworker/%s&quot;, id_buf); // 内核线程的名字 ...&#125; 创建号内核线程（”kworker&#x2F;n:id”）后，再创建workqueue 12345init_workqueues system_wq = alloc_workqueue(&quot;events&quot;, 0, 0); __alloc_workqueue_key wq = kzalloc(sizeof(*wq) + tbl_size, GFP_KERNEL); // 分配workqueue_struct alloc_and_link_pwqs(wq) // 跟worker_poll建立联系 每个CPU对应2个woker_pool：一个普通的worker_pool，一个高优先级的worker_pool。每个线程池包含多个内核线程，用于执行同一个worker queue的work。work_pool的线程名，形如”kworker&#x2F;n:idH”，n代表CPU编号，id是子线程编号，H代表高优先级，如果普通优先级则为空。 对于CPU 0：普通worker_pool线程名，形如”kworker&#x2F;0:0”，”kworker&#x2F;0:1”，”kworker&#x2F;0:2”。:高优先级的worker_pool线程名，形如”kworker&#x2F;0:0H”，”kworker&#x2F;0:1H”，”kworker&#x2F;0:2H”。","tags":["kernel"],"categories":["kernel"]},{"title":"中断下半部-tasklet","path":"/posts/中断下半部-tasklet.html","content":"tasklet 是中断下半部的一种实现机制，主要用于小任务处理，耗时较短、不能阻塞的任务，用tasklet处理较合适。对于耗时较长，可以用work queue（工作队列）来处理。 tasklet和内核定时器timer_list都是通过软中断方式来实现的。 一、tasklet结构体中断下半部用结构体tasklet_struct来表示 12345678910#include &lt;linux/interrupt.h&gt;struct tasklet_struct&#123; struct tasklet_struct *next; unsigned long state; atomic_t count; void (*func)(unsigned long); unsigned long data;&#125;; 其中，state有2位：1）bit0：表示TASKLET_STATE_SCHED等于1，表示已经执行了tasklet_schedule，该把tasklet放入队列了。tasklet_schedule会判断该位，如果已经等于1，那么它就不会再次把tasklet放入队列。 2）bit1：表示TASKLET_STATE_RUN等于1，表示正在运行tasklet中的func函数。函数执行完毕后，内核会把该位清0。 count表示该tasklet是否使能：值0表示使能了，非0表示被禁止了。对于count非0的tasklet，func()不会被执行。 data 是传递给func()的参数。 二、初始化tasklet_strcut静态初始化：宏初始化tasklet_struct 12345#define DECLARE_TASKLET(name, func, data) \\struct tasklet_struct name = &#123; NULL, 0, ATOMIC_INIT(0), func, data &#125;;#define DECLARE_TASKLET_DISABLED(name, func, data) \\struct tasklet_struct name = &#123; NULL, 0, ATOMIC_INIT(1), func, data &#125;; 使用DECLARE_TASKLET定义的tasklet结构体，它是使能的。使用DECLARE_TASKLET_DISABLED定义的tasklet结构体，它是禁止的。使用之前要先调用tasklet_enable使能之。 动态初始化：也可用函数tasklet_init()初始化tasklet结构体：data是func的参数 12tasklet_init(struct tasklet_struct *t, void (*func)(unsigned long), unsigned long data); 三、使能&#x2F;禁止tasklettasklet_enable将count加1；tasklet_disable将count减1。 123static inline void tasklet_enable(struct tasklet_struct *t); // 使能static inline void tasklet_disable(struct tasklet_struct *t); // 禁止 四、调度tasklet将tasklet放入链表，并设置它的TASKLET_STATE_SCHED状态为1。 1static inline void tasklet_schedule(struct tasklet_struct *t); 五、kill tasklet从链表中删除tasklet。如果一个tasklet未被调度，tasklet_kill会将它的TASKLET_STATE_SCHED状态清0；如果一个tasklet已被调度，tasklet_kill会等待它执行完毕，再把它的TASKLET_STATE_SCHED状态清0。通常，在卸载驱动程序（module_exit）时，调用task_kill。 tasklet_kill_immediate 与tasklet_kill区别是，前者会立即移除tasklet，二不论tasklet是否处于TASKLET_STATE_SCHED状态。 123void tasklet_kill(struct tasklet_struct *t); // 移除taskletvoid tasklet_kill_immediate(struct tasklet_struct *t, unsigned int cpu); // 立即移除tasklet 六、tasklet使用方法先定义tasklet实例，需要使用时调用tasklet_schedule，驱动卸载前调用tasklet_kill。tasklet_schedule只是将tasklet放入内核队列，其func函数会在软中断执行过程中被调用。 七、tasklet内部实现机制前面讲过，tasklet是通过软中断实现，属于TASKLET_SOFTIRQ类型的软中断。入口函数tasklet_action。 12345678910111213141516// kernel/softirq.cvoid __init softirq_init(void)&#123; int cpu; for_each_possible_cpu(cpu) &#123; per_cpu(tasklet_vec, cpu).tail = &amp;per_cpu(tasklet_vec, cpu).head; per_cpu(tasklet_hi_vec, cpu).tail = &amp;per_cpu(tasklet_hi_vec, cpu).head; &#125; open_softirq(TASKLET_SOFTIRQ, tasklet_action); // 注册TASKLET_SOFTIRQ类型软中断(普通软中断)及其处理函数 open_softirq(HI_SOFTIRQ, tasklet_hi_action); // 高优先级软中断&#125; 在软中断的初始化（softirq_init）末尾，通过open_softirq注册TASKLET_SOFTIRQ类型的软中断（即tasklet）及其处理函数（即tasklet_action）。 驱动程序调用tasklet_schedule时，会设置tasket的state为TASKLET_STATE_SCHED，并把它放入某个链表： 1234567891011121314151617181920static inline void tasklet_schedule(struct tasklet_struct *t)&#123; // 1. 如果未设置为SCHED，则设置为SCHED并放入队列 if (!test_and_set_bit(TASKLET_STATE_SCHED, &amp;t-&gt;state)) // 设置tasklet.state为TASKLET_STATE_SCHED __tasklet_schedule(t);&#125;void __tasklet_schedule(struct tasklet_struct *t)&#123; unsigned long flags; local_irq_save(flags); // 保存中断 // 2. 放入队列 t-&gt;next = NULL; *__this_cpu_read(tasklet_vec.tail) = t; __this_cpu_write(tasklet_vec.tail, &amp;(t-&gt;next)); raise_softirq_irqoff(TASKLET_SOFTIRQ); // 唤醒中断, 会导致调用该类型软中断对应的处理函数 local_irq_restore(flags); // 恢复中断到flags状态&#125;EXPORT_SYMBOL(__tasklet_schedule); 产生硬件中断时，讹你好处理完硬件中断后，会处理软中断。对于TASKLET_SOFTIRQ软中断，会调用tasklet_action函数。 执行过程是：从队列中找到tasklet，进行状态判断后执行func函数，从队列中删除tasklet。可知：1）tasklet_schedule 调度tasklet时，其中的函数并不会立即执行，而只是把tasklet放入队列；2）调用一次tasklet_schedule，只会导致tasklet的函数被执行一次；3）如果tasklet的函数尚未执行，多次调用tasklet_schedule也是少的，只会放入队列一次。 普通软中断处理函数tasklet_action： 1234567891011121314151617181920212223242526272829303132333435363738static __latent_entropy void tasklet_action(struct softirq_action *a)&#123; struct tasklet_struct *list; local_irq_disable(); list = __this_cpu_read(tasklet_vec.head); __this_cpu_write(tasklet_vec.head, NULL); __this_cpu_write(tasklet_vec.tail, this_cpu_ptr(&amp;tasklet_vec.head)); local_irq_enable(); while (list) &#123; struct tasklet_struct *t = list; list = list-&gt;next; // 1. 从列表中去除每一项 if (tasklet_trylock(t)) &#123; if (!atomic_read(&amp;t-&gt;count)) &#123; // 2. 判断：如果不是SCHED状态，就是有BUG if (!test_and_clear_bit(TASKLET_STATE_SCHED, &amp;t-&gt;state)) BUG(); t-&gt;func(t-&gt;data); // 3. 执行tasklet的func tasklet_unlock(t); continue; &#125; tasklet_unlock(t); &#125; local_irq_disable(); // 4. 从队列中取出 t-&gt;next = NULL; *__this_cpu_read(tasklet_vec.tail) = t; __this_cpu_write(tasklet_vec.tail, &amp;(t-&gt;next)); __raise_softirq_irqoff(TASKLET_SOFTIRQ); local_irq_enable(); &#125;&#125;","tags":["kernel"],"categories":["kernel"]},{"title":"内核内存申请函数","path":"/posts/内核内存申请函数.html","content":"一、kmalloc12#include &lt;linux/slab.h&gt;static inline void *kmalloc(size_t size, gfp_t flags); size：指定要分配的块的大小,单位是字节 flags：指定分配内存时的控制方式; 该函数用于在内核空间中分配内存使用，它的返回速度快(除非被阻塞)，并且对其分配的内存不进行任何初始化(清零)操作，分配的内存区域仍然保留有他原有的内容。 kmalloc申请得到的是物理内存,位于物理内存映射区，而且在物理地址上是连续的；但是kmalloc返回的内存地址却是虚拟地址(线性地址)，返回的这个虚拟地址(线性地址)与真实的物理地址之间仅仅相差一个固定的偏移值；因此,kmalloc申请得到的物理内存块的首地址与其返回的虚拟地址之间存在着比较简单的转换关系;通过内核提供的函数virt_to_phys()可以实现该虚拟地址到真实的内核物理地址之间的转换。 kmalloc()函数用于小块内存的申请，最小可以申请的内存是32字节或64字节，最大可以申请的内存是128KB-16，其中，被减掉的16个字节用于存储页描述符结构；这些都依赖于体系架构所使用的页面大小；kmalloc申请的内存在物理地址上是连续的，这对于要进行DMA传输的设备来说，是非常重要的； kmalloc()的内存分配是基于slab机制实现的，slab机制是为分配小内存而提供的一种高效的机制；但是slab机制也不是独立的，它本身也是在页分配器的基础上来划分更细粒度的内存供调用者使用；也就是说，系统先使用页分配器分配以页为最小单位的连续物理地址，然后，kmalloc()再在这个基础上根据调用者的需要进行切分的；另外，slab机制分配的内存在物理地址和虚拟地址(线性地址&#x2F;逻辑地址)上都是连续的。 对于kmalloc()申请的内存,需要使用kfree函数来释放; 二、kzalloc函数原型 1void *kzalloc(size_t size, gfp_t flags); 1）kzalloc()函数与 kmalloc()非常相似，参数及返回值一样 2）kzalloc()基于kmalloc实际上只是额外附加了 __GFP_ZERO 标志。所以它除了申请内核内存外，还会对申请到的内存内容清零 释放函数仍然为kfree 三、vmalloc12#include &lt;linux/vmalloc.h&gt;void* vmalloc(unsigned long size) vmalloc()函数也是用于申请内存的，但是它申请的内存是位于vmalloc_start到vmalloc_end之间的虚拟内存；它申请的内存在虚拟地址(线性地址&#x2F;逻辑地址)上是连续的，但是并不要求在物理地址上连续，并且返回的地址与物理地址之间没有简单的转换关系。 vmalloc()函数适用于大块内存的申请环境中；但是它申请的内存不能直接用于DMA传输；因为DMA传输需要使用物理地址连续的内存块。 对于vmalloc()申请的内存,需要使用vfree()函数来释放。 备注:vmalloc是基于slab机制实现的。 GFP标志位kmalloc、kzalloc、kcalloc、vmalloc、get_free_pages函数在调用时都有一个gfp_t类型的控制标记flags；这个标记用于控制申请内存时的内存分配控制方式； 1#include &lt;linux/gfp.h&gt; GFP的标记有两种：带双下划线前缀的和不带双下划线前缀的 不带双下划线前缀的GFP标志： GFP_ATOMIC：用于在中断上下文和进程上下文之外的其它代码中分配内存;从不睡眠; GFP_KERNEL：内核正常分配内存;可能睡眠; GFP_USER：用于为用户空间页分配内存;可能睡眠; GFP_HIGHUSER：如同GFP_USER,但它是从高端内存中申请; GFP_NOIO和GFP_NOFS：功能如同GFP_KERNEL,但是它俩增加限制到内核能做的来满足请求；GFP_NOFS分配不允许进行任何文件系统调用，而GFP_NOIO分配根本不允许进行任何IO初始化；它俩主要用于文件系统和虚拟内存代码，那里允许一个分配睡眠，但是递归的文件系统调用会是个坏主意； 带有双下划线前缀的GFP标志: __GFP_DMA:这个标志要求分配的内存在能够进行DMA的内存区;平台依赖的; __GFP_HIGHMEM:这个标志指示分配的内存可以位于高端内存区;平台依赖的; __GFP_COLD:正常地,内存分配器尽力返回”缓冲热”的页—可能在处理器缓冲中找到的页;相反,这个标志请求一个”冷”页—在一段时间内没被使用的页;它对分配页做DMA读是很有用的,此时在处理器缓冲中出现是没用的; __GFP_NOWARN:这个标志用于分配内存时阻止内核发出警告,当一个分配请求无法满足时; __GFP_HIGH:这个标志标识了一个高优先级请求,它被允许来消耗甚至被内核保留给紧急状况的最后的内存页; __GFP_REPEAT:分配器的动作;当分配器有困难满足一个分配请求时,通过重复尝试的方式来”尽力尝试”,但是分配操作仍然有可能失败; __GFP_NOFAIL:分配器的动作;当分配器有困难满足一个分配请求时,这个标志告诉分配器不要失败,尽最大努力来满足分配请求; __GFP_NORETRY:分配器的动作;当分配器有困难满足一个分配请求时,这个标志告诉分配器立即放弃,不再做任何尝试; 通常,一个或多个带双下划线前缀的标记相或,即可得到对应的不带双下划线前缀的标记;最常用的标记就是GFP_KERNEL,它的意思就是当前的这个分配代表运行在内核空间的进程而进行的;换句话说,这意味着调用函数是代表一个进程在执行一个系统调用;使用GFP_KERNEL标记,就意味着kmalloc能够使当前进程在少内存的情况下通过睡眠来等待一个内存页;因此,一个使用GFP_KERNEL的函数必须是可重入的,且不能在原子上下文中运行;当前进程睡眠,内核采取正确的动作来定位一些空闲的内存页,或者通过刷新缓存到磁盘或者交换出去一个用户进程的内存页;如果一个内存分配动作发生在中断处理或内核定时器的上下文中时,当前进程就不能被设置为睡眠,也就不能再使用GFP_KERNEL标志了,此时应该使用GFP_ATOMIC标志来代替;正常地,内核试图保持一些空闲页以便来满足原子的分配;当使用GFP_ATOMIC标志时,kmalloc标志能够使用甚至最后一个空闲页;如果这最后一个空闲页不存在,那分配就会失败; 五、copy_to_user用户一般访问内核，需要从用户态变为内核态，然后再访问内核，这么做的目的是防止用户随意篡改内核。在编写某个外设的驱动时，我们需要实现内核中的 read 和 write 函数，此时站在内核的角度，无法直接读取用户缓冲区 或者 无法直接向用户缓冲区写入。 因此，就需要用到 copy_to_user 和 copy_from_user 函数。 copy_to_user()：完成内核空间到用户空间的复制copy_from_user()：完成用户空间到内核空间的复制 1ulong copy_from_user(void *to, const void __user *from, unsigned long n) 第一个参数 to：目标用户空间的地址 第二个参数 from: 源内核空间地址。保存了要拷贝到用户空间的内容的地址 第三个参数 n：要拷贝的字节数 返回值：成功返回 0 六、copy_form_user1ulong copy_to_user(void __user *to, const void *from, unsigned long n); 第一个参数 to：目标内核空间的地址 第二个参数 from: 源用户空间地址。保存了用户要发送的数据，或者要拷贝到内核空间的内容的地址 第三个参数 n：要拷贝的字节数 返回值：成功返回 0","tags":["kernel"],"categories":["kernel"]},{"title":"红黑树","path":"/posts/红黑树.html","content":"一、 红黑树的原理红黑树RB Tree是二叉树的一种，作为一种自平衡二叉树（一些情况下不是完全平衡的），它在最坏的情况下查询复杂度为O(logN)𝑂(𝑙𝑜𝑔𝑁)。与AVL树类似，尽管RB Tree查询效率不如AVL树（因为RB Tree左右子树高度差距最多接近两倍，而AVL树始终保持左右子树高度最多不超过1），但其插入删除效率高，适合用于大数据量且更新频繁的场景，例如内核IO调度算法。红黑树在二叉树的基础上做了如下约束： 树种全部节点要么是黑色要么是红色 树的根节点是黑色的 叶节点（指NULL节点）颜色为黑色 红色节点之间不能相邻 一个节点的左子树和右子树高度（只统计黑色节点）相同 在介绍红黑树的操作前，我们先说明以下几点惯例： &#x3D;&#x3D;所有节点在插入的时候都将是红色节点（不包括根节点，其插入时是黑色的）&#x3D;&#x3D;，这样有一个好处是可以不违反约束1，2，3和5，对于约束1，2和3是显然的，对于5，由于添加红色节点并不会影响其父节点及以上节点左右子树黑色节点数量，故不违反约束5。因此，在插入节点后，只需判断是否违反约束4。 &#x3D;&#x3D;一颗红黑树中，某一节点左右子树节点高度差不会超过2倍&#x3D;&#x3D;，考虑一种极限情况：左子树黑色节点高度为x，且最长路径中不存在红色节点，这是允许的，右子树有黑色节点高度为x，这样满足约束5，除此之外，右子树最长路径黑色几点之间都由红色节点隔开（满足约束4），故右子树总高度为2x-1，约等于2x。 二、红黑树操作在Linux内核代码中仅提供了红黑树节点链接、索引、调整、删除等基础操作，不包含特定含义的查询、插入等操作： void rb_insert_color(struct rb_node *, struct rb_root *);，检查调整一个指定节点，通常与rb_link_node搭配使用； void rb_erase(struct rb_node *, struct rb_root *);，从树中删除一个指定节点； struct rb_node *rb_next(struct rb_node *);，返回一个节点的下一个节点（顺序的）； struct rb_node *rb_prev(struct rb_node *);，返回一个节点的上一个节点（顺序的）； struct rb_node *rb_first(struct rb_root *);，返回树中的第一个节点（顺序的）； struct rb_node *rb_last(struct rb_root *);，返回树中的最后一个节点（顺序的）； void rb_replace_node(struct rb_node *victim, struct rb_node *new, struct rb_root *root);，用new替换节点victim； inline void rb_link_node(struct rb_node * node, struct rb_node * parent, struct rb_node ** rb_link)，将一个节点链接到树中指定位置，parent是父节点，rb_link指定了链接父节点的位置是左还是右。 2.1 红黑树的节点插入根据第一个部分我们所讲的内容可知，一个节点插入RB Tree时会被染成红色，因此只需要检查插入时是否违反规则4，既插入节点与其父节点是否都是红色，然后做出相应的调整，这些工作由rb_insert_color函数完成，其主要分以下三种情况，第一种是父节点为黑色，那么不需要做任何事情，插入红节点后该树仍然符合所有规则。 1234567891011void rb_insert_color(struct rb_node *node, struct rb_root *root)&#123; struct rb_node *parent, *gparent; while ((parent = node-&gt;rb_parent) &amp;&amp; parent-&gt;rb_color == RB_RED) &#123; ... // 检查与处理 &#125; root-&gt;rb_node-&gt;rb_color = RB_BLACK; // 保证根节点是黑色的&#125; 由代码可知，只要父节点为黑色那么可以直接退出。第二种情况是父节点为红色，此时违反规则4，但是其叔父节点（父节点的父节点的另一个子节点）也是红色，如下图所示，左边四个树包含了全部这种情况，A是祖父，B是插入节点的父节点，E是插入节点。 这种情况下，可以直接将父节点和叔父节点染成黑色，祖父节点染成红色，这样插入节点的父节点解决了规则4，同时祖父节点左右子树黑色节点高度仍然相同，例如上图中的第5棵树，之后将祖父节点作为插入节点继续向上检查，下面的代码执行的正是这一步骤： 12345678910111213141516171819202122232425262728293031323334353637383940void rb_insert_color(struct rb_node *node, struct rb_root *root)&#123; struct rb_node *parent, *gparent; while ((parent = node-&gt;rb_parent) &amp;&amp; parent-&gt;rb_color == RB_RED) &#123; gparent = parent-&gt;rb_parent; // 祖父节点 if (parent == gparent-&gt;rb_left) &#123; &#123; register struct rb_node *uncle = gparent-&gt;rb_right; if (uncle &amp;&amp; uncle-&gt;rb_color == RB_RED) &#123; uncle-&gt;rb_color = RB_BLACK; parent-&gt;rb_color = RB_BLACK; gparent-&gt;rb_color = RB_RED; node = gparent; continue; &#125; &#125; ... // 其他检查和处理 &#125; else &#123; &#123; register struct rb_node *uncle = gparent-&gt;rb_left; if (uncle &amp;&amp; uncle-&gt;rb_color == RB_RED) &#123; uncle-&gt;rb_color = RB_BLACK; parent-&gt;rb_color = RB_BLACK; gparent-&gt;rb_color = RB_RED; node = gparent; continue; &#125; &#125; ... // 其他检查和处理 &#125; &#125; root-&gt;rb_node-&gt;rb_color = RB_BLACK;&#125; 第三种情况最为复杂，由于叔父节点不再是红色，故不能只靠染色来解决，其可分为以下四种： 插入节点为父节点的右节点，父节点为祖父节点的左节点； 插入节点为父节点的左节点，父节点为祖父节点的左节点； 插入节点为父节点的右节点，父节点为祖父节点的右节点； 插入节点为父节点的左节点，父节点为祖父节点的右节点； 在这四种中，第2种（左左）和第3种（右右）需要先进行一次染色解决规则4冲突，然后经过旋转解决染色后的规则5冲突。以左左为例，先将父节点染成黑色，祖父节点染成红色，此时不再有颜色冲突，但是规则5出现冲突，因为左子树显然多出一个黑色节点，所以接下来祖父节点右旋，将父节点作为祖父节点，这样就完成了两个恰到好处的事情：1）祖父节点位置的颜色再次变为黑色，这必然使得祖父不会破坏规则4；2）由于原祖父节点染成红色，所以即使其变成了右子树的节点也不影响规则5。下图展示了这一过程： 对于右右，其与左左区别在于使用左旋，原理可以参考左左自行推断。对于第1种（右左）和第4种（左右），需要多增加一个旋转，使其变为左左或者右右，然后便可按照左左&#x2F;右右的规则调整RB Tree，下图展示了右左的调整过程。 需要注意的是，不论是这四种中的哪种，最后操作的结果实际上都是在祖父节点和叔父节点直接新插入了红色节点，祖父节点颜色并没有改变，而且黑色节点数量也没有改变，所以在调整结束后无需继续向上检查。下面是内核中关于第三种情况的处理： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990static void __rb_rotate_left(struct rb_node *node, struct rb_root *root)&#123; struct rb_node *right = node-&gt;rb_right; if ((node-&gt;rb_right = right-&gt;rb_left)) right-&gt;rb_left-&gt;rb_parent = node; right-&gt;rb_left = node; if ((right-&gt;rb_parent = node-&gt;rb_parent)) &#123; if (node == node-&gt;rb_parent-&gt;rb_left) node-&gt;rb_parent-&gt;rb_left = right; else node-&gt;rb_parent-&gt;rb_right = right; &#125; else root-&gt;rb_node = right; node-&gt;rb_parent = right;&#125;static void __rb_rotate_right(struct rb_node *node, struct rb_root *root)&#123; struct rb_node *left = node-&gt;rb_left; if ((node-&gt;rb_left = left-&gt;rb_right)) left-&gt;rb_right-&gt;rb_parent = node; left-&gt;rb_right = node; if ((left-&gt;rb_parent = node-&gt;rb_parent)) &#123; if (node == node-&gt;rb_parent-&gt;rb_right) node-&gt;rb_parent-&gt;rb_right = left; else node-&gt;rb_parent-&gt;rb_left = left; &#125; else root-&gt;rb_node = left; node-&gt;rb_parent = left;&#125;void rb_insert_color(struct rb_node *node, struct rb_root *root)&#123; struct rb_node *parent, *gparent; while ((parent = node-&gt;rb_parent) &amp;&amp; parent-&gt;rb_color == RB_RED) &#123; gparent = parent-&gt;rb_parent; if (parent == gparent-&gt;rb_left) &#123; &#123; register struct rb_node *uncle = gparent-&gt;rb_right; ... // 叔父为红色的处理 &#125; if (parent-&gt;rb_right == node) &#123; register struct rb_node *tmp; __rb_rotate_left(parent, root); tmp = parent; parent = node; node = tmp; &#125; parent-&gt;rb_color = RB_BLACK; gparent-&gt;rb_color = RB_RED; __rb_rotate_right(gparent, root); &#125; else &#123; &#123; register struct rb_node *uncle = gparent-&gt;rb_left; ... // 叔父为红色的处理 &#125; if (parent-&gt;rb_left == node) &#123; register struct rb_node *tmp; __rb_rotate_right(parent, root); tmp = parent; parent = node; node = tmp; &#125; parent-&gt;rb_color = RB_BLACK; gparent-&gt;rb_color = RB_RED; __rb_rotate_left(gparent, root); &#125; &#125; root-&gt;rb_node-&gt;rb_color = RB_BLACK;&#125; 在Linux内核中，如果需要插入一个节点到RB Tree中，需要执行以下几步： 遍历RB Tree，找到新节点插入位置； 调用rb_link_node将节点链接到1找到的位置； 调用rb_insert_color调整RB Tree，使其符合规则。 2.2 红黑树的节点删除红黑树的删除比插入操作更为复杂，其分为两个阶段，第一个阶段先删除节点，其技巧为：如果删除节点只有一个孩子或者没孩子，那么直接删除该节点，并链接父节点和孩子节点，代码如下： 12345678910111213141516171819202122232425262728293031323334void rb_erase(struct rb_node *node, struct rb_root *root)&#123; struct rb_node *child, *parent; int color; if (!node-&gt;rb_left) child = node-&gt;rb_right; else if (!node-&gt;rb_right) child = node-&gt;rb_left; else &#123; ... // 有两个孩子的操作 &#125; parent = node-&gt;rb_parent; color = node-&gt;rb_color; // 链接父节点和孩子节点 if (child) child-&gt;rb_parent = parent; if (parent) &#123; if (parent-&gt;rb_left == node) parent-&gt;rb_left = child; else parent-&gt;rb_right = child; &#125; else root-&gt;rb_node = child; color: // 第二阶段：调整 if (color == RB_BLACK) __rb_erase_color(child, parent, root);&#125; 如果有两个孩子，那么选择删除节点的顺序下一个节点替换删除节点，既删除位置变到了删除节点的顺序下一个节点的原先位置，这样可以保证删除节点只有一个右子树（因为删除节点的顺序下一个节点是删除节点的右子树的最左边的叶子节点），代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263void rb_erase(struct rb_node *node, struct rb_root *root)&#123; struct rb_node *child, *parent; int color; if (!node-&gt;rb_left) ... else if (!node-&gt;rb_right) ... else &#123; struct rb_node *old = node, *left; node = node-&gt;rb_right; while ((left = node-&gt;rb_left) != NULL) node = left; // 此时 node 为 删除节点的顺序下一个节点（只有右子树或者无孩子），old 为原删除节点 child = node-&gt;rb_right; parent = node-&gt;rb_parent; color = node-&gt;rb_color; // 链接删除节点的顺序下一个节点的孩子节点和父节点 if (child) child-&gt;rb_parent = parent; if (parent) &#123; if (parent-&gt;rb_left == node) parent-&gt;rb_left = child; else parent-&gt;rb_right = child; &#125; else root-&gt;rb_node = child; if (node-&gt;rb_parent == old) // 由于 old 是待删除节点，而 parent 此时指向 old，所以要将 parent 指向新的 node parent = node; // node 节点替换原删除节点 node-&gt;rb_parent = old-&gt;rb_parent; node-&gt;rb_color = old-&gt;rb_color; node-&gt;rb_right = old-&gt;rb_right; node-&gt;rb_left = old-&gt;rb_left; // 将新 node 链接到原删除节点 old 的父节点上 if (old-&gt;rb_parent) &#123; if (old-&gt;rb_parent-&gt;rb_left == old) old-&gt;rb_parent-&gt;rb_left = node; else old-&gt;rb_parent-&gt;rb_right = node; &#125; else root-&gt;rb_node = node; // 将新 node 链接到原删除节点 old 的子节点上 old-&gt;rb_left-&gt;rb_parent = node; if (old-&gt;rb_right) // 可能删除的右子树只有一个节点，删除后变为NULL old-&gt;rb_right-&gt;rb_parent = node; goto color; &#125; color: // 第二阶段：调整 if (color == RB_BLACK) __rb_erase_color(child, parent, root);&#125; 第二阶段 当在第一阶段确定了删除节点位置（通常其只有一个子树或者没有子树）后，将会检查是否要进行调色和旋转使得节点删除后的RB Tree再次符合规则。我们在下面通过5种大的情况来讲解这一操作。(1) 最简单的情况是：我们删除的节点颜色是红色的，这意味着节点删除后，子树连接到其父节点后黑色节点高度不变，因此无需调整，这点可以在rb_erase函数的最后印证，因为只有删除节点为黑色才需要执行__rb_erase_color函数。 (2) 稍微复杂的一种情况是：我们删除的节点B颜色是黑色，同时其父节点的另一个孩子节点C颜色也是黑色且其左右孩子节点E&#x2F;F也为黑色。由于父节点A的一边少了一个黑色节点，所以应该把另一边的黑色节点染成红色，这样父节点A的左右黑色节点高度相同，而且C和E&#x2F;F节点颜色不冲突。对于父节点A，如果其为红色，那正好，将其染色为黑色，这样以A为根的子树高度又恢复原样，且颜色也不会冲突；如果A为黑色，那么就要继续向上检查调整，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253static void __rb_erase_color(struct rb_node *node, struct rb_node *parent, struct rb_root *root)&#123; struct rb_node *other; while ((!node || node-&gt;rb_color == RB_BLACK) &amp;&amp; node != root-&gt;rb_node) &#123; if (parent-&gt;rb_left == node) &#123; other = parent-&gt;rb_right; if (other-&gt;rb_color == RB_RED) &#123; ... &#125; if ((!other-&gt;rb_left || other-&gt;rb_left-&gt;rb_color == RB_BLACK) &amp;&amp; (!other-&gt;rb_right || other-&gt;rb_right-&gt;rb_color == RB_BLACK)) &#123; other-&gt;rb_color = RB_RED; node = parent; parent = node-&gt;rb_parent; &#125; else &#123; ... &#125; &#125; else &#123; other = parent-&gt;rb_left; if (other-&gt;rb_color == RB_RED) &#123; ... &#125; if ((!other-&gt;rb_left || other-&gt;rb_left-&gt;rb_color == RB_BLACK) &amp;&amp; (!other-&gt;rb_right || other-&gt;rb_right-&gt;rb_color == RB_BLACK)) &#123; other-&gt;rb_color = RB_RED; node = parent; parent = node-&gt;rb_parent; &#125; else &#123; ... &#125; &#125; &#125; if (node) node-&gt;rb_color = RB_BLACK;&#125; 下面以删除节点为左子树为例展示了调色过程： (3) 我们删除的节点B颜色是黑色的，同时其父节点A的另一个孩子节点C颜色是黑色的，而C左孩子节点E为黑色，右孩子节点F为红色。对于这种情况，可以将父节点染色成黑色左旋&#x2F;右旋使得删除节点一侧增加一个黑色节点，对于另一边，因为C因为旋转变成了子树根节点，所以其应该继承原先子树根节点颜色。除此之外，由于C不再是子树节点，所以少了一个黑色节点，所以要把F染成黑色，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071static void __rb_erase_color(struct rb_node *node, struct rb_node *parent, struct rb_root *root)&#123; struct rb_node *other; while ((!node || node-&gt;rb_color == RB_BLACK) &amp;&amp; node != root-&gt;rb_node) &#123; if (parent-&gt;rb_left == node) &#123; other = parent-&gt;rb_right; if (other-&gt;rb_color == RB_RED) &#123; ... &#125; if ((!other-&gt;rb_left || other-&gt;rb_left-&gt;rb_color == RB_BLACK) &amp;&amp; (!other-&gt;rb_right || other-&gt;rb_right-&gt;rb_color == RB_BLACK)) &#123; ... &#125; else &#123; if (!other-&gt;rb_right || other-&gt;rb_right-&gt;rb_color == RB_BLACK) &#123; ... &#125; other-&gt;rb_color = parent-&gt;rb_color; parent-&gt;rb_color = RB_BLACK; if (other-&gt;rb_right) other-&gt;rb_right-&gt;rb_color = RB_BLACK; __rb_rotate_left(parent, root); node = root-&gt;rb_node; break; &#125; &#125; else &#123; other = parent-&gt;rb_left; if (other-&gt;rb_color == RB_RED) &#123; ... &#125; if ((!other-&gt;rb_left || other-&gt;rb_left-&gt;rb_color == RB_BLACK) &amp;&amp; (!other-&gt;rb_right || other-&gt;rb_right-&gt;rb_color == RB_BLACK)) &#123; ... &#125; else &#123; if (!other-&gt;rb_left || other-&gt;rb_left-&gt;rb_color == RB_BLACK) &#123; ... &#125; other-&gt;rb_color = parent-&gt;rb_color; parent-&gt;rb_color = RB_BLACK; if (other-&gt;rb_left) other-&gt;rb_left-&gt;rb_color = RB_BLACK; __rb_rotate_right(parent, root); node = root-&gt;rb_node; break; &#125; &#125; &#125; if (node) node-&gt;rb_color = RB_BLACK;&#125; 下面以删除节点为左子树为例展示了调色过程： (4) 我们删除的节点B颜色是黑色的，同时其父节点A的另一个孩子节点C颜色是黑色的，而C左孩子节点E为红色，右孩子节点F为黑色。对于这种情况，应该先经过染色和旋转将其变为情况(3)。其过程为将C染成红色右旋，这样C原先这颗子树左右子树黑色节点高度不变，只是C和E颜色冲突，不过这不用担心，按照(3)的方法，C最后变成黑色，而E变成了原先A的颜色，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980 struct rb_root *root)&#123; struct rb_node *other; while ((!node || node-&gt;rb_color == RB_BLACK) &amp;&amp; node != root-&gt;rb_node) &#123; if (parent-&gt;rb_left == node) &#123; other = parent-&gt;rb_right; if (other-&gt;rb_color == RB_RED) &#123; ... &#125; if ((!other-&gt;rb_left || other-&gt;rb_left-&gt;rb_color == RB_BLACK) &amp;&amp; (!other-&gt;rb_right || other-&gt;rb_right-&gt;rb_color == RB_BLACK)) &#123; ... &#125; else &#123; if (!other-&gt;rb_right || other-&gt;rb_right-&gt;rb_color == RB_BLACK) &#123; register struct rb_node *o_left; if ((o_left = other-&gt;rb_left)) o_left-&gt;rb_color = RB_BLACK; other-&gt;rb_color = RB_RED; __rb_rotate_right(other, root); other = parent-&gt;rb_right; &#125; other-&gt;rb_color = parent-&gt;rb_color; parent-&gt;rb_color = RB_BLACK; if (other-&gt;rb_right) other-&gt;rb_right-&gt;rb_color = RB_BLACK; __rb_rotate_left(parent, root); node = root-&gt;rb_node; break; &#125; &#125; else &#123; other = parent-&gt;rb_left; if (other-&gt;rb_color == RB_RED) &#123; ... &#125; if ((!other-&gt;rb_left || other-&gt;rb_left-&gt;rb_color == RB_BLACK) &amp;&amp; (!other-&gt;rb_right || other-&gt;rb_right-&gt;rb_color == RB_BLACK)) &#123; ... &#125; else &#123; if (!other-&gt;rb_left || other-&gt;rb_left-&gt;rb_color == RB_BLACK) &#123; register struct rb_node *o_right; if ((o_right = other-&gt;rb_right)) o_right-&gt;rb_color = RB_BLACK; other-&gt;rb_color = RB_RED; __rb_rotate_left(other, root); other = parent-&gt;rb_left; &#125; other-&gt;rb_color = parent-&gt;rb_color; parent-&gt;rb_color = RB_BLACK; if (other-&gt;rb_left) other-&gt;rb_left-&gt;rb_color = RB_BLACK; __rb_rotate_right(parent, root); node = root-&gt;rb_node; break; &#125; &#125; &#125; if (node) node-&gt;rb_color = RB_BLACK;&#125; 下面以删除节点为左子树为例展示了调色过程： (5) 我们删除的节点B颜色是黑色的，同时其父节点A的另一个孩子节点C颜色是红色的。对于这种情况，意味着父节点A必定为黑色的，而C的E&#x2F;F孩子节点为黑色的，因此我们可以通过将A染成红色左旋&#x2F;右旋，然后C染成黑色，这样，这颗子树黑色节点高度不变，同时删除节点一侧的子树变成了(3)或者(4)的情况，因为经过旋转，A的右节点变成了黑色，代码如下： 12345678910111213141516171819202122232425262728293031323334 struct rb_root *root)&#123; struct rb_node *other; while ((!node || node-&gt;rb_color == RB_BLACK) &amp;&amp; node != root-&gt;rb_node) &#123; if (parent-&gt;rb_left == node) &#123; other = parent-&gt;rb_right; if (other-&gt;rb_color == RB_RED) &#123; other-&gt;rb_color = RB_BLACK; parent-&gt;rb_color = RB_RED; __rb_rotate_left(parent, root); other = parent-&gt;rb_right; &#125; ... &#125; else &#123; other = parent-&gt;rb_left; if (other-&gt;rb_color == RB_RED) &#123; other-&gt;rb_color = RB_BLACK; parent-&gt;rb_color = RB_RED; __rb_rotate_right(parent, root); other = parent-&gt;rb_left; &#125; ... &#125; &#125; if (node) node-&gt;rb_color = RB_BLACK;&#125; 下面以删除节点为左子树为例展示了调色过程： 2.3 红黑树的查询操作Linux内核中红黑树库提供的功能没有特定某一种排序方法，所以也没有给出查询接口。由于红黑树也是二叉排序树的一种，以升序为例，我们只需要按照以下流程即可进行查询操作： 12345678910Query x:node = rootwhile node is not null and node.value != x: if node.value &lt; x： node = node.right else: node = node.leftReturn node 3. 红黑树操作实验 实验介绍：有一种对象Item，里面包含：1）树节点，用于管理RB Tree；2）数值，表示了对象的实际内容；3）出现次数，由于我们希望节点随机产生，因此可能存在重复的情况，该值用于统计相同节点的数量。我们先随机num个Item，然后使用这些Item构建出红黑树。最后通过输入要擦除的对象，我们将其从树中删除并显示。 下图时代码运行后的效果，每个节点打印含义为[数值，出现次数，节点颜色]，最左边为根节点，左节点在右节点上方。 附录A: 实验代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740main.c :#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &quot;rbtree.h&quot;typedef struct _Item&#123; int val; int num; // appear num struct rb_node node;&#125;Item;static int print_num = 0;static int print_level = 0;Item* GenerateItem();void DFS(struct rb_node *node);int main()&#123; int num = 0; Item *item, *cur, *prev = NULL; struct rb_node **link; struct rb_root root = RB_ROOT; srand(time(NULL)); printf(&quot;Test item num: &quot;); scanf(&quot;%d&quot;, &amp;num); print_num = 0; printf(&quot;Generate Item[%d]: &quot;, num); /* generate a random rb tree with [num] node */ while (num &gt; 0) &#123; /* randomize a rb tree node */ item = GenerateItem(); if (print_num == 16) &#123; printf(&quot; &quot;); print_num = 0; &#125; printf(&quot;%d\\t&quot;, item-&gt;val); /* insert a rb tree node to rb tree */ if (!root.rb_node) // empty rb tree &#123; root.rb_node = &amp;(item-&gt;node); rb_insert_color(&amp;(item-&gt;node), &amp;root); goto next_loop; &#125; cur = rb_entry(root.rb_node, Item, node); /* 1. find insert position */ while (cur) &#123; if (cur-&gt;val == item-&gt;val) // the same item &#123; cur-&gt;num++; free(item); goto next_loop; &#125; else if (cur-&gt;val &gt; item-&gt;val) &#123; prev = cur; link = &amp;(cur-&gt;node.rb_left); if (cur-&gt;node.rb_left == NULL) &#123; break; &#125; cur = rb_entry(cur-&gt;node.rb_left, Item, node); &#125; else &#123; prev = cur; link = &amp;(cur-&gt;node.rb_right); if (cur-&gt;node.rb_right == NULL) &#123; break; &#125; cur = rb_entry(cur-&gt;node.rb_right, Item, node); &#125; &#125; /* 2. link node */ rb_link_node(&amp;(item-&gt;node), &amp;(prev-&gt;node), link); /* 3. adjust */ rb_insert_color(&amp;(item-&gt;node), &amp;root);next_loop: num--; &#125; /* print a generated rb tree */ print_num = 0; print_level = 0; printf(&quot; sort result: &quot;); DFS(root.rb_node); printf(&quot; &quot;); /* testing erase some rb tree node */ printf(&quot; Test Erase, input node value to erase its node, or input negative value to exit &quot;); while (1) &#123; /* get the node need to erase */ printf(&quot;&gt;&gt;&quot;); scanf(&quot;%d&quot;, &amp;num); if (num &lt; 0) &#123; break; &#125; /* 1. find insert position */ if (!root.rb_node) // empty rb tree &#123; printf(&quot;empty tree &quot;); break; &#125; cur = rb_entry(root.rb_node, Item, node); while (cur) &#123; if (cur-&gt;val == num) // the same item &#123; break; &#125; else if (cur-&gt;val &gt; num) &#123; if (cur-&gt;node.rb_left == NULL) &#123; cur = NULL; break; &#125; cur = rb_entry(cur-&gt;node.rb_left, Item, node); &#125; else &#123; if (cur-&gt;node.rb_right == NULL) &#123; cur = NULL; break; &#125; cur = rb_entry(cur-&gt;node.rb_right, Item, node); &#125; &#125; /* 2. do erase function */ if (cur) &#123; printf(&quot;erase %d &quot;, num); rb_erase(&amp;(cur-&gt;node), &amp;root); free(cur); DFS(root.rb_node); printf(&quot; &quot;); &#125; else &#123; printf(&quot;not exist &quot;); &#125; printf(&quot;=================================================================== &quot;); &#125; return 0;&#125;Item* GenerateItem()&#123; Item *item = (Item*)malloc(sizeof(Item)); item-&gt;val = rand() % 1000; item-&gt;num = 1; item-&gt;node.rb_parent = NULL; item-&gt;node.rb_left = NULL; item-&gt;node.rb_right = NULL; return item;&#125;void DFS(struct rb_node *node)&#123; Item *item; int i; if (node) &#123; print_level++; DFS(node-&gt;rb_left); if (print_num == 4) &#123; printf(&quot; &quot;); print_num = 0; &#125; item = rb_entry(node, Item, node); for (i = 1; i &lt; print_level; i++) &#123; printf(&quot; &quot;); &#125; printf(&quot;[%3d,%3d,%c] &quot;, item-&gt;val, item-&gt;num, (item-&gt;node.rb_color == RB_RED) ? &#x27;R&#x27; : &#x27;B&#x27;); print_num++; DFS(node-&gt;rb_right); print_level--; &#125;&#125;rbtree.h :/* Red Black Trees (C) 1999 Andrea Arcangeli &lt;andrea@suse.de&gt; This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA linux/include/linux/rbtree.h To use rbtrees you&#x27;ll have to implement your own insert and search cores. This will avoid us to use callbacks and to drop drammatically performances. I know it&#x27;s not the cleaner way, but in C (not in C++) to get performances and genericity... Some example of insert and search follows here. The search is a plain normal search over an ordered tree. The insert instead must be implemented int two steps: as first thing the code must insert the element in order as a red leaf in the tree, then the support library function rb_insert_color() must be called. Such function will do the not trivial work to rebalance the rbtree if necessary.-----------------------------------------------------------------------static inline struct page * rb_search_page_cache(struct inode * inode, unsigned long offset)&#123; struct rb_node * n = inode-&gt;i_rb_page_cache.rb_node; struct page * page; while (n) &#123; page = rb_entry(n, struct page, rb_page_cache); if (offset &lt; page-&gt;offset) n = n-&gt;rb_left; else if (offset &gt; page-&gt;offset) n = n-&gt;rb_right; else return page; &#125; return NULL;&#125;static inline struct page * __rb_insert_page_cache(struct inode * inode, unsigned long offset, struct rb_node * node)&#123; struct rb_node ** p = &amp;inode-&gt;i_rb_page_cache.rb_node; struct rb_node * parent = NULL; struct page * page; while (*p) &#123; parent = *p; page = rb_entry(parent, struct page, rb_page_cache); if (offset &lt; page-&gt;offset) p = &amp;(*p)-&gt;rb_left; else if (offset &gt; page-&gt;offset) p = &amp;(*p)-&gt;rb_right; else return page; &#125; rb_link_node(node, parent, p); return NULL;&#125;static inline struct page * rb_insert_page_cache(struct inode * inode, unsigned long offset, struct rb_node * node)&#123; struct page * ret; if ((ret = __rb_insert_page_cache(inode, offset, node))) goto out; rb_insert_color(node, &amp;inode-&gt;i_rb_page_cache); out: return ret;&#125;-----------------------------------------------------------------------*/#ifndef _LINUX_RBTREE_H#define _LINUX_RBTREE_H// #include &lt;linux/kernel.h&gt;// #include &lt;linux/stddef.h&gt;#include &lt;stdlib.h&gt;#define offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE*)0)-&gt;MEMBER)#define container_of(ptr, type, member) (&#123; \\ const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr); \\ (type *)( (char *)__mptr - offsetof(type,member) );&#125;)struct rb_node&#123; struct rb_node *rb_parent; int rb_color;#define RB_RED 0#define RB_BLACK 1 struct rb_node *rb_right; struct rb_node *rb_left;&#125;;struct rb_root&#123; struct rb_node *rb_node;&#125;;#define RB_ROOT (struct rb_root) &#123; NULL, &#125;#define rb_entry(ptr, type, member) container_of(ptr, type, member)extern void rb_insert_color(struct rb_node *, struct rb_root *);extern void rb_erase(struct rb_node *, struct rb_root *);/* Find logical next and previous nodes in a tree */extern struct rb_node *rb_next(struct rb_node *);extern struct rb_node *rb_prev(struct rb_node *);extern struct rb_node *rb_first(struct rb_root *);extern struct rb_node *rb_last(struct rb_root *);/* Fast replacement of a single node without remove/rebalance/add/rebalance */extern void rb_replace_node(struct rb_node *victim, struct rb_node *new, struct rb_root *root);static inline void rb_link_node(struct rb_node * node, struct rb_node * parent, struct rb_node ** rb_link)&#123; node-&gt;rb_parent = parent; node-&gt;rb_color = RB_RED; node-&gt;rb_left = node-&gt;rb_right = NULL; *rb_link = node;&#125;#endif /* _LINUX_RBTREE_H */rbtree.c :/* Red Black Trees (C) 1999 Andrea Arcangeli &lt;andrea@suse.de&gt; (C) 2002 David Woodhouse &lt;dwmw2@infradead.org&gt; This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA linux/lib/rbtree.c*/// #include &lt;linux/rbtree.h&gt;// #include &lt;linux/module.h&gt;#include &quot;rbtree.h&quot;static void __rb_rotate_left(struct rb_node *node, struct rb_root *root)&#123; struct rb_node *right = node-&gt;rb_right; if ((node-&gt;rb_right = right-&gt;rb_left)) right-&gt;rb_left-&gt;rb_parent = node; right-&gt;rb_left = node; if ((right-&gt;rb_parent = node-&gt;rb_parent)) &#123; if (node == node-&gt;rb_parent-&gt;rb_left) node-&gt;rb_parent-&gt;rb_left = right; else node-&gt;rb_parent-&gt;rb_right = right; &#125; else root-&gt;rb_node = right; node-&gt;rb_parent = right;&#125;static void __rb_rotate_right(struct rb_node *node, struct rb_root *root)&#123; struct rb_node *left = node-&gt;rb_left; if ((node-&gt;rb_left = left-&gt;rb_right)) left-&gt;rb_right-&gt;rb_parent = node; left-&gt;rb_right = node; if ((left-&gt;rb_parent = node-&gt;rb_parent)) &#123; if (node == node-&gt;rb_parent-&gt;rb_right) node-&gt;rb_parent-&gt;rb_right = left; else node-&gt;rb_parent-&gt;rb_left = left; &#125; else root-&gt;rb_node = left; node-&gt;rb_parent = left;&#125;void rb_insert_color(struct rb_node *node, struct rb_root *root)&#123; struct rb_node *parent, *gparent; while ((parent = node-&gt;rb_parent) &amp;&amp; parent-&gt;rb_color == RB_RED) &#123; gparent = parent-&gt;rb_parent; if (parent == gparent-&gt;rb_left) &#123; &#123; register struct rb_node *uncle = gparent-&gt;rb_right; if (uncle &amp;&amp; uncle-&gt;rb_color == RB_RED) &#123; uncle-&gt;rb_color = RB_BLACK; parent-&gt;rb_color = RB_BLACK; gparent-&gt;rb_color = RB_RED; node = gparent; continue; &#125; &#125; if (parent-&gt;rb_right == node) &#123; register struct rb_node *tmp; __rb_rotate_left(parent, root); tmp = parent; parent = node; node = tmp; &#125; parent-&gt;rb_color = RB_BLACK; gparent-&gt;rb_color = RB_RED; __rb_rotate_right(gparent, root); &#125; else &#123; &#123; register struct rb_node *uncle = gparent-&gt;rb_left; if (uncle &amp;&amp; uncle-&gt;rb_color == RB_RED) &#123; uncle-&gt;rb_color = RB_BLACK; parent-&gt;rb_color = RB_BLACK; gparent-&gt;rb_color = RB_RED; node = gparent; continue; &#125; &#125; if (parent-&gt;rb_left == node) &#123; register struct rb_node *tmp; __rb_rotate_right(parent, root); tmp = parent; parent = node; node = tmp; &#125; parent-&gt;rb_color = RB_BLACK; gparent-&gt;rb_color = RB_RED; __rb_rotate_left(gparent, root); &#125; &#125; root-&gt;rb_node-&gt;rb_color = RB_BLACK;&#125;static void __rb_erase_color(struct rb_node *node, struct rb_node *parent, struct rb_root *root)&#123; struct rb_node *other; while ((!node || node-&gt;rb_color == RB_BLACK) &amp;&amp; node != root-&gt;rb_node) &#123; if (parent-&gt;rb_left == node) &#123; other = parent-&gt;rb_right; if (other-&gt;rb_color == RB_RED) &#123; other-&gt;rb_color = RB_BLACK; parent-&gt;rb_color = RB_RED; __rb_rotate_left(parent, root); other = parent-&gt;rb_right; &#125; if ((!other-&gt;rb_left || other-&gt;rb_left-&gt;rb_color == RB_BLACK) &amp;&amp; (!other-&gt;rb_right || other-&gt;rb_right-&gt;rb_color == RB_BLACK)) &#123; other-&gt;rb_color = RB_RED; node = parent; parent = node-&gt;rb_parent; &#125; else &#123; if (!other-&gt;rb_right || other-&gt;rb_right-&gt;rb_color == RB_BLACK) &#123; register struct rb_node *o_left; if ((o_left = other-&gt;rb_left)) o_left-&gt;rb_color = RB_BLACK; other-&gt;rb_color = RB_RED; __rb_rotate_right(other, root); other = parent-&gt;rb_right; &#125; other-&gt;rb_color = parent-&gt;rb_color; parent-&gt;rb_color = RB_BLACK; if (other-&gt;rb_right) other-&gt;rb_right-&gt;rb_color = RB_BLACK; __rb_rotate_left(parent, root); node = root-&gt;rb_node; break; &#125; &#125; else &#123; other = parent-&gt;rb_left; if (other-&gt;rb_color == RB_RED) &#123; other-&gt;rb_color = RB_BLACK; parent-&gt;rb_color = RB_RED; __rb_rotate_right(parent, root); other = parent-&gt;rb_left; &#125; if ((!other-&gt;rb_left || other-&gt;rb_left-&gt;rb_color == RB_BLACK) &amp;&amp; (!other-&gt;rb_right || other-&gt;rb_right-&gt;rb_color == RB_BLACK)) &#123; other-&gt;rb_color = RB_RED; node = parent; parent = node-&gt;rb_parent; &#125; else &#123; if (!other-&gt;rb_left || other-&gt;rb_left-&gt;rb_color == RB_BLACK) &#123; register struct rb_node *o_right; if ((o_right = other-&gt;rb_right)) o_right-&gt;rb_color = RB_BLACK; other-&gt;rb_color = RB_RED; __rb_rotate_left(other, root); other = parent-&gt;rb_left; &#125; other-&gt;rb_color = parent-&gt;rb_color; parent-&gt;rb_color = RB_BLACK; if (other-&gt;rb_left) other-&gt;rb_left-&gt;rb_color = RB_BLACK; __rb_rotate_right(parent, root); node = root-&gt;rb_node; break; &#125; &#125; &#125; if (node) node-&gt;rb_color = RB_BLACK;&#125;void rb_erase(struct rb_node *node, struct rb_root *root)&#123; struct rb_node *child, *parent; int color; if (!node-&gt;rb_left) child = node-&gt;rb_right; else if (!node-&gt;rb_right) child = node-&gt;rb_left; else &#123; struct rb_node *old = node, *left; node = node-&gt;rb_right; while ((left = node-&gt;rb_left) != NULL) node = left; child = node-&gt;rb_right; parent = node-&gt;rb_parent; color = node-&gt;rb_color; if (child) child-&gt;rb_parent = parent; if (parent) &#123; if (parent-&gt;rb_left == node) parent-&gt;rb_left = child; else parent-&gt;rb_right = child; &#125; else root-&gt;rb_node = child; if (node-&gt;rb_parent == old) parent = node; node-&gt;rb_parent = old-&gt;rb_parent; node-&gt;rb_color = old-&gt;rb_color; node-&gt;rb_right = old-&gt;rb_right; node-&gt;rb_left = old-&gt;rb_left; if (old-&gt;rb_parent) &#123; if (old-&gt;rb_parent-&gt;rb_left == old) old-&gt;rb_parent-&gt;rb_left = node; else old-&gt;rb_parent-&gt;rb_right = node; &#125; else root-&gt;rb_node = node; old-&gt;rb_left-&gt;rb_parent = node; if (old-&gt;rb_right) old-&gt;rb_right-&gt;rb_parent = node; goto color; &#125; parent = node-&gt;rb_parent; color = node-&gt;rb_color; if (child) child-&gt;rb_parent = parent; if (parent) &#123; if (parent-&gt;rb_left == node) parent-&gt;rb_left = child; else parent-&gt;rb_right = child; &#125; else root-&gt;rb_node = child; color: if (color == RB_BLACK) __rb_erase_color(child, parent, root);&#125;/* * This function returns the first node (in sort order) of the tree. */struct rb_node *rb_first(struct rb_root *root)&#123; struct rb_node *n; n = root-&gt;rb_node; if (!n) return NULL; while (n-&gt;rb_left) n = n-&gt;rb_left; return n;&#125;struct rb_node *rb_last(struct rb_root *root)&#123; struct rb_node *n; n = root-&gt;rb_node; if (!n) return NULL; while (n-&gt;rb_right) n = n-&gt;rb_right; return n;&#125;struct rb_node *rb_next(struct rb_node *node)&#123; /* If we have a right-hand child, go down and then left as far as we can. */ if (node-&gt;rb_right) &#123; node = node-&gt;rb_right; while (node-&gt;rb_left) node=node-&gt;rb_left; return node; &#125; /* No right-hand children. Everything down and left is smaller than us, so any &#x27;next&#x27; node must be in the general direction of our parent. Go up the tree; any time the ancestor is a right-hand child of its parent, keep going up. First time it&#x27;s a left-hand child of its parent, said parent is our &#x27;next&#x27; node. */ while (node-&gt;rb_parent &amp;&amp; node == node-&gt;rb_parent-&gt;rb_right) node = node-&gt;rb_parent; return node-&gt;rb_parent;&#125;struct rb_node *rb_prev(struct rb_node *node)&#123; /* If we have a left-hand child, go down and then right as far as we can. */ if (node-&gt;rb_left) &#123; node = node-&gt;rb_left; while (node-&gt;rb_right) node=node-&gt;rb_right; return node; &#125; /* No left-hand children. Go up till we find an ancestor which is a right-hand child of its parent */ while (node-&gt;rb_parent &amp;&amp; node == node-&gt;rb_parent-&gt;rb_left) node = node-&gt;rb_parent; return node-&gt;rb_parent;&#125;void rb_replace_node(struct rb_node *victim, struct rb_node *new, struct rb_root *root)&#123; struct rb_node *parent = victim-&gt;rb_parent; /* Set the surrounding nodes to point to the replacement */ if (parent) &#123; if (victim == parent-&gt;rb_left) parent-&gt;rb_left = new; else parent-&gt;rb_right = new; &#125; else &#123; root-&gt;rb_node = new; &#125; if (victim-&gt;rb_left) victim-&gt;rb_left-&gt;rb_parent = new; if (victim-&gt;rb_right) victim-&gt;rb_right-&gt;rb_parent = new; /* Copy the pointers/colour from the victim to the replacement */ *new = *victim;&#125;","tags":["kernel"],"categories":["kernel"]},{"title":"内核队列","path":"/posts/内核队列.html","content":"一、kfifo原理 kfifo实现原理是采用循环（环形）队列。 1234567struct kfifo&#123; unsigned char *buffer; / *保存数据的缓冲区* / unsigned int size; / *分配的缓冲区的大小* / unsigned int in; / *数据以偏移量(in%size)添加* / unsigned int out; / *数据从off中提取。(out%size)* /&#125;; 二、kfifo特点1、采用环形缓冲区来实现，提供一个无边界的字节流服务。采用环形缓冲区的好处为，当一个数据元素被用掉后，其余数据元素不需要移动其存储位置，从而减少拷贝提高效率。 2、保证缓冲区大小为2的次幂，不是的向上取整为2的次幂（很重要）。 3、使用无符号整数保存输入(in)和输出(out)的位置，在输入输出时不对in和out的值进行模运算，而让其自然溢出，并能够保证in-out的结果为缓冲区中已存放的数据长度。 4、将需要取模的运算用 &amp; 操作代替（ a % size &#x3D; (a &amp; (size − 1)) ), 这需要size保证为2的次幂。 5、使用内存屏障(Memory Barrier)技术，实现单消费者和单生产者对kfifo的无锁并发访问（包括多CPU的情况），多个消费者、生产者的并发访问还是需要加锁的。 关于kfifo中内存屏障的使用，请参考https://www.linuxidc.com/Linux/2016-12/137936.htm。 三、kfifo功能函数之创建队列 kfifo提供两种创建队列的方法，动态创建和静态创建。 1、动态创建(1)、kfifo_alloc 123struct kfifo g_fifoqueue;int kfifo_alloc(struct kfifo *fifo, unsigned int size, gfp_t gfp_mask); 该函数创建并初始化一个size大小的kfifo。内核使用gfp_mask标识符分配队列的缓冲区内存。如果成功，函数返回0，错误则返回负数的错误码。注意kfifo_alloc申请的内存是在物理地址上是连续的 (2)、kfifo_init 如果要自己分配缓冲区，可以调用函数： 1void kfifo_init(struct kfifo *fifo, void *buffer, unsigned int size); 2、静态创建DECLARE_KFIFO(name, size) ; INIT_KFIFO(name); 四、入队操作对于推入队列数据，kfifo提供三大类函数：常规函数， 将用户空间数据推入队列的函数，带记录域功能的函数。 1）常规函数 unsigned int kfifo_in(struct kfifo *fifo, const void *from, unsigned int len); unsigned int kfifo_in_locked(struct kfifo *fifo, const void *from, unsigned int n, spinlock_t *lock); 2）将用户空间数据推入队列的函数 int kfifo_from_user(struct kfifo *fifo, const void __user *from, unsigned int n, unsigned *lenout); unsigned int kfifo_from_user_rec(struct kfifo *fifo, const void __user *from, unsigned int n, unsigned int recsize); 3）带记录域功能的函数 unsigned int kfifo_in_rec(struct kfifo *fifo, void *from, unsigned int n, unsigned int recsize)； 五、出队对于摘取队列数据，kfifo提供三大类函数：常规函数， 摘取队列数据至用户空间的函数，带记录域功能的函数。 (1)、常规函数 12345unsigned int kfifo_out(struct kfifo *fifo, void *to, unsigned int len);unsigned int kfifo_out_locked(struct kfifo *fifo, void *to, unsigned int n, spinlock_t *lock);unsigned int kfifo_out_peek(struct kfifo *fifo, void *to, unsigned int len, unsigned offset); (2)、摘取队列数据至用户空间的函数 123unsigned int kfifo_to_user(struct kfifo *fifo, void __user *to, unsigned int n, unsigned *lenout);unsigned int kfifo_to_user_rec(struct kfifo *fifo, void __user *to, unsigned int n, unsigned int recsize, unsigned int *total); (3)、带记录域功能的函数 1unsigned int kfifo_out_rec(struct kfifo *fifo, void *to, unsigned int n, unsigned int recsize, unsigned int *total); 六、获取队列长度、判空等操作(1)、获取队列缓冲区大小 1unsigned int kfifo_size(struct kfifo *fifo); (2)、获取队列已推入的数据大小 1unsigned int kfifo_len(struct kfifo *fifo); (3)、获取队列可用空间大小 1unsigned int kfifo_avail(struct kfifo *fifo); (4)、判断队列是否空 1int kfifo_is_empty(struct kfifo *fifo); (5)、判断队列是否满 1int kfifo_is_full(struct kfifo *fifo); 七、重置和撤销队列(1)、重置队列 123void kfifo_reset(struct kfifo *fifo);void kfifo_skip(struct kfifo *fifo, unsigned int len); (2)、撤销队列 如果队列是由函数kfifo_alloc创建，则撤销队列使用： 12void kfifo_free(struct kfifo *fifo); 如果队列是由函数kfifo_init创建，则你需要负责释放相关缓冲。","tags":["kernel"],"categories":["kernel"]},{"title":"内核链表","path":"/posts/内核链表.html","content":"在Linux内核中使用了大量的链表结构来组织数据，包括设备列表以及各种功能模块中的数据组织。这些链表大多采用在include&#x2F;linux&#x2F;list.h实现的一个相当精彩的链表数据结构。事实上，内核链表就是采用双循环链表机制。 内核链表有别于传统链表就在节点本身不包含数据域，只包含指针域。故而可以很灵活的拓展数据结构。 一、神奇的结构：list_head要了解内核链表，就不得不提 list_head。这个结构很有意思，整个结构没有数据域，只有两个指针域。这个结构本身意义不大，不过在内核链表中，起着整个衔接作用，可以说是内核链表的核心不为过。 123struct list_head &#123; struct list_head *next, *prev;&#125;; 二、链表初始化内核提供多种方式来初始化链表：宏初始化和接口初始化。 (1)宏初始化LIST_HEAD_HEAD_INIT宏设计的很精妙。这个宏本身不包含任何数据类型，也就是说没有限定唯一的数据类型，这就使得整个链表足够灵活。是不是有点C++模板的意思？ 对于任意给定的结构指针，将【前驱】和【后继】指针都指向自己，作为链表头指针。 LIST_HEAD 宏 本质就是赋予了 name 于 【struct list_head】 属性，由于 list_head 本身不包含数据域，所以搭配 LIST_HEAD_HEAD_INIT 宏，就使得整个链表上的数据更加灵活。具备通用性。 123#define LIST_HEAD_INIT(name) &#123; &amp;(name), &amp;(name) &#125;#define LIST_HEAD(name) \\ struct list_head name = LIST_HEAD_INIT(name) (2)接口初始化接口操作就比较直接明了，基本上和宏实现的意图一样。直接将链表头指针的前驱和后继都指向自己 12345static inline void INIT_LIST_HEAD(struct list_head *list)&#123; list-&gt;next = list; list-&gt;prev = list;&#125; 我们以示例来补充说明，这样有助于大家辅助理解： 12// 1. 链表节点初始化，前驱和后继都指向自己（初始化）struct list = LIST_HEAD(list); 前面说了 list_head 只有指针域，没有数据域，如果只是这样就没有什么意义了。所以我们需要创建一个宿主结构，然后再再此结构包含 list 字段，宿主结构，也有其他字段（进程描述符，页面管理结构等都是采用这种方法创建链表的）。假设定义如下： 1234struct my_data_list &#123; int data ; struct list_head list; /* list head , 这个至关重要，后期遍历通过container_of 解析my_data_list 地址 */&#125;; 创建一个节点： 123456struct my_data_list first_data =&#123; .val = 1, /* 这里有点绕，事实上就是将first_data.list , 前驱和后继都指向自己进行初始化 */ .list = LIST_HEAD_INIT(first_data.list),&#125;; 这里 list 的 prev 和 next 都指向list 自己了，并且list 属于 my_data_list 的成员。只需要遍历到lst 节点就能根据 前面讲的 container_of 推导得到其宿主结构的地址，从而访问val值，如果有其他方法，也可访问。 分析到这里，应该逐渐明晰，为何list_head 设计很有意思？为什么链表本身不包含数据域，却能衍生出无数数据类型，不受特定的数据类型限制。 三、添加节点内核相应的提供了添加节点的接口： (1)list_addlist_add 如下，最终调用的是__list_add 函数，根据注释可知，list_add 是头部插入，总是在链表的头部插入一个新的节点。 list_add 123456789101112/** * list_add - add a new entry * @new: new entry to be added * @head: list head to add it after * * Insert a new entry after the specified head. * This is good for implementing stacks. */static inline void list_add(struct list_head *new, struct list_head *head)&#123; __list_add(new, head, head-&gt;next);&#125; __list_add 123456789101112131415/* * Insert a new entry between two known consecutive entries. * * This is only for internal list manipulation where we know * the prev/next entries already! */static inline void __list_add(struct list_head *new, struct list_head *prev, struct list_head *next)&#123; next-&gt;prev = new; new-&gt;next = next; new-&gt;prev = prev; prev-&gt;next = new;&#125; 我们再以示例补充说明： 首先创建一个链表头：listHead 1LIST_HEAD(listHead); 然后再创建第一个链表节点： 12345struct my_data_list first_data =&#123; .val = 1, .list = LIST_HEAD_INIT(first_data.list),&#125;; 接着 把这个节点插入到 listHead 后 1list_add(&amp;frist_data.list, &amp;listHead); 紧接着我们再创建第二个节点： 12345678struct my_data_list second_data =&#123; .val = 2, /* 也可以调用接口 初始化*/ .list = LIST_HEAD_INIT(second_data.list),&#125;;list_add(&amp;second_data.list, &amp;listHead); 示意图如下： 以此类推，每次插入一个新节点，都是紧靠着header节点，而之前插入的节点依次排序靠后，那最后一个节点则是第一次插入header后的那个节点。 可以看出：先来的节点靠后，而后来的节点靠前，符合“先进后出，后进先出”。所以此种结构类似于 stack“栈” ， 类似于内核stack中的栈顶指针esp， 它都是紧靠着最后push到栈的元素。 (2)list_add_tail再看内核另外一种插入方式，本质都是调用__lis_add。不同的是，一个是头部插入，一个是尾部插入。 123456789101112/** * list_add_tail - add a new entry * @new: new entry to be added * @head: list head to add it before * * Insert a new entry before the specified head. * This is useful for implementing queues. */static inline void list_add_tail(struct list_head *new, struct list_head *head)&#123; __list_add(new, head-&gt;prev, head);&#125; 我们还是以示例辅助说明： 首先创建一个链表头： 1LIST_HEAD(listHead); 然后创建第一个节点 12345struct my_data_list first_data =&#123; .val = 1, .list = LIST_HEAD_INIT(first_data.list),&#125;; 插入第一个节点： 1list_add_tail(&amp;first_data.list, listHead); 紧接着插入第二个节点： 12345678struct my_data_list second_data =&#123; .val = 2, /* 也可以调用接口 初始化*/ .list = LIST_HEAD_INIT(second_data.list),&#125;;list_add_tail(&amp;second_data.list, &amp;listHead); 示意图如下： 每次插入的新节点都是紧挨着 header 表尾，而插入的第一个节点排在了第一位，第二个排在了第二位。 先插入的节点排在前面，后插入的节点排在后面，“先进先出，后进后出”（First in First out,FIFO）！这不就是队列吗？ 总结由于是双循环链表，看起来尾部插入和头部插入是一样的，其实不然。 我们再来对比尾部和头部插入的区别： 头部插入，结构是逆序，属于先进后出，最主要的区别就是头节点的prev指针指向第一个节点。 尾部插入，结构是顺序，属于FIFO结构，最主要的区别就是头节点的next指针指向第一个节点。 list_add：头部插入一个节点 list_add_tail：尾部插入一个节点 四、删除节点内核同样定义了删除节点的接口 list_del list_del： 123456789static inline void list_del(struct list_head *entry)&#123; /* __list_del_entry(entry) 也行*/ __list_del(entry-&gt;prev, entry-&gt;next); /* 指向特定的位置，反初始化 */ entry-&gt;next = LIST_POISON1; entry-&gt;prev = LIST_POISON2;&#125; __list_del：这个接口，根据prev&#x2F;next 删除其节点，删除的节点必须是已知的并且 prev 和 next 不为空 123456789101112/* * Delete a list entry by making the prev/next entries * point to each other. * * This is only for internal list manipulation where we know * the prev/next entries already! */static inline void __list_del(struct list_head * prev, struct list_head * next)&#123; next-&gt;prev = prev; prev-&gt;next = next;&#125; __list_del_entry：删除一个节点。 12345678910/** * list_del - deletes entry from list. * @entry: the element to delete from the list. * Note: list_empty() on entry does not return true after this, the entry is * in an undefined state. */static inline void __list_del_entry(struct list_head *entry)&#123; __list_del(entry-&gt;prev, entry-&gt;next);&#125; 123456789/** * list_del_init - deletes entry from list and reinitialize it. * @entry: the element to delete from the list. */static inline void list_del_init(struct list_head *entry)&#123; __list_del_entry(entry); INIT_LIST_HEAD(entry);&#125; 利用list_del(struct list_head *entry) 接口就可以删除链表中的任意节点了，需注意，前提条件是这个节点是已知的，既在链表中真实存在，切prev，next指针都不为NULL。 被剔除下来的 my_data_list.list，prev、next 指针分别被设为 LIST_POSITION2和LIST_POSITION1两个特殊值，这样设置是为了保证不在链表中的节点项不可访问–对LIST_POSITION1和LIST_POSITION2的访问都将引起页故障。 与之相对应，list_del_init()函数将节点从链表中解下来之后，调用LIST_INIT_HEAD()将节点置为空链状态。 list_del() 和 list_del_init 是外部接口。__list_del() 和 __list_entry() 是内核内部节点。 list_del() 作用是删除双链表中的一个节点。并将节点的prev和next都指向特定位置，LIST_POSITION1和LIST_POSITION2。 list_del_init() 作用是删除双链表中的一个节点，并将节点的prev和next都指向自己，回到最开始创建节点前的状态。 五、搬移内核提供了将原本属于一个链表的节点移动到另一个链表的操作，并根据插入到新链表的位置分为两类：头部搬移和尾部搬移。搬移的本质就是删除加插入。 头部搬移12345678910/** * list_move - delete from one list and add as another&#x27;s head * @list: the entry to move * @head: the head that will precede our entry */static inline void list_move(struct list_head *list, struct list_head *head)&#123; __list_del_entry(list); list_add(list, head);&#125; 尾部搬移1234567891011/** * list_move_tail - delete from one list and add as another&#x27;s tail * @list: the entry to move * @head: the head that will follow our entry */static inline void list_move_tail(struct list_head *list, struct list_head *head)&#123; __list_del_entry(list); list_add_tail(list, head);&#125; 六、合并内核还提供两组合并操作，将两条链表合并在一起。 当 list1 被挂接到 list2 之后，作为原表头指针的 list1 的next、prev仍然指向原来的节点，为了避免引起混乱，Linux提供了一个list_splice_init()函数.该函数在将list合并到head链表的基础上，调用INIT_LIST_HEAD(list)将list设置为空链。 1234static inline void list_splice(const struct list_head *list, struct list_head *head);static inline void list_splice_init(struct list_head *list, struct list_head *head);static inline void list_splice_tail(const struct list_head *list, struct list_head *head);static inline void list_splice_tail_init(struct list_head *list, struct list_head *head); 示意图如下： 另外一种方式类似，只不过合并时断开的位置有所不同 七、替换内核还提供一组替换链表节点的操作。list_replace：将新的节点替换到旧的节点上。list_replace_init：将新的节点替换到旧的节点上。同时将旧的节点的prev和next指向自己，反初始化 12static inline void list_replace(struct list_head *old, struct list_head *new);static inline void list_replace_init(struct list_head *old, struct list_head *new); 八、遍历操作内核提供了一组宏进行遍历操作。经过一系列的增删减改操作，我们终于到了遍历的时候。 list_entry 宏重头戏来了，遍历的关键就是这个list_entry宏。本质就是container_of宏。 具体分析见上一篇文章。这个宏的主要作用就是获取宿主结构的指针地址。 前文提到，我们是以list 指针为节点组成的一条双链表，遍历的过程中只能得到list的地址，那么对于其所有者地址就是通过这个宏获取的。 12345678/*** list_entry - get the struct for this entry* @ptr: the &amp;struct list_head pointer.* @type: the type of the struct this is embedded in.* @member: the name of the list_struct within the struct.*/#define list_entry(ptr, type, member) \\ container_of(ptr, type, member) 12/* 根据list 倒推 my_list_data*/list_entry(&amp;my_list_data.list, typeof(&amp;my_list_data), list) list_for_eachlist_for_each 它实际上是一个for循环，利用传入的pos作为循环变量，从表头head开始，逐项向后（next方向）移动pos，直至又回到head 1234567/** * list_for_each - iterate over a list * @pos: the &amp;struct list_head to use as a loop cursor. * @head: the head for your list. */#define list_for_each(pos, head) \\ for (pos = (head)-&gt;next; pos != (head); pos = pos-&gt;next) list_for_each_entry遍历每一个list,然后获取其宿主结构地址。&#x3D;&#x3D;pos一般是新建一个链表，传入，用于for循环遍历，head一般是待遍历的链表，member是传入的pos中的list_head对应的成员&#x3D;&#x3D; 12345678910/** * list_for_each_entry - iterate over list of given type * @pos: the type * to use as a loop cursor. * @head: the head for your list. * @member: the name of the list_struct within the struct. */#define list_for_each_entry(pos, head, member) \\ for (pos = list_entry((head)-&gt;next, typeof(*pos), member); \\ &amp;pos-&gt;member != (head); \\ pos = list_entry(pos-&gt;member.next, typeof(*pos), member)) list_for_each_prev反向遍历得到list. 1234567/** * list_for_each_prev - iterate over a list backwards * @pos: the &amp;struct list_head to use as a loop cursor. * @head: the head for your list. */#define list_for_each_prev(pos, head) \\ for (pos = (head)-&gt;prev; pos != (head); pos = pos-&gt;prev) list_for_each_entry_reverse反向遍历得到list,然后获取其宿主结构地址。 12345678910/*** list_for_each_entry_reverse - iterate backwards over list of given type.* @pos: the type * to use as a loop cursor.* @head: the head for your list.* @member: the name of the list_struct within the struct.*/#define list_for_each_entry_reverse(pos, head, member) \\ for (pos = list_entry((head)-&gt;prev, typeof(*pos), member); \\ &amp;pos-&gt;member != (head); \\ pos = list_entry(pos-&gt;member.prev, typeof(*pos), member)) 九、总结本文详细分析了 linux 内核 中的双链表结构，以图文的方式旨在帮助大家理解。 当然还有很多接口限于篇幅没有介绍，本文只列出了常用了接口，相信只要理解了前面双链表的组成和插入过程，后面的删除和遍历就自然而然通了。","tags":["kernel"],"categories":["kernel"]},{"title":"offset_of和container_of宏","path":"/posts/offset-of和container-of宏.html","content":"一、container_of 宏介绍到这里假设大家都懂了 typeof 和 语句表达式，那么我们就开始一睹 Linux 内核第一宏 container_of 的芳容吧： 1234#define offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)#define container_of(ptr, type, member) (&#123; \\ const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr); \\ (type *)( (char *)__mptr - offsetof(type,member) );&#125;) 作为 Linux 内核第一个宏，绝对是实至名归的，看看它外表斯文而内藏八块腹肌的身形，就知道它是不好惹的。宏中有宏，作为 GNU C 高端扩展特性的综合运用，那么它有什么作用呢？它的主要作用是：根据结构体某一成员的地址，获取这个结构体的首地址。 根据宏定义，可知这个宏有三个参数： ptr：结构体内成员 member 的地址 type：结构体类型 member：结构体内的成员 也就是说，当我们知道了一个结构体的类型，结构体内某一成员的地址，也就可以直接获得到这个结构体的首地址。container_of 宏返回的就是这个结构体的首地址。 二、container_of 宏的使用示例这个宏在内核中非常重要。在内核中会经常有这样的需求：我们传递给某个函数的参数是某个结构体的成员变量，然后在这个函数中，可能还会用到此结构体的其它成员变量，那么这个时候怎么办呢？我们可以使用 container_of 先通过结构体某一成员的访问找到这个结构体的首地址，然后就可以访问其它成员变量了。 12345678910111213141516171819struct _box_t&#123; double length; // 盒子的长度 double breadth; // 盒子的宽度 double height; // 盒子的高度&#125;; int main(void)&#123; struct _box_t box = &#123;30.0, 20.0, 10.0&#125;; struct _box_t *p_box = NULL; p_box = container_of(&amp;box.height, struct _box_t, height); printf(&quot;%p &quot;, p_box); printf(&quot;length: %f &quot;, p_box-&gt;length); printf(&quot;breadth: %f &quot;, p_box-&gt;breadth); return 0;&#125; 在这个程序中，我们定义一个结构体变量 box，知道了它的成员变量 height 的地址 &amp;box.height，就可以通过 container_of 宏直接获得 box 结构体变量的首地址，然后直接访问 box 结构体的其它成员 p_box-&gt;length 和 p_box-&gt;breadth。 三、container_of 宏实现原理分析container_of 宏的实现主要用到的知识为：语句表达式和 typeof，再加上结构体存储的基础知识。为了帮助大家更好地理解这个宏，我们先复习下结构体存储的基础知识。 3.1 结构体在内存中的存储我们知道，结构体作为一个复合类型数据，它里面可以有多个成员。当我们定义一个结构体变量时，编译器要给这个变量在内存中分配存储空间。除了考虑数据类型、字节对齐等因素之外，编译器会按照结构体中各个成员的顺序，在内存中分配一片连续的空间来存储它们。 1234567891011121314151617struct _box_t&#123; double length; // 盒子的长度 double breadth; // 盒子的宽度 double height; // 盒子的高度&#125;; int main(void)&#123; struct _box_t box = &#123;30.0, 20.0, 10.0&#125;; printf(&quot;&amp;box = %p &quot;, &amp;box); printf(&quot;&amp;box.length = %p &quot;, &amp;box.length); printf(&quot;&amp;box.breadth = %p &quot;, &amp;box.breadth); printf(&quot;&amp;box.height = %p &quot;, &amp;box.height); return 0;&#125; 在这个程序中，我们定义一个结构体，里面有三个 double 型数据成员，我们定义一个变量，然后分别打印结构体的地址、各个成员变量的地址，运行结果如下： 1234&amp;box = 2b6c3dd0&amp;box.length = 2b6c3dd0&amp;box.breadth = 2b6c3dd8&amp;box.height = 2b6c3de0 从运行结果我们可以看到，结构体中的每个成员变量，从结构体首地址开始，依次存放。每个成员变量相对于结构体首地址，都有一个固定偏移。比如 breadth 相对于结构体首地址偏移了8个字节。height 的存储地址，相对于结构体首地址偏移了16个字节。 3.2 计算成员变量在结构体内的偏移一个结构体数据类型，在同一个编译环境下，各个成员相对于结构体首地址的偏移是固定的。我们可以修改一下上面的程序，当结构体的首地址为 0 时，结构体中的各成员地址在数值上等于结构体各成员相对于结构体首地址的偏移。 123456789101112131415struct _box_t&#123; double length; // 盒子的长度 double breadth; // 盒子的宽度 double height; // 盒子的高度&#125;; int main(void)&#123; printf(&quot;&amp;length = %p &quot;, &amp;((struct _box_t*)0)-&gt;length); printf(&quot;&amp;breadth = %p &quot;, &amp;((struct _box_t*)0)-&gt;breadth); printf(&quot;&amp;height = %p &quot;, &amp;((struct _box_t*)0)-&gt;height); return 0;&#125; 在上面的程序中，我们没有直接定义结构体变量，而是将数字 0 通过强制类型转换，转换为一个指向结构体类型为 _box_t 的常量指针，然后分别打印这个常量指针指向的结构体的各成员地址。运行结果如下： 123&amp;length = ox0&amp;breadth = 0x8&amp;height = 0x10 因为常量指针为 0，即可以看做结构体首地址为 0，所以结构体中每个成员变量的地址即为该成员相对于结构体首地址的偏移。container_of 宏的实现就是使用这个技巧来实现的。 3.3 container_of 宏的原理实现container_of 宏整体的实现原理如图所示： 从语法角度来看，container_of 宏的实现由一个语句表达式构成： 1234#define offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)#define container_of(ptr, type, member) (&#123; \\ const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr); \\ (type *)( (char *)__mptr - offsetof(type,member) );&#125;) 语句表达式的值即为最后一个表达式的值： 1(type *)( (char *)__mptr - offsetof(type,member) ); 以上这个语句的意义就是，拿结构体某个成员 member 的地址，减去这个成员在结构体 type 中的偏移，结果就是结构体 type 的首地址。因为语句表达式的值等于最后一个表达式的值，所以这个结果也是整个语句表达式的值，container_of 最后就会返回这个地址值给宏的调用者。 内核中定义了 offset 宏来计算结构体某个成员在结构体内的偏移，它的定义如下： 1#define offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER) 这个宏有两个参数，一个是结构体类型 TYPE，一个是结构体的成员 MEMBER，它使用的技巧跟我们上面计算 0 地址常量指针的偏移是一样的：将 0 强制转换为一个指向 TYPE 的结构体常量指针，然后通过这个常量指针访问成员，获取成员 MEMBER 的地址，其大小在数值上就等于 MEMBER 在结构体 TYPE 中的偏移。 因为结构体的成员数据类型可以是任意数据类型，所以为了让这个宏兼容各种数据类型。我们定义了一个临时指针变量 __mptr ，该变量用来存储结构体成员 MEMBER 的地址，即存储 ptr 的值。那么如何获取 ptr 指针类型呢？通过下面的方式： 1typeof( ((type *)0)-&gt;member ) *__mptr = (ptr); 以上宏的参数 ptr 代表的是一个结构体成员变量 MEMBER 的地址，所以 ptr 的类型是一个指向 MEMBER 数据类型的指针。为了确保临时变量 __mptr 的指针类型也是一个指向 MEMBER 类型的指针变量，通过 typeof( ((type *)0)-&gt;member ) 表达式，使用 typeof 关键字来获取结构体成员 member 的数据类型，然后使用 typeof( ((type *)0)-&gt;member ) *__mptr 就可以定义一个指向该类型的指针变量了。 注意：在语句表达式的最后，因为返回的是结构体的首地址，所以数据类型还必须强制转换为 TYPE *，即返回一个指向 TYPE 结构体类型的指针，所以你会在最后一个表达的offset宏中看到一个强制类型转换(TYPE *)。 四、总结通过对 container_of 宏的整体分析后，这个过程到底对我们有什么启发呢？ 对于任何一个复杂的技术，我们都可以把它由上而下的逐步分解，然后运用所学的基础知识一点一点剖析：先进行小模块分析，然后再进行综合分析。 比如 container_of 宏的定义，就运用了结构体的存储、语句表达式、typeof 等知识点。 当我们掌握了这些基础知识，并且有了分析方法，以后在内核中再遇到这样类似的宏，我们就可以自信从容地去自己分析，而不必总是依赖网上大海捞针式的搜索了。 这就是你的核心竞争力，也是你超越其他工程师、脱颖而出的机会。 原文链接：https://blog.csdn.net/m0_37383484/article/details/129244244","tags":["kernel"],"categories":["kernel"]},{"title":"mmap","path":"/posts/mmap.html","content":"mmap 即 memory map，也就是内存映射。mmap 是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用 read、write 等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。 mmap原型 12#include &lt;sys/mman.h&gt;void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset) &#x3D;&#x3D;必须注意这里的映射长度length必须是4K整数倍&#x3D;&#x3D; 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/mman.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt; int main() &#123; int my_data; int fd = open(&quot;/dev/mem&quot;, O_RDWR | O_SYNC); if (fd &lt; 0) &#123; perror(&quot;open&quot;); return 1; &#125; unsigned long addr = 0x80000000; // 假设我们要访问的物理地址 unsigned long map_length = 0x1000; // 映射的长度为4KB // 映射内存 void *ptr = mmap(NULL, map_length, PROT_READ | PROT_WRITE, MAP_SHARED, fd, addr &amp; ~(getpagesize() - 1)); // 获取页面对齐基地址，必须以4K对齐 if (ptr == MAP_FAILED) &#123; perror(&quot;mmap&quot;); close(fd); return 1; &#125; my_data = *(int *)(ptr + addr &amp; (getpagesize() - 1)); // 解除内存映射 if (munmap(ptr, map_length) &lt; 0) &#123; perror(&quot;munmap&quot;); close(fd); return 1; &#125; // 关闭文件描述符 close(fd); return 0;&#125;","tags":["C语言"],"categories":["C语言"]},{"title":"gtest","path":"/posts/gtest.html","content":"一、构建gtest执行如下命令后，就会在系统目录下生成对应的头文件和静态库，可以直接在代码中引用了。 1234567git clone git@github.com:google/googletest.git cd googletestmkdir buildcd buildcmake .. makesudo make install 一个小例子 mySrc.h 1234#ifndef UNTITLED_MYSRC_H#define UNTITLED_MYSRC_Hint Foo(int a,int b);#endif //UNTITLED_MYSRC_H mySrc.cpp 12345int Foo(int a, int b) &#123; if (0 == a || 0 == b) throw &quot;don&#x27;t do that&quot;; int c = a % b; if (0 == c) &#123; return b; &#125; return Foo(b, c); &#125;` test.cpp 123456789101112`#include &quot;mySrc.h&quot;#include &quot;gtest/gtest.h&quot;TEST(FooTest, HandleNoneZeroInput) &#123; EXPECT_EQ(2, Foo(4, 10)); EXPECT_EQ(6, Foo(30, 18)); &#125; int main(int argc, char *argv[]) &#123; testing::InitGoogleTest(&amp;argc, argv); return RUN_ALL_TESTS(); &#125; CMakeLists.txt 1234567cmake_minimum_required(VERSION 3.20)project(untitled) set(CMAKE_CXX_STANDARD 11) include_directories(/usr/local/include) add_executable(untitled mySrc.cpp test.cpp) FIND_LIBRARY(gtest libgtest.a /usr/local/lib) target_link_libraries (untitled $&#123;gtest&#125;) 输出信息： 1234567[==========] Running 1 test from 1 test suite. [----------] Global test environment set-up. [----------] 1 test from FooTest [ RUN ] FooTest.HandleNoneZeroInput[ OK ] FooTest.HandleNoneZeroInput (0 ms) [----------] 1 test from FooTest (0 ms total) [----------] Global test environment tear-down [==========] 1 test from 1 test suite ran. (0 ms total) [ PASSED ] 1 test. 上面的是通过事先编译好gtest的方式进行使用，其实也可以在项目的目录下，直接把googletest放进去的方式进行使用 二、assertion在gtest中，是通过断言（assertion）来判断代码实现的功能是否符合预期。断言的结果分为success、non-fatal failture和fatal failture。 根据断言失败的种类，gtest提供了两种断言函数： success：即断言成功，程序的行为符合预期，程序继续向下允许。 non-fatal failure：即断言失败，但是程序没有直接crash，而是继续向下运行。 gtest提供了宏函数EXPECT_XXX(expected, actual)：如果condition(expected, actual)返回false，则EXPECT_XXX产生的就是non-fatal failure错误，并显示相关错误。 fatal failure：断言失败，程序直接crash，后续的测试案例不会被运行。 gtest提供了宏函数ASSERT_XXX(expected, actual)。 在写单元测试时，更加倾向于使用EXPECT_XXX，因为ASSERT_XXX是直接crash退出的，可能会导致一些内存、文件资源没有释放，因此可能会引入一些bug。 具体的EXPECT_XXX、ASSERT_XXX函数及其判断条件，如下两个表。 表1 一元比较 ASSERT EXPECT Verifies ASSERT_TRUE(condition); EXPECT_TRUE(condition); condition is true ASSERT_FALSE(condition) EXPECT_FALSE(condition) condition is false 表2 二元比较 ASSERT EXPECT Condition ASSERT_EQ(val1, val2); EXPECT_EQ(val1, val2); val1 &#x3D;&#x3D; val2 ASSERT_NE(val1, val2); EXPECT_NE(val1, val2); val1 !&#x3D; val2 ASSERT_LT(val1, val2); EXPECT_LT(val1, val2); val1 &lt; val2 ASSERT_LE(val1, val2); EXPECT_LE(val1, val2); val1 &lt;&#x3D; val2 ASSERT_GT(val1, val2); EXPECT_GT(val1, val2); val1 &gt; val2 ASSERT_GE(val1, val2); EXPECT_GE(val1, val2); val1 &gt;&#x3D; val2 三、Quick Start下面以EXPECT_XXX为例子，快速开始使用gtest吧。 对于EXPECT_XXX，无论条件是否满足，都会继续向下运行，但是如果条件不满足，在报错的地方会显示： 没有通过的那个EXPECT_XXX函数位置； EXPECT_XXX第一个参数的值，即期待值 EXPECT_XXX第二个参数的值，即实际值 如下demo： 12345678910// in gtest_demo_1.cc#include &lt;gtest/gtest.h&gt;int add(int lhs, int rhs) &#123; return lhs + rhs; &#125; int main(int argc, char const *argv[]) &#123; EXPECT_EQ(add(1,1), 2); // PASS EXPECT_EQ(add(1,1), 1) &lt;&lt; &quot;FAILED: EXPECT: 2, but given 1&quot;;; // FAILDED return 0; &#125; 编译执行后输出如下： 1234567`$ ./gtest_demo_1 /Users/self_study/Cpp/OpenSource/demo/gtest_demo_1.cc:9: Failure Expected equality of these values: add(1,1) Which is: 2 # 期待的值 1 # 给定的值FAILED: EXPECT: 2, but given 1 # 自己添加的提示信息 可能你注意到了，在EXPECT_EQ(add(1,1), 1)后有个&lt;&lt;，这是因为gtest允许添加自定义的描述信息，当这个语句测试未通过时就会显示，比如上面的”FAILED: EXPECT: 2, but given 1”。 这个&lt;&lt;和std::ostream接受的类型一致，即可以接受std::ostream可以接受的类型。 四、TEST下面以googletest&#x2F;samples中的sample1_unittest.cc中的demo为例，介绍如何更好地组织测试案例。 一个简单计算阶乘函数Factorial实现如下： 1234567int Factorial(int n) &#123; int result = 1; for (int i = 1; i &lt;= n; i++) &#123; result *= i; &#125; return result; &#125; 怎么使用gtest来测试这个函数的行为？ 按照上面的quick start可知，这个时候就可以使用EXPECT_EQ宏来判断： 123EXPECT_EQ(1, Factorial(-5)); // 测试计算负数的阶乘 EXPECT_EQ(1, Factorial(0)); // 测试计算0的阶乘 EXPECT_EQ(6, Factorial(3)); // 测试计算正数的阶乘 但是当测试案例规模变大，不好组织。 因此，为了更好的组织test cases，比如针对Factorial函数，输入是负数的cases为一组，输入是0的case为一组，正数cases为一组。gtest提供了一个宏TEST(TestSuiteName, TestName)，用于组织不同场景的cases，这个功能在gtest中称为test suite。 用法如下： 12345678910111213141516// 下面三个 TEST 都是属于同一个 test suite，即 FactorialTest// 正数为一组TEST(FactorialTest, Negative) &#123; EXPECT_EQ(1, Factorial(-5)); EXPECT_EQ(1, Factorial(-1)); EXPECT_GT(Factorial(-10), 0); &#125; // 0TEST(FactorialTest, Zero) &#123; EXPECT_EQ(1, Factorial(0)); &#125; // 负数为一组TEST(FactorialTest, Positive) &#123; EXPECT_EQ(1, Factorial(1)); EXPECT_EQ(2, Factorial(2)); EXPECT_EQ(6, Factorial(3)); EXPECT_EQ(40320, Factorial(8)); &#125; 问题来了，怎么运行这些TEST？ 在sample1_unittest.cc的main函数中，添加RUN_ALL_TESTS函数即可。 12345int main(int argc, char **argv) &#123; printf(&quot;Running main() from %s &quot;, __FILE__); testing::InitGoogleTest(&amp;argc, argv); return RUN_ALL_TESTS(); &#125; 在build&#x2F;bin路径下，执行对应的可执行文件，输出如下： 12345678$./sample1_unittest Running main() from /Users/self_study/Cpp/OpenSource/demo/include/googletest/googletest/samples/sample1_unittest.cc [==========] Running 6 tests from 2 test suites. # 在 sample1_unittest.cc 中有两个 test suites [----------] Global test environment set-up. # 第一个 test suite，即上面的 FactorialTest [----------] 3 tests from FactorialTest # 3 组 [ RUN ] FactorialTest.Negative # Negative 组输出 [ OK ] FactorialTest.Negative (0 ms) # OK 表示 Negative 组全部测试通过 [ RUN ] FactorialTest.Zero # Zero组输出 [ OK ] FactorialTest.Zero (0 ms) [ RUN ] FactorialTest.Positive # Positive组输出 [ OK ] FactorialTest.Positive (0 ms) [----------] 3 tests from FactorialTest (0 ms total) #sample1_unitest 另一个测试案例的输出 ... [----------] Global test environment tear-down [==========] 6 tests from 2 test suites ran. (0 ms total) [ PASSED ] 6 tests. # 全部测试结果：PASS表示全部通过 下面稍微修改下sample1_unittest.cc中的代码，来产生一个错误： TEST(FactorialTest, Negative) &#123; EXPECT_EQ(10, Factorial(-5)); // 正确的应该是 EXPECT_EQ(1, Factorial(-5)); // ... &#125; 重新编译，运行结果如下： 12345$ ./sample1_unittest Running main() from /Users/self_study/Cpp/OpenSource/demo/include/googletest/googletest/samples/sample1_unittest.cc [==========] Running 6 tests from 2 test suites. [----------] Global test environment set-up. [----------] 3 tests from FactorialTest [ RUN ] FactorialTest.Negative # 开始运行上面修改的那个组 /Users/self_study/Cpp/OpenSource/demo/include/googletest/googletest/samples/sample1_unittest.cc:79: Failure # 测试失败，并指出错误case的位置 Expected equality of these values: # 期待的值 10 Factorial(-5) # 实际计算出的值 Which is: 1 [ FAILED ] FactorialTest.Negative (0 ms) # 这组case测试状态：FAILED [ RUN ] FactorialTest.Zero # 下面继续运行 [ OK ] FactorialTest.Zero (0 ms) [ RUN ] FactorialTest.Positive [ OK ] FactorialTest.Positive (0 ms) [----------] 3 tests from FactorialTest (0 ms total) # ... [----------] Global test environment tear-down [==========] 6 tests from 2 test suites ran. (0 ms total) [ PASSED ] 5 tests. [ FAILED ] 1 test, listed below: # 1个test失败 [ FAILED ] FactorialTest.Negative # 失败的test suite及其组 1 FAILED TEST 此外，在TEST宏函数中，也可以像个普通函数一样，定义变量之类的行为。 比如在sample2_unittest.cc中，测试一个自定义类MyString的复制构造函数是否表现正常： 12345const char kHelloString[] = &quot;Hello, world!&quot;; // 在 TEST内部，定义变量TEST(MyString, CopyConstructor) &#123; const MyString s1(kHelloString); const MyString s2 = s1; EXPECT_EQ(0, strcmp(s2.c_string(), kHelloString)); &#125; 为获得进一步学习，读者可以自行调整sample1_unittest.cc、sample2_unittest.cc中的TEST行为，加深对gtest的TEST宏的理解。 五、TEST_F下面介绍gtest中更为高级的功能：test fixture，对应的宏函数是TEST_F(TestFixtureName, TestName)。 fixture，其语义是固定的设施，而test fixture在gtest中的作用就是为每个TEST都执行一些同样的操作。 比如，要测试一个队列Queue的各个接口功能是否正常，因此就需要向队列中添加元素。如果使用一个TEST函数测试Queue的一个接口，那么每次执行TEST时，都需要在TEST宏函数中定义一个Queue对象，并向该对象中添加元素，就很冗余、繁琐。 怎么避免这部分冗余的过程？ TEST_F就是完成这样的事情，它的第一个参数TestFixtureName是个类，需要继承testing::Test，同时根据需要实现以下两个虚函数： virtual void SetUp()：在TEST_F中测试案例之前运行； virtual void TearDown()：在TEST_F之后运行。 可以类比对象的构造函数和析构函数。这样，同一个TestFixtureName下的每个TEST_F都会先执行SetUp，最后执行TearDwom。 此外，testing::Test还提供了两个static函数： static void SetUpTestSuite()：在第一个TEST之前运行 static void TearDownTestSuite()：在最后一个TEST之后运行 以sample3-inl中实现的class Queue为例： 123456789101112131415161718192021222324252627282930313233343536373839class QueueTestSmpl3 : public testing::Test &#123; // 继承了 testing::Test protected: static void SetUpTestSuite() &#123; std::cout&lt;&lt;&quot;run before first case...&quot;&lt;&lt;std::endl; &#125; static void TearDownTestSuite() &#123; std::cout&lt;&lt;&quot;run after last case...&quot;&lt;&lt;std::endl; &#125; virtual void SetUp() override &#123; std::cout&lt;&lt;&quot;enter into SetUp()&quot; &lt;&lt;std::endl; q1_.Enqueue(1); q2_.Enqueue(2); q2_.Enqueue(3); &#125; virtual void TearDown() override &#123; std::cout&lt;&lt;&quot;exit from TearDown&quot; &lt;&lt;std::endl; &#125; static int Double(int n) &#123; return 2*n; &#125; void MapTester(const Queue&lt;int&gt; * q) &#123; const Queue&lt;int&gt; * const new_q = q-&gt;Map(Double); ASSERT_EQ(q-&gt;Size(), new_q-&gt;Size()); for (const QueueNode&lt;int&gt;*n1 = q-&gt;Head(), *n2 = new_q-&gt;Head(); n1 != nullptr; n1 = n1-&gt;next(), n2 = n2-&gt;next()) &#123; EXPECT_EQ(2 * n1-&gt;element(), n2-&gt;element()); &#125; delete new_q; &#125; Queue&lt;int&gt; q0_; Queue&lt;int&gt; q1_; Queue&lt;int&gt; q2_; &#125;; 下面是sample3_unittest.cc中的TEST_F： 12345678910111213141516171819202122232425262728// in sample3_unittest.cc// Tests the default c&#x27;tor.TEST_F(QueueTestSmpl3, DefaultConstructor) &#123; // !!! 在 TEST_F 中可以使用 QueueTestSmpl3 的成员变量、成员函数 EXPECT_EQ(0u, q0_.Size()); &#125; // Tests Dequeue().TEST_F(QueueTestSmpl3, Dequeue) &#123; int * n = q0_.Dequeue(); EXPECT_TRUE(n == nullptr); n = q1_.Dequeue(); ASSERT_TRUE(n != nullptr); EXPECT_EQ(1, *n); EXPECT_EQ(0u, q1_.Size()); delete n; n = q2_.Dequeue(); ASSERT_TRUE(n != nullptr); EXPECT_EQ(2, *n); EXPECT_EQ(1u, q2_.Size()); delete n; &#125; // Tests the Queue::Map() function.TEST_F(QueueTestSmpl3, Map) &#123; MapTester(&amp;q0_); MapTester(&amp;q1_); MapTester(&amp;q2_); &#125; 以TEST_F(QueueTestSmpl3, DefaultConstructor)为例，再具体讲解下TEST_F的运行流程： gtest构造一个QueueTestSmpl3对象t1； t1.setUp初始化t1 第一个TEST_F即DefaultConstructor开始运行并结束 t1.TearDwon运行，用于清理工作 t1被析构 因此，sample3_unittest.cc输出如下： 123456789% ./sample3_unittest Running main() from /Users/self_study/Cpp/OpenSource/demo/include/googletest/googletest/samples/sample3_unittest.cc [==========] Running 3 tests from 1 test suite. [----------] Global test environment set-up. [----------] 3 tests from QueueTestSmpl3 run before first case... # 所有的test case 之前运行 [ RUN ] QueueTestSmpl3.DefaultConstructor enter into SetUp() # 每次都会运行 exit from TearDown [ OK ] QueueTestSmpl3.DefaultConstructor (0 ms) [ RUN ] QueueTestSmpl3.Dequeue enter into SetUp() # 每次都会运行 exit from TearDown [ OK ] QueueTestSmpl3.Dequeue (0 ms) [ RUN ] QueueTestSmpl3.Map enter into SetUp() # 每次都会运行 exit from TearDown [ OK ] QueueTestSmpl3.Map (0 ms) run after last case... # 所有test case结束之后运行 [----------] 3 tests from QueueTestSmpl3 (0 ms total) [----------] Global test environment tear-down [==========] 3 tests from 1 test suite ran. (0 ms total) [ PASSED ] 3 tests. TEST_F相比较TEST可以更加简洁地实现功能测试。 gtest的基础入门教程就到此为止 六、MOCKER对打桩的函数，使用MOCKER，可以按照预期值返回 示例： 12345678910111213#include &quot;gtest/gtest.h&quot;#include &quot;mockercpp/mockercpp.hpp&quot;TEST_F(QueueTestSmpl3, xxx_test)&#123; MOCKER(hal_kernel_get_soc_type) .stub() .with(any(), outBoundP()) .will(return (0)); xxx_test(); GlobalMockObject::verify();&#125; C++中MOCKER类中的函数可以使用MOCKERCPP GlobalMockObject::verify();是验证mock是否正常按照预期传入参数，清除后续mocker","tags":["C语言"],"categories":["C语言"]},{"title":"poll、epoll","path":"/posts/poll、epoll.html","content":"一、poll介绍poll与select一样，只负责IO的等的过程，只不过一次可以等待多个文件描述符，他的作用是让read和write不再阻塞。 是用来监视多个文件描述符的状态变化的程序会停在poll这里等待，直到被监视的文件描述符有一个或多个发生了状态改变 二、poll的接口poll的接口如下，比select要轻量化很多，只有三个参数 123456789101112131415161718参数1：struct pollfd *fds，pollfd数组首元素地址， pollfd是操作系统给我们提供的结构体，主要成员如下 fd：文件描述符 events：用户告诉内核，需要关心的fd，上面的事件 revents：poll返回，内核告诉用户，关心的fd，那些事件就绪参数2：nfds_t nfds，数组元素个数参数3：int timeout，毫秒级的等待时间timeout &gt; 0 等待timeout毫秒或者有fd就绪再返回。timeout == 0 非阻塞轮询。timeout == -1 阻塞等待，直到有fd就绪。返回值：ret &gt; 0 ：poll等待的多个fd中，已经就需要的fd个数ret == 0 ：poll超时返回ret &lt; 0 ：poll出错 poll的事件如下，这些值是bit位，可以通过 |（或运算） 的方式写入到events中，我们着重学习POLLIN和POLLOUT 三、poll使用例子Log.hpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#pragma once #include &lt;iostream&gt;#include &lt;cstdarg&gt;#include &lt;unistd.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;#include &lt;pthread.h&gt;using namespace std; enum&#123; Debug = 0, Info, Warning, Error, Fatal&#125;; enum&#123; Screen = 10, OneFile, ClassFile&#125;; string LevelToString(int level)&#123; switch (level) &#123; case Debug: return &quot;Debug&quot;; case Info: return &quot;Info&quot;; case Warning: return &quot;Warning&quot;; case Error: return &quot;Error&quot;; case Fatal: return &quot;Fatal&quot;; default: return &quot;Unknown&quot;; &#125;&#125; const int default_style = Screen;const string default_filename = &quot;Log.&quot;;const string logdir = &quot;log&quot;; class Log&#123;public: Log(int style = default_style, string filename = default_filename) : _style(style), _filename(filename) &#123; if (_style != Screen) mkdir(logdir.c_str(), 0775); &#125; // 更改打印方式 void Enable(int style) &#123; _style = style; if (_style != Screen) mkdir(logdir.c_str(), 0775); &#125; // 时间戳转化为年月日时分秒 string GetTime() &#123; time_t currtime = time(nullptr); struct tm *curr = localtime(&amp;currtime); char time_buffer[128]; snprintf(time_buffer, sizeof(time_buffer), &quot;%d-%d-%d %d:%d:%d&quot;, curr-&gt;tm_year + 1900, curr-&gt;tm_mon + 1, curr-&gt;tm_mday, curr-&gt;tm_hour, curr-&gt;tm_min, curr-&gt;tm_sec); return time_buffer; &#125; // 写入到文件中 void WriteLogToOneFile(const string &amp;logname, const string &amp;message) &#123; FILE *fp = fopen(logname.c_str(), &quot;a&quot;); if (fp == nullptr) &#123; perror(&quot;fopen failed&quot;); exit(-1); &#125; fprintf(fp, &quot;%s &quot;, message.c_str()); fclose(fp); &#125; // 打印日志 void WriteLogToClassFile(const string &amp;levelstr, const string &amp;message) &#123; string logname = logdir; logname += &quot;/&quot;; logname += _filename; logname += levelstr; WriteLogToOneFile(logname, message); &#125; pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER; void WriteLog(const string &amp;levelstr, const string &amp;message) &#123; pthread_mutex_lock(&amp;lock); switch (_style) &#123; case Screen: cout &lt;&lt; message &lt;&lt; endl; // 打印到屏幕中 break; case OneFile: WriteLogToClassFile(&quot;all&quot;, message); // 给定all，直接写到all里 break; case ClassFile: WriteLogToClassFile(levelstr, message); // 写入levelstr里 break; default: break; &#125; pthread_mutex_unlock(&amp;lock); &#125; // 提供接口给运算符重载使用 void _LogMessage(int level, const char *file, int line, char *rightbuffer) &#123; char leftbuffer[1024]; string levelstr = LevelToString(level); string currtime = GetTime(); string idstr = to_string(getpid()); snprintf(leftbuffer, sizeof(leftbuffer), &quot;[%s][%s][%s][%s:%d]&quot;, levelstr.c_str(), currtime.c_str(), idstr.c_str(), file, line); string messages = leftbuffer; messages += rightbuffer; WriteLog(levelstr, messages); &#125; // 运算符重载 void operator()(int level, const char *file, int line, const char *format, ...) &#123; char rightbuffer[1024]; va_list args; // va_list 是指针 va_start(args, format); // 初始化va_list对象，format是最后一个确定的参数 vsnprintf(rightbuffer, sizeof(rightbuffer), format, args); // 写入到rightbuffer中 va_end(args); _LogMessage(level, file, line, rightbuffer); &#125; ~Log() &#123; &#125; private: int _style; string _filename;&#125;; Log lg; class Conf&#123;public: Conf() &#123; lg.Enable(Screen); &#125; ~Conf() &#123; &#125;&#125;; Conf conf; // 辅助宏#define lg(level, format, ...) lg(level, __FILE__, __LINE__, format, ##__VA_ARGS__) Socket.hpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170#pragma once #include &lt;iostream&gt;#include &lt;string&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;cstring&gt;#include &lt;unistd.h&gt;using namespace std;namespace Net_Work&#123; static const int default_backlog = 5; static const int default_sockfd = -1; using namespace std; enum &#123; SocketError = 1, BindError, ListenError, ConnectError, &#125;; // 封装套接字接口基类 class Socket &#123; public: // 封装了socket相关方法 virtual ~Socket() &#123;&#125; virtual void CreateSocket() = 0; virtual void BindSocket(uint16_t port) = 0; virtual void ListenSocket(int backlog) = 0; virtual bool ConnectSocket(string &amp;serverip, uint16_t serverport) = 0; virtual int AcceptSocket(string *peerip, uint16_t *peerport) = 0; virtual int GetSockFd() = 0; virtual void SetSockFd(int sockfd) = 0; virtual void CloseSocket() = 0; virtual bool Recv(string *buff, int size) = 0; virtual void Send(string &amp;send_string) = 0; // 方法的集中在一起使用 public: void BuildListenSocket(uint16_t port, int backlog = default_backlog) &#123; CreateSocket(); BindSocket(port); ListenSocket(backlog); &#125; bool BuildConnectSocket(string &amp;serverip, uint16_t serverport) &#123; CreateSocket(); return ConnectSocket(serverip, serverport); &#125; void BuildNormalSocket(int sockfd) &#123; SetSockFd(sockfd); &#125; &#125;; class TcpSocket : public Socket &#123; public: TcpSocket(int sockfd = default_sockfd) : _sockfd(sockfd) &#123; &#125; ~TcpSocket() &#123;&#125; void CreateSocket() override &#123; _sockfd = socket(AF_INET, SOCK_STREAM, 0); if (_sockfd &lt; 0) exit(SocketError); &#125; void BindSocket(uint16_t port) override &#123; int opt = 1; setsockopt(_sockfd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &amp;opt, sizeof(opt)); struct sockaddr_in local; memset(&amp;local, 0, sizeof(local)); local.sin_family = AF_INET; local.sin_port = htons(port); local.sin_addr.s_addr = INADDR_ANY; int n = bind(_sockfd, (struct sockaddr *)&amp;local, sizeof(local)); if (n &lt; 0) exit(BindError); &#125; void ListenSocket(int backlog) override &#123; int n = listen(_sockfd, backlog); if (n &lt; 0) exit(ListenError); &#125; bool ConnectSocket(string &amp;serverip, uint16_t serverport) override &#123; struct sockaddr_in addr; memset(&amp;addr, 0, sizeof(addr)); addr.sin_family = AF_INET; addr.sin_port = htons(serverport); // addr.sin_addr.s_addr = inet_addr(serverip.c_str()); inet_pton(AF_INET, serverip.c_str(), &amp;addr.sin_addr); int n = connect(_sockfd, (sockaddr *)&amp;addr, sizeof(addr)); if (n == 0) return true; return false; &#125; int AcceptSocket(string *peerip, uint16_t *peerport) override &#123; struct sockaddr_in addr; socklen_t len = sizeof(addr); int newsockfd = accept(_sockfd, (sockaddr *)&amp;addr, &amp;len); if (newsockfd &lt; 0) return -1; // *peerip = inet_ntoa(addr.sin_addr); // INET_ADDRSTRLEN 是一个定义在头文件中的宏，表示 IPv4 地址的最大长度 char ip_str[INET_ADDRSTRLEN]; inet_ntop(AF_INET, &amp;addr.sin_addr, ip_str, INET_ADDRSTRLEN); *peerip = ip_str; *peerport = ntohs(addr.sin_port); return newsockfd; &#125; int GetSockFd() override &#123; return _sockfd; &#125; void SetSockFd(int sockfd) override &#123; _sockfd = sockfd; &#125; void CloseSocket() override &#123; if (_sockfd &gt; default_sockfd) close(_sockfd); &#125; bool Recv(string *buff, int size) override &#123; char inbuffer[size]; ssize_t n = recv(_sockfd, inbuffer, size - 1, 0); if (n &gt; 0) &#123; inbuffer[n] = 0; *buff += inbuffer; return true; &#125; else return false; &#125; void Send(string &amp;send_string) override &#123; send(_sockfd, send_string.c_str(),send_string.size(),0); &#125; private: int _sockfd; string _ip; uint16_t _port; &#125;;&#125; PollServer.hpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162#pragma once#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;poll.h&gt;#include &lt;memory&gt;#include &quot;Log.hpp&quot;#include &quot;Socket.hpp&quot; using namespace Net_Work;const static int gdefaultport = 8888;const static int gbacklog = 8;const static int gnum = 1024;class PollServer&#123;public: PollServer(int port) : _port(port), _num(gnum), _listensock(new TcpSocket()) &#123; &#125; void HandlerEvent() &#123; for (int i = 0; i &lt; _num; i++) &#123; if (_rfds[i].fd == -1) continue; int fd = _rfds[i].fd; short revents = _rfds[i].revents; // 判断事件是否就绪 if (revents &amp; POLLIN) &#123; // 读事件分两类，一类是新链接到来，一类是新数据到来 if (fd == _listensock-&gt;GetSockFd()) &#123; // 新链接到来 lg(Info, &quot;get a new link&quot;); // 获取连接 std::string clientip; uint16_t clientport; int sockfd = _listensock-&gt;AcceptSocket(&amp;clientip, &amp;clientport); if (sockfd == -1) &#123; lg(Error, &quot;accept error&quot;); continue; &#125; lg(Info, &quot;get a client,client info is# %s:%d,fd: %d&quot;, clientip.c_str(), clientport, sockfd); // 此时获取连接成功了，但是不能直接read write,sockfd仍需要交给poll托管 -- 添加到数组_rfds中 int pos = 0; for (; pos &lt; _num; pos++) &#123; if (_rfds[pos].fd == -1) &#123; _rfds[pos].fd = sockfd; _rfds[pos].events = POLLIN; lg(Info, &quot;get a new link, fd is : %d&quot;, sockfd); break; &#125; &#125; if (pos == _num) &#123; // 1.扩容 // 2.关闭 close(sockfd); lg(Warning, &quot;server is full, be carefull...&quot;); &#125; &#125; else &#123; // 普通的读事件就绪 char buffer[1024]; ssize_t n = recv(fd, buffer, sizeof(buffer-1), 0); if (n &gt; 0) &#123; buffer[n] = 0; lg(Info, &quot;client say# %s&quot;, buffer); std::string message = &quot;你好,同志&quot;; message += buffer; send(fd, message.c_str(), message.size(), 0); &#125; else &#123; lg(Warning, &quot;client quit ,maybe close or error,close fd: %d&quot;, fd); close(fd); // 还要取消poll的关心 _rfds[i].fd = -1; _rfds[i].events = 0; _rfds[i].revents = 0; &#125; &#125; &#125; &#125; &#125; void InitServer() &#123; _listensock-&gt;BuildListenSocket(_port, gbacklog); _rfds = new struct pollfd[_num]; for (int i = 0; i &lt; _num; i++) &#123; _rfds[i].fd = -1; _rfds[i].events = 0; _rfds[i].revents = 0; &#125; // 最开始的时候，只有一个文件描述符，Listensock _rfds[0].fd = _listensock-&gt;GetSockFd(); _rfds[0].events |= POLLIN; &#125; void Loop() &#123; _isrunning = true; // 循环重置select需要的rfds while (_isrunning) &#123; // 定义时间 int timeout = 1000; //PrintDebug(); // rfds是输入输出型参数，rfds是在select调用返回时，不断被修改，所以每次需要重置rfds int n = poll(_rfds, _num, timeout); switch (n) &#123; case 0: lg(Info, &quot;select timeout...&quot;); break; case -1: lg(Error, &quot;select error!!!&quot;); default: // 正常就绪的fd lg(Info, &quot;select success,begin event handler&quot;); HandlerEvent(); break; &#125; &#125; _isrunning = false; &#125; void Stop() &#123; _isrunning = false; &#125; void PrintDebug() &#123; // std::cout &lt;&lt; &quot;current select rfds list is :&quot;; // for (int i = 0; i &lt; num; i++) // &#123; // if (_rfds_array[i] == nullptr) // continue; // else // std::cout &lt;&lt; _rfds_array[i]-&gt;GetSockFd() &lt;&lt; &quot; &quot;; // &#125; // std::cout &lt;&lt; std::endl; &#125; private: std::unique_ptr&lt;Socket&gt; _listensock; int _port; bool _isrunning; struct pollfd *_rfds; int _num;&#125;; Main.cc 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;memory&gt;#include &quot;PollServer.hpp&quot; void Usage(char* argv)&#123; std::cout&lt;&lt;&quot;Usage: \\t&quot;&lt;&lt;argv&lt;&lt;&quot; port &quot;&lt;&lt;std::endl;&#125;// ./select_server 8080int main(int argc,char* argv[])&#123; // std::cout&lt;&lt;num&lt;&lt;std::endl; 1024 if(argc!=2) &#123; Usage(argv[0]); return -1; &#125; uint16_t localport = std::stoi(argv[1]); std::unique_ptr&lt;PollServer&gt; svr = std::make_unique&lt;PollServer&gt;(localport); svr-&gt;InitServer(); svr-&gt;Loop(); return 0;&#125; 运行结果如下，由于我们poll第三个参数设置的是1000ms，因此每一秒poll都会返回，当发现有新链接的时候，就回去执行函数，在函数中调用write或者read变不会再阻塞了。","tags":["C语言"],"categories":["C语言"]},{"title":"进程间通信","path":"/posts/进程间通信.html","content":"一、什么是消息队列消息队列提供了一种从一个进程向另一个进程发送一个数据块的方法。 每个数据块都被认为含有一个类型，接收进程可以独立地接收含有不同类型的数据结构。我们可以通过发送消息来避免命名管道的同步和阻塞问题。但是消息队列与命名管道一样，每个数据块都有一个最大长度的限制。 Linux用宏MSGMAX和MSGMNB来限制一条消息的最大长度和一个队列的最大长度。 二、在Linux中使用消息队列Linux提供了一系列消息队列的函数接口来让我们方便地使用它来实现进程间的通信。它的用法与其他两个System V PIC机制，即信号量和共享内存相似。 1、msgget函数该函数用来创建和访问一个消息队列。它的原型为： int msgget(key_t, key, int msgflg); 与其他的IPC机制一样，程序必须提供一个键来命名某个特定的消息队列。msgflg是一个权限标志，表示消息队列的访问权限，它与文件的访问权限一样。msgflg可以与IPC_CREAT做或操作，表示当key所命名的消息队列不存在时创建一个消息队列，如果key所命名的消息队列存在时，IPC_CREAT标志会被忽略，而只返回一个标识符。 它返回一个以key命名的消息队列的标识符（非零整数），失败时返回-1. 2、msgsnd函数该函数用来把消息添加到消息队列中。它的原型为： int msgsend(int msgid, const void *msg_ptr, size_t msg_sz, int msgflg); msgid是由msgget函数返回的消息队列标识符。 msg_ptr是一个指向准备发送消息的指针，但是消息的数据结构却有一定的要求，指针msg_ptr所指向的消息结构一定要是以一个长整型成员变量开始的结构体，接收函数将用这个成员来确定消息的类型。所以消息结构要定义成这样： 1234struct my_message&#123; long int message_type; /* The data you wish to transfer*/ &#125;; msg_sz是msg_ptr指向的消息的长度，注意是消息的长度，而不是整个结构体的长度，也就是说msg_sz是不包括长整型消息类型成员变量的长度。 msgflg用于控制当前消息队列满或队列消息到达系统范围的限制时将要发生的事情。 如果调用成功，消息数据的一分副本将被放到消息队列中，并返回0，失败时返回-1. 3、msgrcv函数该函数用来从一个消息队列获取消息，它的原型为 int msgrcv(int msgid, void *msg_ptr, size_t msg_st, long int msgtype, int msgflg); msgid, msg_ptr, msg_st的作用也函数msgsnd函数的一样。 msgtype可以实现一种简单的接收优先级。如果msgtype为0，就获取队列中的第一个消息。如果它的值大于零，将获取具有相同消息类型的第一个信息。如果它小于零，就获取类型等于或小于msgtype的绝对值的第一个消息。 msgflg用于控制当队列中没有相应类型的消息可以接收时将发生的事情。 调用成功时，该函数返回放到接收缓存区中的字节数，消息被复制到由msg_ptr指向的用户分配的缓存区中，然后删除消息队列中的对应消息。失败时返回-1. 4、msgctl函数该函数用来控制消息队列，它与共享内存的shmctl函数相似，它的原型为： int msgctl(int msgid, int command, struct msgid_ds *buf); command是将要采取的动作，它可以取3个值， IPC_STAT：把msgid_ds结构中的数据设置为消息队列的当前关联值，即用消息队列的当前关联值覆盖msgid_ds的值。 IPC_SET：如果进程有足够的权限，就把消息列队的当前关联值设置为msgid_ds结构中给出的值 IPC_RMID：删除消息队列 buf是指向msgid_ds结构的指针，它指向消息队列模式和访问权限的结构。msgid_ds结构至少包括以下成员： 123456struct msgid_ds &#123; uid_t shm_perm.uid; uid_t shm_perm.gid; mode_t shm_perm.mode; &#125;; 成功时返回0，失败时返回-1. 三、使用消息队列进行进程间通信马不停蹄，介绍完消息队列的定义和可使用的接口之后，我们来看看它是怎么让进程进行通信的。由于可以让不相关的进程进行行通信，所以我们在这里将会编写两个程序，msgreceive和msgsned来表示接收和发送信息。根据正常的情况，我们允许两个程序都可以创建消息，但只有接收者在接收完最后一个消息之后，它才把它删除。 接收信息的程序源文件为msgreceive.c的源代码为： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;unistd.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;errno.h&gt; #include &lt;sys/msg.h&gt; struct msg_st &#123; long int msg_type; char text[BUFSIZ]; &#125;; int main() &#123; int running = 1; int msgid = -1; struct msg_st data; long int msgtype = 0; //注意1 //建立消息队列 msgid = msgget((key_t)1234, 0666 | IPC_CREAT); if(msgid == -1) &#123; fprintf(stderr, &quot;msgget failed with error: %d &quot;, errno); exit(EXIT_FAILURE); &#125; //从队列中获取消息，直到遇到end消息为止 while(running) &#123; if(msgrcv(msgid, (void*)&amp;data, BUFSIZ, msgtype, 0) == -1) &#123; fprintf(stderr, &quot;msgrcv failed with errno: %d &quot;, errno); exit(EXIT_FAILURE); &#125; printf(&quot;You wrote: %s &quot;,data.text); //遇到end结束 if(strncmp(data.text, &quot;end&quot;, 3) == 0) running = 0; &#125; //删除消息队列 if(msgctl(msgid, IPC_RMID, 0) == -1) &#123; fprintf(stderr, &quot;msgctl(IPC_RMID) failed &quot;); exit(EXIT_FAILURE); &#125; exit(EXIT_SUCCESS); &#125; 发送信息的程序的源文件msgsend.c的源代码为： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;unistd.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;sys/msg.h&gt; #include &lt;errno.h&gt; #define MAX_TEXT 512 struct msg_st &#123; long int msg_type; char text[MAX_TEXT]; &#125;; int main() &#123; int running = 1; struct msg_st data; char buffer[BUFSIZ]; int msgid = -1; //建立消息队列 msgid = msgget((key_t)1234, 0666 | IPC_CREAT); if(msgid == -1) &#123; fprintf(stderr, &quot;msgget failed with error: %d &quot;, errno); exit(EXIT_FAILURE); &#125; //向消息队列中写消息，直到写入end while(running) &#123; //输入数据 printf(&quot;Enter some text: &quot;); fgets(buffer, BUFSIZ, stdin); data.msg_type = 1; //注意2 strcpy(data.text, buffer); //向队列发送数据 if(msgsnd(msgid, (void*)&amp;data, MAX_TEXT, 0) == -1) &#123; fprintf(stderr, &quot;msgsnd failed &quot;); exit(EXIT_FAILURE); &#125; //输入end结束输入 if(strncmp(buffer, &quot;end&quot;, 3) == 0) running = 0; sleep(1); &#125; exit(EXIT_SUCCESS); &#125; 四、例子分析——消息类型这里主要说明一下消息类型是怎么一回事，注意msgreceive.c文件main函数中定义的变量msgtype（注释为注意1），它作为msgrcv函数的接收信息类型参数的值，其值为0，表示获取队列中第一个可用的消息。再来看看msgsend.c文件中while循环中的语句data.msg_type &#x3D; 1（注释为注意2），它用来设置发送的信息的信息类型，即其发送的信息的类型为1。所以程序msgreceive能够接收到程序msgsend发送的信息。 如果把注意1，即msgreceive.c文件main函数中的语句由 long int msgtype &#x3D; 0;改变为long int msgtype &#x3D; 2;会发生什么情况，msgreceive将不能接收到程序msgsend发送的信息。因为在调用msgrcv函数时，如果msgtype（第四个参数）大于零，则将只获取具有相同消息类型的第一个消息，修改后获取的消息类型为2，而msgsend发送的消息类型为1，所以不能被msgreceive程序接收。重新编译msgreceive.c文件并再次执行 我们可以看到，msgreceive并没有接收到信息和输出，而且当msgsend输入end结束后，msgreceive也没有结束，通过jobs命令我们可以看到它还在后台运行着。 五、消息队列与命名管道的比较消息队列跟命名管道有不少的相同之处，通过与命名管道一样，消息队列进行通信的进程可以是不相关的进程，同时它们都是通过发送和接收的方式来传递数据的。在命名管道中，发送数据用write，接收数据用read，则在消息队列中，发送数据用msgsnd，接收数据用msgrcv。而且它们对每个数据都有一个最大长度的限制。 与命名管道相比，消息队列的优势在于， 1、消息队列也可以独立于发送和接收进程而存在，从而消除了在同步命名管道的打开和关闭时可能产生的困难。 2、同时通过发送消息还可以避免命名管道的同步和阻塞问题，不需要由进程自己来提供同步方法。 3、接收程序可以通过消息类型有选择地接收数据，而不是像命名管道中那样，只能默认地接收。","tags":["C语言"],"categories":["C语言"]},{"title":"锁、信号量","path":"/posts/锁、信号量.html","content":"一、信号量线程的信号量与进程间通信中使用的信号量的概念是一样，它是一种特殊的变量，它可以被增加或减少，但对其的关键访问被保证是原子操作。如果一个程序中有多个线程试图改变一个信号量的值，系统将保证所有的操作都将依次进行。 而只有0和1两种取值的信号量叫做二进制信号量，在这里将重点介绍。而信号量一般常用于保护一段代码，使其每次只被一个执行线程运行。我们可以使用二进制信号量来完成这个工作。 C语言中的信号量分为两种，POSIX信号量和Syetem -V信号量 二、POSIX信号量信号量的函数都以sem_开头，线程中使用的基本信号量函数有4个，它们都声明在头文件semaphore.h中。 1、sem_init函数该函数用于创建信号量，其原型如下 int sem_init(sem_t *sem,int pshared,unsigned int value); 该函数初始化由sem指向的信号对象，设置它的共享选项，并给它一个初始的整数值。pshared控制信号量的类型，如果其值为0，就表示这个信号量是当前进程的局部信号量，否则信号量就可以在多个进程之间共享，value为sem的初始值。调用成功时返回0，失败返回-1. 2、sem_wait函数该函数用于以原子操作的方式将信号量的值减1。原子操作就是，如果两个线程企图同时给一个信号量加1或减1，它们之间不会互相干扰。它的原型如下： int sem_wait(sem_t *sem); 等待信号量，如果信号量的值大于0，将信号量的值减1，立即返回。如果信号量的值为0，则线程阻塞。相当于P操作。成功返回0，失败返回-1。sem指向的对象是由sem_init调用初始化的信号量。 3、 sem_post函数该函数用于以原子操作的方式将信号量的值加1。它的原型如下： int sem_post(sem_t *sem); 释放信号量，让信号量的值加1。相当于V操作。与sem_wait一样，sem指向的对象是由sem_init调用初始化的信号量。调用成功时返回0，失败返回-1. 4、sem_destroy函数该函数用于对用完的信号量的清理。它的原型如下： int sem_destroy(sem_t *sem); 成功时返回0，失败时返回-1. 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;pthread.h&gt;#include &lt;semaphore.h&gt; sem_t sem; void func1(void* arg) &#123; sem_wait(&amp;sem); int *running=arg; printf(&quot;thread running1 &quot;); printf(&quot;%d &quot;,*running); &#125; void func2(void* arg) &#123; printf(&quot;pthread2 running &quot;); sem_post(&amp;sem); &#125; int main() &#123; sem_init(&amp;sem,0,0); pthread_t thread[2]; int a=5; pthread_create(&amp;(thread[0]),NULL,(void*)func1,(void*)&amp;a); printf(&quot;main thread running &quot;); sleep(10); pthread_create(&amp;(thread[1]),NULL,(void*)func2,(void*)&amp;a); printf(&quot;main thread running2 &quot;); pthread_join(thread[0],NULL); pthread_join(thread[1],NULL); sem_destroy(&amp;sem); return 0; &#125; 首先创建信号量，第二个参数为0，表示这个信号量是当前进程的局部信号量，初始值为0。 然后使用pthread_create()函数创建两个线程，传入参数a。 线程1创建完成后，由于信号量初始化value&#x3D;0，调用sem_wait会阻塞这个线程，信号量的值将减少1（此时&lt;0），这个线程函数就会等待。 主线程sleep(10)后，线程2创建并执行调用，sem_post用于使信号量的值增加1，此时线程1可以执行。 使用pthread_join等待所创建的两个线程的结束。 以上代码输出为： 12345main thread runningmain thread running2pthread2 runningthread running15 可以用来做线程同步使用，比如升级流程代码中，可以在升级的初始化代码中使用sem_wait，最终被阻塞在那里，而用户执行升级命令的流程中才会执行到sem_post函数，从而触发到sem_wait后面的流程继续执行。 三、System -V信号量1、创建SEM功能：获取信号量ID int semget(key_t key,int nsems,int semflg); 返回值：成功：信号量ID失败：-1参数：key：信号量的键值nsems：信号量元素的个数semflg：创建选项IPC_CREAT：如果key对应的信号量不存在，则创建IPC_EXCL：如果key对应的信号量存在，则报错mode：信号量的访问权限创建信号量时，还受到以下系统信息的影响 SEMMNI：系统中信号量的总数最大值SEMMSL：每个信号量中信号量元素的个数最大值SEMMNS：系统中素有信号量中的信号量元素的总数最大值实例代码： 12345int main(void) &#123; key_t key = ftok(&quot;.&quot;,1); int semid = semget(key,2,IPC_CREATE|0666); &#125; 2、PV操作功能：对信号量进行PV操作，或者等零操作 int semop(int semid,struct sembuf sops[],unsigned nsops); 返回值：成功：0失败：-1 参数：semid：信号量IDsops：信号量操作结构体数组nsops结果体数组元素个数信号量操作结构体 12345struct sembuf &#123; unsigned short sem_num;//信号量元素序号 short sem_op;//操作参数 short sem_flg;//操作选项 &#125; 根据sem_op的值，信号量操作分为3中情况：sem_op&gt;0：V操作sem_op&#x3D;0：等零操作sem_op示例代码 12345678910111213int main() &#123; key_t key = ftok(&quot;.&quot;, 1); // 创建（若已有则打开）一个包含2个元素的信号量组 int id = semget(key, 2, IPC_CREAT|0666); // 定义包含两个P/V操作的结构体数组 struct sembuf op[2]; op[0].sem_num = 0; // 信号量元素序号 op[0].sem_op = -2; // P操作 op[0].sem_num = 0; // 选项默认0 op[1].sem_num = 1; // 信号量元素序号 op[1].sem_op = +3; // V操作 op[1].sem_num = 0; // 选项默认0 // 同时对第0、1号信号量元素分别进行P、V操作 semop(id, op, 2);&#125; 3、获取或设置信号量的相关属性int semctl(int semid,int semnum,int cmd....) 参数：semid：信号量IDsemnum：信号量元素序号cmdIPC_STAT：获取属性信息IPC_SET：设置属性信息IPC_RMID：立即删除该信号量，参数semnum将被忽略IPC_INFO：获得关于信号量的系统限制信息SEM_INFO：获得系统为共享内存消耗的资源信息SEM_STAT：获得系统中所有SEM的相关信息GETALL：返回所有信号量元素的值，参数semnum将被忽略GETNCNT：返回正阻塞在对该吸纳后量元素P操作的进程总数GETPID：返回最后一个队该信号量元素操作的进程PIDGETVAL：返回该信号量元素的值GETZCNT：返回正阻塞对该信号量元素等零操作的进程总数SETALL：返回所有信号量元素的值，参数semnum将被忽略SETVAL：设置该信号量元素的值返回值GETNCNT：semncntGETPID：sempidGETVAL：semvalGETZCNT：semzcntIPC_INFO：内核中记录所有SEM信息的数组的下标最大值SEM_INFO：同IPC_INFOSEM_STAT：内核中看i路所有SEM信息的数组失败：-1这是一个变参函数，根据cmd的不同，可能需要第四个参数，第四个参数是一个如下所示的联合体，用户需要自己定义 123456union semun &#123; int val;//当cmd为SERVAL时使用 struct semid_ds *buf;//当cmd为IPC_STAT或IPC_SET时使用 unsigned short *array;//当cmd为GETALL或SETALL时使用 struct seminfo *_buf;//当cmd为IPC_INFO时使用 &#125; 当cmd为IPC_STAT或IPC_SET时,需要用到一下属性信息结构体 123456struct semid_ds &#123; struct ipc_perm sem_perm;//权限相关信息 time_t sem_otime;//最后一次semop()的信息 tien_t sem_ctime;//最后一次状态改变时间 unsigned short sem_nsems;//信号量元素个数 &#125; 使用例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758int mutex_p(key_t sem_tag, int *sem_id, unsigned int timeout)&#123; int ret; int semid =0; int semno = 0; int val; struct sembuf smbf[2] = &#123;&#123;0&#125;&#125;; DRV_CHECK_RETV(sem_id != NULL, -EINVAL); ret = semget(sem_tag, 1, IPC_CREAT | IPC_EXCL | MSG_SEM_PERMISSION_RW_GROUP); if (ret &lt; 0) &#123; if (errno == EEXIST) &#123; semid = semget(sem_tag, 1, 0); if (semid &lt; 0) &#123; return -EINVAL; &#125; &#125; else &#123; return -EINVAL; &#125; &#125; else &#123; semid = ret; val = 1; ret = semctl(semid, semno, SETVAL, val); if (ret &lt; 0) &#123; return -EINVAL; &#125; &#125; *sem_id = semid; smbf[0].sem_num = 0; smbf[0].sem_op = -1; smbf[0].sem_flg = (timeout == MUTEX_WAIT_FOR_EVER) ? SEM_UNDO : (SEM_UNDO | IPC_NOWAIT); ret = semop(semid, smbf, 1); if (ret == 0) &#123; return 0; &#125; else if (errno == EAGAIN) &#123; printf(&quot;have another process use &quot;); &#125; else &#123; printf(&quot;semop fail &quot;); &#125; return -EINVAL;&#125;int mutex_v(int sem_id)&#123; int ret; struct sembuf smbf; smbf[0].sem_num = 0; smbf[0].sem_op = 1; smbf[0].sem_flg = SEM_UNDO | IPC_NOWAIT; ret = semop(semid, &amp;smbf, 1); if (ret != 0) &#123; return -EINVAL; &#125; return ret;&#125; 四、锁互斥量从本质上说就是一把锁, 提供对共享资源的保护访问。 1、初始化在Linux下, 线程的互斥量数据类型是pthread_mutex_t. 在使用前, 要对它进行初始化: 对于静态分配的互斥量, 可以把它设置为PTHREAD_MUTEX_INITIALIZER, 或者调用pthread_mutex_init.对于动态分配的互斥量, 在申请内存(malloc)之后, 通过pthread_mutex_init进行初始化, 并且在释放内存(free)前需要调用pthread_mutex_destroy. 原型: &#96;int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restric attr); int pthread_mutex_destroy(pthread_mutex_t *mutex); 头文件:#include&lt;pthread.h&gt; 返回值: 成功则返回0, 出错则返回错误编号. 说明: 如果使用默认的属性初始化互斥量, 只需把attr设为NULL. 其他值在以后讲解。 2、互斥操作:对共享资源的访问, 要对互斥量进行加锁, 如果互斥量已经上了锁, 调用线程会阻塞, 直到互斥量被解锁. 在完成了对共享资源的访问后, 要对互斥量进行解锁。 首先说一下加锁函数: 头文件:#include&lt;pthread.h&gt; 原型: 12int pthread_mutex_lock(pthread_mutex_t *mutex);int pthread_mutex_trylock(pthread_mutex_t *mutex); 返回值: 成功则返回0, 出错则返回错误编号. 说明: 具体说一下trylock函数, 这个函数是非阻塞调用模式, 也就是说, 如果互斥量没被锁住, trylock函数将把互斥量加锁, 并获得对共享资源的访问权限; 如果互斥量被锁住了, trylock函数将不会阻塞等待而直接返回EBUSY, 表示共享资源处于忙状态。 再说一下解锁函数:原型: int pthread_mutex_unlock(pthread_mutex_t *mutex); 返回值: 成功则返回0, 出错则返回错误编号.","tags":["C语言"],"categories":["C语言"]},{"title":"线程","path":"/posts/线程.html","content":"我们知道，在创建线程时，会用到pthread_create()函数 ，我们来简单介绍一下该函数： pthread_create(线程的tid ， 线程属性 ， 工作函数名 ， 函数需要的参数); 这篇博客要讲的线程属性，便是用于进行线程的初始化的，我们可以通过对线程属性的修改来自定义线程 接下来我们来了解一下什么线程属性 一、线程属性中的成员线程属性是一个结构体，用法为 pthread_attr_t 变量名（本篇博客里默认变量名为attr） 线程属性结构体中的成员分别有：线程的警戒缓冲区、线程的优先级指针、线程的退出状态、线程栈地址、线程栈大小 接下来，我们来介绍一下该结构体中的这几个成员 线程的警戒缓冲区首先我们要知道，每当一个线程被创建出来的时候，都会有一个相应的线程栈出现，而栈存在溢出问题（栈的溢出都是上溢），线程栈是申请在堆空间的 一旦栈发生溢出，数据就会向上覆盖，影响甚至破坏到库、栈区等空间中的数据。但更可怕的是，由于用户对用户空间中的内容具有读写权限，线程栈上溢所导致的对这些内容的修改，系统是不会报错的，只有当数据溢出到内核层时，我们才能够发现问题，但此时已经晚了，数据已经全被破坏了，所以我们需要来给每个线程栈“加个盖子”，也就是所谓的“警戒缓冲区”。 警戒缓冲区的大小一般为4K，这块内存是不可读写的，所以当线程栈发生上溢，想要修改这块内存中的内容时，系统就会发现有线程非法操作内存，并杀死该线程，这样就可以保护其他内存中的数据 线程的优先级指针表示线程的优先级，一般情况下不建议修改，因为会影响系统的稳定性，一般只有杀毒软件或系统的防御软件才会修改其优先级 二、线程退出状态线程的退出状态有两种，分别是回收态(PTHREAD_JOINABLE)和分离态(PTHREAD_DETACH) 线程栈地址由于当修改线程属性时，线程还没有被创建，自然也就没有地址可存，所以默认情况下都是nil，表示空 线程栈大小线程栈大小一般情况下都是8M，但是我们知道，8M如果用二进制表示时非常大的数，将这么大的数放进去仅仅表示线程栈的大小其实没什么意义，所以默认情况下，这里存放的数据就是0，表示8M，申请空间时也是申请8M大小的空间 三、修改线程属性的相关函数在了解了线程属性的组成之后，我们就要来了解一下修改线程属性的相关函数了 先介绍下一会会用到的几个变量： pthread_attr_t attr ; &#x2F;&#x2F;定义一个线程属性结构体 int exit_state ; &#x2F;&#x2F;线程属性中的退出状态 void* thread_stack_addr ; &#x2F;&#x2F;线程属性中的线程栈地址 size_t thread_stack_size ; &#x2F;&#x2F;线程属性中的线程栈大小 函数 功能 返回值 pthread_attr_getdetachstate(&amp;attr , &amp;exit_state); exit_state作为传出参数，可以获取线程属性中的退出状态 回收态返回 PTHREAD_CREATE_JOINABLE分离态返回 PTHREAD_CREATE_DETACHED pthread_attr_setdetachstate(&amp;attr , exit_state); 通过传入参数exit_state，设置线程属性中的退出状态 成功返回0，失败返回非0错误码 pthread_attr_getstack(&amp;attr , &amp;thread_stack_addr , &amp;thread_stack_size); thread_stack_addr、thread_stack_size作为传出参数，可以获取线程属性中的栈地址与栈大小 返回两个参数——线程栈地址与线程栈大小 pthread_attr_setstack(&amp;attr , thread_stack_addr , thread_stack_size); 通过传入参数thread_stack_addr、thread_stack_size，可以设置线程属性中的栈地址与栈大小 成功返回0，失败返回非0错误码 pthread_attr_init(&amp;attr); 初始化线程属性结构体 成功返回0，失败返回-1 pthread_attr_destroy(&amp;attr); 释放线程属性结构体内存 成功返回0，失败返回-1 四、修改线程属性的具体实现接下来，我们可以根据这些函数来实际操作一下，完成以下两个小任务 获取线程属性中默认的退出状态（难度：⭐）获取默认状态下线程属性中的线程栈地址与大小。将线程属性中的退出状态设置为分离态，修改线程栈地址，修改线程栈大小为1M，并测试使用这种线程属性的线程，系统一共能够创建多少个？（难度：⭐⭐⭐⭐）PS：64位机下，即使你修改了线程栈大小，创建的数目和原来还是一样的，因为你的修改是无效的，系统创建的线程栈大小还是8M，修改线程栈大小只有32位机有效 1、获取线程属性中默认的退出状态，以下是代码实现 123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;pthread.h&gt;#include &lt;fcntl.h&gt; int main()&#123; pthread_attr_t attr; //1.初始化线程属性 pthread_attr_init(&amp;attr); //2.检测线程属性中的线程退出状态 int detach_status; pthread_attr_getdetachstate(&amp;attr , &amp;detach_status); //3.判断是回收态还是分离态 if(detach_status == PTHREAD_CREATE_JOINABLE) &#123; printf(&quot;线程属性默认为回收态 &quot;); &#125; else &#123; printf(&quot;线程属性默认为分离态 &quot;); &#125; //4.释放线程属性结构体内存 pthread_attr_destroy(&amp;attr); printf(&quot;进程退出！ &quot;);&#125; 怎么样，是不是很简单呢？ 接下来，我们来完成第二个小任务 2、获取默认状态下线程属性中的线程栈地址与大小。将线程属性中的退出状态设置为分离态，修改线程栈地址，修改线程栈大小为1M，并测试使用这种线程属性的线程，系统一共能够创建多少个，以下是代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//pthread_addr_change.c #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/stat.h&gt;#include &lt;pthread.h&gt;#include &lt;fcntl.h&gt; void* thread_jobs(void* arg)&#123; while(1) &#123; sleep(1); &#125; pthread_exit(NULL);&#125; int main()&#123; pthread_attr_t attr; //1.初始化线程属性 pthread_attr_init(&amp;attr); //2.检测线程属性中的线程退出状态 int detach_status; pthread_attr_getdetachstate(&amp;attr , &amp;detach_status); //3.判断是回收态还是分离态并打印 if(detach_status == PTHREAD_CREATE_JOINABLE) &#123; printf(&quot;线程属性默认为回收态 &quot;); &#125; else &#123; printf(&quot;线程属性默认为分离态 &quot;); &#125; //4.将线程属性中的退出态修改为分离态 pthread_attr_setdetachstate(&amp;attr , PTHREAD_CREATE_DETACHED); //5.获取线程属性中线程栈的初始地址与大小并打印 void* thread_stack_addr; size_t thread_stack_size; pthread_attr_getstack(&amp;attr , &amp;thread_stack_addr , &amp;thread_stack_size); printf(&quot;线程栈地址为 %p , 线程栈大小为 %d &quot; , thread_stack_addr , (int)thread_stack_size); //6.通过malloc函数修改线程栈的初始地址，并将线程栈大小改为1M pthread_t tid; thread_stack_size = 0x100000;//0x100000代表1M int flag = 0; int errno; while(1) &#123; //如果malloc函数的返回值为NULL，就说明分配失败，内存已经用完 if((thread_stack_addr = (void*)malloc(thread_stack_size)) == NULL) &#123; perror(&quot;thread_addr malloc failed! &quot;); exit(0);//进程退出 &#125; //修改栈初始地址和大小 pthread_attr_setstack(&amp;attr , thread_stack_addr , thread_stack_size); //创建线程，并判断是否创建失败 if((errno = pthread_create(&amp;tid , &amp;attr , thread_jobs , NULL)) &gt; 0) &#123; perror(&quot;thread create failed! &quot;); exit(0);//进程直接退出 &#125; else &#123; flag++; printf(&quot;flag = %d &quot;,flag); &#125; &#125; pthread_attr_destroy(&amp;attr); return 0; &#125; 结果如下图所示： 五、pthread 亲和性设置1、pthread_attr_setaffinity_np函数原型： 12int pthread_attr_setaffinity_np(pthread_attr_t *attr, size_t cpusetsize, const cpu_set_t *cpuset); attr：指向线程属性对象的指针。 cpusetsize：CPU 亲和性集合的大小（以字节为单位）。 cpuset：指向 CPU 亲和性集合的指针，其中包含要绑定线程的 CPU。 返回值：成功返回 0，失败返回错误代码。 用于设置线程的 CPU 亲和性（CPU Affinity）。 它允许将线程绑定到特定的 CPU 核心或 CPU 集合上，以控制线程在哪些 CPU 上运行。 2、pthread_setaffinity_np函数原型： 12int pthread_setaffinity_np(pthread_t thread, size_t cpusetsize, const cpu_set_t *cpuset); thread：要设置 CPU 亲和性的线程标识符。 cpusetsize：CPU 亲和性集合的大小（以字节为单位）。 cpuset：指向 CPU 亲和性集合的指针，其中包含要绑定线程的 CPU。 返回值：成功返回 0，失败返回错误代码。 用于设置线程的 CPU 亲和性（CPU Affinity）。 它允许将线程绑定到特定的 CPU 核心或 CPU 集合上，以控制线程在哪些 CPU 上运行。 示例1（推荐）本示例演示了如何在创建线程时限制其只能在 cpu1 上运行。 123456789101112131415161718192021222324252627282930313233343536373839#define _GNU_SOURCE#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;sched.h&gt;void *thread_func(void *arg)&#123; usleep(10000); // 获取当前线程的 CPU 亲和性 cpu_set_t cpuset; CPU_ZERO(&amp;cpuset); pthread_getaffinity_np(pthread_self(), sizeof(cpu_set_t), &amp;cpuset); // 打印当前线程绑定的 CPU for (int i = 0; i &lt; CPU_SETSIZE; i++) &#123; if (CPU_ISSET(i, &amp;cpuset)) &#123; printf(&quot;thread is running on cpu %d &quot;, i); &#125; &#125; return NULL;&#125;int main() &#123; pthread_t tid; pthread_attr_t attr; pthread_attr_init(&amp;attr); // 创建线程并设置其只能在 cpu1 上运行 cpu_set_t mask; CPU_ZERO(&amp;mask); CPU_SET(1, &amp;mask); pthread_attr_setaffinity_np(&amp;attr, sizeof(mask), &amp;mask); pthread_create(&amp;tid, &amp;attr, thread_func, NULL); pthread_attr_destroy(&amp;attr); pthread_join(tid, NULL); return 0;&#125; 示例2：本示例演示了如何在创建线程后限制其只能在 cpu0 1 2 上运行。 12345678910111213141516171819202122232425262728293031323334353637#define _GNU_SOURCE#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;sched.h&gt;void *thread_func(void *arg)&#123; usleep(10000); // 获取当前线程的 CPU 亲和性 cpu_set_t cpuset; CPU_ZERO(&amp;cpuset); pthread_getaffinity_np(pthread_self(), sizeof(cpu_set_t), &amp;cpuset); // 打印当前线程绑定的 CPU for (int i = 0; i &lt; CPU_SETSIZE; i++) &#123; if (CPU_ISSET(i, &amp;cpuset)) &#123; printf(&quot;thread is running on cpu %d &quot;, i); &#125; &#125; return NULL;&#125;int main() &#123; // 创建线程并设置其只能在 cpu0 1 2 上运行 pthread_t tid; cpu_set_t mask; CPU_ZERO(&amp;mask); CPU_SET(0, &amp;mask); CPU_SET(1, &amp;mask); CPU_SET(2, &amp;mask); pthread_create(&amp;tid, NULL, thread_func, NULL); pthread_setaffinity_np(tid, sizeof(mask), &amp;mask); pthread_join(tid, NULL); return 0;&#125;","tags":["C语言"],"categories":["C语言"]},{"title":"动态链接库、静态链接库","path":"/posts/动态链接库、静态链接库.html","content":"一、什么是链接库有时候我们对外提供功能的时候，可能不希望对方看到源码，我们就可以制作成库文件，把库文件和头文件给到对方就可以达到提供功能又不暴露源码的目的。链接库就是指将库文件编译后打包为一个二进制文件，这些二进制文件会在程序调用的时候加载到内存中。实际上，一个或多个源文件编译为目标文件后，这个文件中所引用的外部的符号需要通过链接来找到这部分缺失的地址。而链接的方式又分为两种，如果是在生成可执行文件之前就已经把所有的链接操作完成了，这种链接称为静态链接，这种库文件称为静态链接库；如果是在程序执行的时候才进行链接，这种称为动态链接，对应的库文件称为动态链接库。也正因为如此，使用静态库时生成的可执行文件是可以独立运行的，因为他不再需要外部的内容，而动态库编译生成的可执行文件就无法单独运行，因为他在运行时，才会去链接所引用的外部地址。 1. 静态链接库静态库会直接加载到代码段，他和所有的目标文件一起链接成可执行文件，生成可执行文件后可以独立运行。但是，正因为静态库会直接加载到内存的代码段，可执行文件的内部都拷贝了所有目标文件和静态库的指令和数据，编译生成的可执行文件会比较大。并且，如果整个系统中有多个链接统一静态库的可执行文件时，每个可执行文件都要拷贝一份静态库的指令和数据，这就造成了空间浪费，因为他们拷贝的数据都是同样的内容。最后，如果一旦静态库文件有代码更新，就需要重新编译链接重新生成整个可执行文件，更新升级麻烦。在 Linux 系统中，静态链接库文件的名称通常为 libxxx .a，在 Windows 系统中，静态链接库文件的后缀名为 .lib。 2. 动态链接库其实，动态库这个称呼本身是对 Windows 平台上动态链接所用的库文件的一种称呼，在 Linux 下，一般称为共享库。动态库是在运行时加载到内存的共享库段，这样，如果很多程序都要用到静态库的时候，就会节省大量内存，因为它不像静态库那样加载到代码段，而是是在运行时载入内存的共享库段，当多个程序要用到同一个动态库时，所有程序可以共享这个共享库段的指令和数据。动态链接的实现是这样的，在编译时首先由静态链接器将所有的目标文件链接为一个可执行文件，等到程序运行时会将要用到的动态库加载到内存的共享库段，由动态链接器完成可执行文件和动态库文件的链接工作，可以理解为按需载入内存（在需要用到的时候，才会载入内存）。动态库大大方便了程序的升级和更改，只要用新的动态库文件替换旧的动态库文件即可，在运行时，会自动连接新的库文件。但是正因为动态库运行时载入的这个特点，使用动态库的可执行文件在运行时，会略慢一些，但整体来说，运行速度的性能损失，远远小于内存节省带来的收益。在Linux系统中，动态链接库的名称通常为 libxxx.so，在 Windows 系统中，动态链接库的后缀名为 .dll。GCC 编译器在生成可执行文件时，默认会优先使用动态链接库完成链接，如果当前系统环境中没有程序文件所需要的动态链接库，GCC 便会选择静态链接库进行静态链接。如果两种库文件都没有找到，则链接失败。 3. 库文件与头文件我们在发布库文件的同时，要将库文件和头文件一起发布，头文件中存储了变量、函数或者类等这些功能模块的声明部分，库文件中存储了各模块具体的实现部分。也就是说，头文件中定义了调用库文件中功能模块的接口。头文件的存在也实现了这样一种功能，当我们对外提供功能时，可以通过库文件来隐藏源码实现，功能的使用方只需要根据头文件所提供的接口来调用功能模块即可。 4. 库文件的引用当我们使用 GCC 编译和链接程序时，GCC 默认会链接 libc.a 或者 libc.so这两个标准库，但是对于其他的库（非标准库、第三方库等），就需要手动去添加链接库。通过 GCC -l 选项来指定库名，直接在 -l 后面加库名即可。（ -l 是小写的 L ）正常情况下，我们指定了要使用的库名时，GCC 会自动在标准库目录中搜索文件，例如在CentOS中是 &#x2F;usr&#x2F;lib 目录。但是，如果想链接位于其它目录中的库，比如说我们自己建的库，或者我们要引用别人提供的库，就需要在编译时显示指定库的路径。指定方法有三种：① 像指定普通头文件的路径一样，为 GCC 显示指定该库文件的完整路径与文件名 -I &#x2F;目录名 。② 通过 GCC 的 -L 选项，为GCC增加搜索目录，可以使用多个 -L 选项，或者在一个选项内使用冒号 : 分割来指定多个搜索路径。③ 把库文件所在的目录加到环境变量 LIBRARYPATH 中。 二、自己动手制作静态链接库准备工作，共准备4个文件，目录结构如下 my_print.h 文件内容如下 123456789101112#ifndef _TEST_H#define _TEST_H#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;void print_array_int(int* array, int len);void print_array_char(char* array, int len);void print_array_string(char* array[], int len);void print_hello();#endif my_print.c 文件内容如下 12345678910111213141516171819202122232425262728293031323334#include &quot;my_print.h&quot; void print_array_int(int* array, int len)&#123; int i = 0; printf(&quot;array: &quot;); for(i = 0; i &lt; len; i++) &#123; printf(&quot;%d &quot;, array[i]); &#125; printf(&quot; &quot;);&#125; void print_array_char(char* array, int len)&#123; i = 0; printf(&quot;array: &quot;); for(i = 0; i &lt; len; i++) &#123; printf(&quot;%c &quot;, array[i]); &#125; printf(&quot; &quot;);&#125;void print_array_string(char* array[], int len)&#123; int i = 0; printf(&quot;array: &quot;); for(i = 0; i &lt; len; i++) &#123; printf(&quot;%s &quot;, array[i]); &#125; printf(&quot; &quot;);&#125; main.c 文件内容如下 12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; #include &quot;my_print.h&quot; int main()&#123; int a1[10]; int i = 0; for(i = 0; i &lt; 10; i++) &#123; a1[i] = i + 1; &#125; print_array_int(a1, 10); print_hello(); return 0;&#125; print_hello.c 文件内容如下 123456#include &quot;my_print.h&quot; void print_hello()&#123; printf(&quot;hello Linux ... &quot;);&#125; 1. 静态库的制作① 首先把所有 .c 文件编译为 .o 文件 1gcc -c *.c -I ../header/ 一定要从 .o 文件去生成 .a 文件，否则即使你生成了库，在使用时也可能出现未知的错误。② 将 .o 文件打包为 .a 文件这一步需要使用 ar 工具来完成。ar 工具是用来创建, 修改和提取档案的工具，ar 是 archive 的缩写。归档是指将多个文件（或一个文件）放到单个文件中，不进行其他额外的操作。也就是说，归档并不等同于压缩，压缩会使文件的大小减小。 1ar rcs libmprint.a *.o 参数 r ：在库中插入模块（替换）。当插入的模块名已经在库中存在，则替换同名的模块。如果若干模块中有一个模块在库中不存在，ar 显示一个错误消息，并不替换其他同名模块。默认的情况下，新的成员增加在库的结尾处，可以使用其他任选项来改变增加的位置。 参数 c ：创建一个库。不管库是否存在，都将创建。 参数 s ：创建目标文件索引，这在创建较大的库时能加快时间。如果不需要创建索引，可改成大写 S 参数。如果 .a 文件缺少索引，可以使用 ranlib 命令添加）。 一般我们命令静态库的时候是这样的，前面是 lib 中间加上我们自己给静态库文件的名称，后面加后缀 .a ，也就是 libxxx.a ，实际上， xxx 才是静态库文件的名称。 可以查看一下生成的 libmprint.a 的内容，一堆乱码 我们可以用 nm 命令查看库文件的信息，可以看到它是由 my_print.o 和 print_hello.o 生成的。 2. 静态库的使用静态库的使用方法 1gcc main.c -o exe -lmyprint -L ../lib/ -I ../header/ 首先对上面的命令进行分解一下，-lmyprint 用于指定链接库的名字，我们上面生成了一个名为 libmprint.a 的静态库，把前缀后缀去掉留下中间的名字即可；-L …&#x2F;lib&#x2F; 指定静态库的搜索目录，不指定的会，编译器只会去默认的链接库搜索路径寻找；-I …&#x2F;header&#x2F; 这个就比较熟悉了，指定头文件的路径。 我们再发布的时候，只需要把 header 和 lib 发布给别人即可 三、自己动手制作动态链接库1. 动态库的制作① 编译生成与位置无关的 .o 文件动态共享库是在运行的时候才加载的，它加载到内存的共享库段，用完后就释放，所以要编译为与位置无关的。这里要用到GCC 的 -fPIC 选项参数，该选项表示编译为位置独立的代码，如果不用这个选项的话编译后的代码是位置相关的，所以动态载入的时候会通过代码拷贝的方式来满足不同进程的需要，而不能达到真正代码段共享的目的。在静态链接库中，可执行文件在链接时就知道每一行代码、每一个变量会被放到线性地址空间的什么位置，因此这些地址可以都作为常数写到代码里面。对于动态库，只有加载的时候才知道。也就是说，动态链接库要编译为与位置无关的代码，这样只有在运行时才直到代码的位置。而静态库是在生成可执行文件之前，就直接把代码加载到内存的代码段了，代码的位置等信息也就已经知道了，所以不需要生成与位置无关的代码。 1gcc -fPIC -c *.c -I ../header/ ② 将 .o 文件打包这里要用到 GCC 的 -shared 选项，该选项指定生成动态连接库（让连接器生成T类型的导出符号表，有时候也生成弱连接W类型的导出符号），如果不用该标志的话外部程序将无法连接。可以在动态库文件名后面加版本号 libxxx.so.主版本号.副版本号 ，比如 libmdprint.so.1.1 表示我这是 1.1 版本的动态库，文件后缀后面的数字就是版本号的意思。 1gcc -shared *.o -o libmdrint.so 2. 动态库的使用（1）加载动态库使用动态库的命令和使用静态库的命令一样 1gcc main.c -o exe -lmdrint -L ../lib/ -I ../header/ （2）“加载共享库出错”的解决方法这个是时候，虽然我们已经生成了可执行文件，但是当我们运行可执行文件的时候，可能会出现这样的错误 我们可以通过命令 ldd 来查看一下可执行文件的链接情况 在我们自己引入的库 libmdrint.so 一栏显示 “not found” ，在默认情况下，我们自己引入的动态库是无法使用的，需要进行一些配置。这里提供以下几种解决方法。 ① 在系统库路径下建立软链接前面我们已经介绍了，GCC 会默认去系统库路径下搜索库文件，所以只要我们把自己的库文件放到这个目录下就可以了，系统库的路径是 &#x2F;usr&#x2F;lib 或 &#x2F;lib 。但是我们实际操作的时候，可能无法把文件拷贝到这两个路径下，我们可以在系统库路径下建立一个软链接来指向我们的库文件（软链接相关知识请参考本人 Linux 专栏文章《【Linux王者之路基础篇：基本命令与基础知识】Linux常用shell命令（及相关知识）详解与用法演示》） 1sudo ln -s /home/qq/dm/dm_lib/lib/libmdrint.so /usr/lib/libmdrint.so 这里第一个路径也就是我们自己的动态库文件所在目录，一定要用绝对路径（如果使用相对路径，会找不到该路径），第二个路径是系统库的路径。 ② 配置环境变量实际上， ld 链接器在寻找库路径的时候，都是通过一个环境变量 LD_LIBRARY_PATH 来寻找的，我们可以打印看一下这个环境变量 我们可以通过 export 命令来给环境变量增加一个路径，只需要把自己的路径加进去即可，命令如下 1export LD_LIBRARY_PATH=/home/qq/dm/dm_lib/lib/:$LD_LIBRARY_PATH 我们知道在 shell 下直接把绝对路径加到环境变量中，只是一种临时的环境变量，当关机再次开机的时候，就会失效，如果想要永久有效，可以修改配置文件。我们可以把上面这条命令放到 .bashrc 文件中。在我的 Linux 专栏文章中，已经不只一次提到 .bashrc 这个配置文件了，其实 Linux 每次开机都会执行这个配置文件，我们实现环境变量永久有效的原理就是，Linux 每次开机都会执行 .bashrc 配置文件，而配置文件中包含设置环境变量的命令，所以每次开机都会配一下环境变量，这样就达到了环境变量永久有效的目的。.bashrc 配置文件在家目录下 1vim ~/.bashrc ③ 修改 ld.so 加载器的配置文件 ld.so.conf这里先介绍几个概念： ld链接器 ：gcc 可以在编译周期传递参数，指定需要链接的库文件，生命周期是在 compile-time。 ld.so动态链接器&#x2F;加载器，程序运行的时候会根据指定的路径去加载指定的库，生命周期是在 run-time。 ld.so加载器及配置文件ld.so.conf：指定动态链接库的搜索路径（也可以通过配置环境变量$LD_LIBRARY_PATH 来指定程序运行时的动态库.so文件的搜索路径）。使用 ldconfig 就可以将 ld.so.conf 中的指定目录的库文件加载到内存中，并记录在&#x2F;etc&#x2F;ld.so.cache文件中。配置文件 &#x2F;etc&#x2F;ld.so.conf 记录了编译时使用的动态链接库的路径，在默认情况下，编译器只会使用 &#x2F;lib 和 &#x2F;usr&#x2F;lib 这两个目录下的库文件，通过这个配置文件可以增加我们自己的动态库文件搜索路径。 使用 vim 编辑器打开配置文件，把路径放进去 1sudo vim /etc/ld.so.conf 放入路径之后，还要在 shell 下执行一条命令，使刚才的配置生效 1sudo ldconfig -v 不管使用上面三种方法的哪种，都可以使动态库正常加载到可执行文件中，我们再次使用 ldd 命令查看 exe 文件，可以看到，我们的动态库 libmdrint.so 后面由原来的 “not found” 变成了一个路径，这说明加载器现在可以找到动态库的路径了，可执行文件 exe 也就可以运行了。","tags":["C语言"],"categories":["C语言"]},{"title":"预处理、编译、汇编、链接","path":"/posts/预处理、编译、汇编、链接.html","content":"C语言经典的 “hello world ” 程序，伴随着每个程序员一起步入编程世界的大门。从编写、编译到运行，看到屏幕上输出的“hello world ”，那么你知道它都经历了什么吗？今天我们就来聊聊这个话题。 一、从hello.c聊起hello world.c 123456#include &lt;stdio.h&gt;int main() &#123; printf(&quot;hello,world! &quot;); return 0;&#125; 在linux下，使用 gcc 编译hello.c源文件，会在当前目录下默认生成 a.out 可执行文件，在终端输出hello，world！。 123$ gcc hello.c$ ./a.out$ hello,world! 预编译器、汇编器as、链接器ld，实际上gcc 命令只是对这些不同程序的封装，根据不同的参数去调用不同的程序。 从 hello.c 到可执行文件的全过程，可分为4个步骤： 1、预处理gcc -E hello.c -o hello.i 得到预处理文件，其中，-E 表示只进行预编译。源文件在预编译阶段会被编译器生成.i文件，主要处理源代码文件中以“#”开头的预编译指令。如：宏定义展开，将被包含的文件插入到该编译指令的位置等。 2、编译gcc -S hello.i -o hello.s 得到汇编文件，其中，-S 表示生成汇编文件。编译就是把预处理完的文件，进行语法分析、词法分析、语义分析及优化后生成相应的汇编代码文件，这个过程是整个程序构建的核心过程，也是最复杂的部分。 3、汇编as hello.s -o hello.o 或者 gcc -c hello.s -o hello.o，其中，-c 表示只编译不链接。将汇编代码文件转变成机器可以执行的指令文件，即目标文件。也可以直接使用：gcc -c hello.c -o hello.o 经过预处理、编译、汇编直接输出目标文件。为什么汇编器不直接生成可执行程序，而是一个目标文件呢？为什么要链接？这个我们后面会详细讨论。 4、链接随着代码量的增多，所有代码若是都放在同一个文件里，那将是一场灾难。现代大型软件，动辄由成千上万的模块组成，每个模块相互依赖又相互独立。将这些模块组装起来的过程就是链接。这些模块如何形成一个单一的程序呢？无非就是两种方式：1、模块间的函数调用；2、模块间的变量访问。函数访问必须知道函数地址，变量访问必须知道变量地址，所以终归到底就是一种方式，不同模块间符号的引用。","tags":["C语言"],"categories":["C语言"]},{"title":"内存申请函数","path":"/posts/内存申请函数.html","content":"一、malloc函数原型： 1void* malloc (size_t size); 这个函数向内存申请一块连续可用的空间，并返回指向这块空间的指针； 如果开辟成功，返回一个指向开辟的空间的首地址的指针； 如果开辟失败，返回一个NULL指针，因此malloc函数的返回值，一定要做检查； 返回值的类型时void*，所以malloc函数并不知道开辟空间的类型，具体在使用时由使用者自己决定（强制转换）； 如果参数size为0，malloc函数的行为是标准未定义的，取决于编译器； 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;int main()&#123; int arr[10] = &#123; 0 &#125;; int* p = (int*)malloc(sizeof(arr));//动态内存开辟； if (p == NULL) &#123; perror(&quot;malloc&quot;);//是空指针则输出错误代码； return 1;//终止程序； &#125; for (int i = 0; i &lt; 10; i++) &#123; *(p + i) = i;//赋值； &#125; for (int i = 0; i &lt; 10; i++) &#123; printf(&quot;%d &quot;, *(p + i));//输出 &#125; //没有使用 动态内存释放函数 free ，此时如果程序继续运行，则被malloc函数开辟的空间不会被回收； //但只要程序退出，系统会自动回收内存空间； //正常情况下，由动态内存开辟函数所开辟的内存空间，在使用完成后必须被释放并销毁； free(p);//将p空间中的值销毁； p = NULL;//p不再指向有效空间； return 0;&#125; 二、calloc函数原型： 1void* calloc(size_t num,size_t size); 函数的功能是为num个大小为size的元素开辟一块空间，并将空间的每个字节初始化为0； 与函数malloc的区别在于，calloc会在返回地址前把申请的空间的每个字节初始化为全0； 1234567891011121314151617#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;int main()&#123; int* p = (int*)calloc(10, sizeof(int));//动态内存开辟； if (p == NULL) &#123; perror(&quot;calloc&quot;);//是空指针则输出错误代码； return 1;//终止程序； &#125; for (int i = 0; i &lt; 10; i++) &#123; printf(&quot;%d &quot;, *(p + i));//输出为：0 0 0 0 0 0 0 0 0 0； &#125; free(p);//将p空间中的值销毁； p = NULL;//p不再指向有效空间； return 0;&#125; 三、realloc函数原型： 1void* realloc(void* ptr,size_t size); ptr是需要调整的内存地址，size是调整之后的空间大小； 返回值为调整后的内存的起始地址； 函数在调整原内存空间大小的基础上，还会将原来内存中的数据移动到新的空间； &#x2F;&#x2F;对于内存空间的调整，存在两种情况： 1.原有空间之后的空间足够满足新空间的开辟； 2.原有空间之后没有足够大的空间满足新空间的开辟； &#x2F;&#x2F;函数调整失败的情况： 1.realloc失败的时候，返回NULL； 2.realloc失败的时候，原来的内存不改变，不会释放也不会移动； &#x2F;&#x2F;注意使用realloc函数改变或开辟空间，最好使用新的变量接收，再将新变量赋值给旧变量；原因是为了避免开辟空间失败返回空指针，导致的旧空间内存泄漏(指针被置空，无法找到旧空间)； 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;int main()&#123; int* p = (int*)malloc(40);//开辟40字节空间赋予p； if (p == NULL) &#123; perror(&quot;malloc&quot;); return 1; &#125; for (int i = 0; i &lt; 10; i++) &#123; *(p + i) = i + 1; &#125; int* ptr = realloc(p, 80);//扩容；此时，如果后续内存空间足够，则空间首地址不会改变，但如果后续内存空间不足，则会发现空间首地址改变，即新空间的开辟； if (ptr != NULL) &#123; p = ptr;//扩容成功则将扩容后的空间赋予p； ptr = NULL;//ptr不再指向有效空间； &#125; else &#123; perror(&quot;realloc&quot;); return 1; &#125; for (int i = 10; i &lt; 20; i++)//为扩容后的空间赋值； &#123; *(p + i) = i + 1; &#125; ptr = realloc(p, 40);//缩容； if (ptr != NULL) &#123; p = ptr;//缩容成功则将扩容后的空间赋予p； ptr = NULL;//将ptr置空； &#125; for (int i = 0; i &lt; 20; i++)//为扩容后的空间赋值； &#123; printf(&quot;%d &quot;, p[i]); &#125; free(p);//将p空间中的值销毁； p = NULL;//p不再指向有效空间； return 0;&#125;","tags":["C语言"],"categories":["C语言"]},{"title":"字符串函数","path":"/posts/字符串函数.html","content":"一、strlen1、原型：size_t strlen(char const* string);2、功能：返回字符串 string 的长度（不包含字符串终止符NUL）3、注意：size_t是一个无符号整数类型 二、strcpy1、原型：char *strcpy(char *dst, char const *src); 2、功能：将参数src字符串复制到dst参数中。如果参数src和dst在内存中出现重叠，其结果是未定义的。由于dst参数将进行修改，所以它必须是个字符数组或者是一个指向动态分配内存的数组的指针，不能使用字符串常量。返回参数dst的一份拷贝。 3、注意： 目标参数dst的以前内容将被覆盖并丢失。即使新的字符串比dst原先的内存更短，由于新字符串是以NUL字符结尾，所以老字符串最后剩余的几个字符也会被有效的删除。如果字符串比数组长，多余的字符仍被复制，它们将覆盖原先存储于数组后面的内存空间的值。所以必须保证目标字符数组的空间足以容纳需要复制的字符串。 三、strncpy1、原型：char *strncpy(char *dst, char const *src, size_t len); 2、功能：和strcpy一样，strncpy把源字符串的字符复制到目标数组。然而，它总是 正好向dst写入len个字符。如果strlen(src)的值小于len, dst数组就用额外的NUL字节填充到len长度。如果strlen(src)的值大于或者等于len,那么只有len个字符被复制到dst中。 3、注意：strncpy调用的结果可能不是一个字符串，它的结果将不会以NUL字符结尾， 因此字符串必须以NUL字符结尾 四、strcat1、原型：char *strcat(char *dst, char const *src); 2、功能：将一个字符串添加(连接)到另一个字符串的后面。 3、注意：src和dst的所指的内存区域不能重叠，如果发生重叠，其结果是未定义的。 五、strncat1、原型：char *strncat(char *dst, char const *src, size_t len); 2、功能：它从src最多复制 len个字符到dst中。但是, strncat总是在结果字符串后面添加一个NUL字符。 3、注意：src和dst所指的内存区域不能重叠，并且dst必须有足够多的空间来容纳src的字符串。 六、strcmp1、原型：int strcmp(char const *s1, char const *s2); 2、功能：比较两个字符串。如果s1小于s2，strcmp函数返回一个小于零的值。如果s1大于s2，函数返回一个大于零的值。如果两个字符串相等，函数就返回零。 3、注意：由于strcmp并不修改它的任何一个参数，所以不存在溢出字符数组的危险。但是，和其他不受限制的字符串函数(strcpy, strcat)一样，strcmp函数的字符串参数也必须以一个NUL字符结尾。如果并非如此，strcmp就可能对参数后面的字符进行比较，这个比较结果将不会有什么意义。 七、strncmp1、原型：int strncmp(char const *s1, char const *s2, size_t len); 2、功能：和strcmp一样，也用于比较两个字符串，但它最多比较 len 个字节。如果两个字符串在第 len 个字符之前存在不相等的字符，这个函数就像strcmp一样停止比较，返回结果。如果两个字符串的前len 个字符相等，函数就返回零。 八、strchr、strrchr1、原型：char *strchr(char const *str, int ch); char *strrchr(char const *str, int ch); 2、功能：在一个字符串中查找一个特定字符。 3、注意：第2个参数是一个整型值。但是，它包含了一个字符值。strchr在字符串str中查找字符ch第一次出现的位置，找到后函数返回一个指向该位置的指针。如果该字符并不存在于str中，函数就返回一个NULL指针。strrchr的功能和strchr基本一致，只是它所返回的是一个指向字符串中该字符最后一次出现的位置(最右边那个)。 九、strpbrk1、原型：char *strpbrk(char const *str, char const *group); 2、功能：这个函数返回一个指向str中第1个匹配group中任何一个字符的字符位置。如果未找到匹配，函数返回一个NULL指针。 十、strstr1、原型：char *strstr(char *s1, char *s2); 2、功能：这个函数在s1中查找整个s2第1次出现的起始位置，并返回一个指向该位置的指针。如果s2并没有完整地出现在s1的任何地方，函数将返回一个NULL指针。如果第2个参数是一个空字符串，函数就返回s1。 十一、strtok1、原型：char *strtok(char *str, char const *sep); 2、功能：分解字符串str为一组字符串，分隔符为sep。 3、注意：如果strtok函数的第1个参数不是NULL，函数将找到字符串的第1个标记。strtok同时将保存它在字符串中的位置。如果strtok函数的第1个参数是NULL，函数就在同一个字符串中从这个被保存的位置开始像前面一样查找下一个标记。如果字符串内不存在更多的标记，strtok函数就返回一个NULL指针。在典型情况下，在第1次调用strtok时，向它传递一个指向字符串的指针。然后，这个函数被重复调用（第1个参数为NULL），直到它返回NULL为止。 1234567891011121314#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main()&#123; char whitespace[] = &quot; &quot;; char *token; char line[] = &quot;I love you&quot;; for (token = strtok(line, whitespace); token !=NULL; token = strtok(NULL, whitespace)) &#123; printf(&quot;Next token is |%s| &quot;, token); &#125; return 0;&#125;","tags":["C语言"],"categories":["C语言"]},{"title":"指针","path":"/posts/指针.html","content":"1、C语言的精髓–指针指针就是地址，在一定程度上可以把数组名就看成一个特殊的指针,指针也就是一个变量而已，指针全名指针变量。 （1）指针数组指针数组，是个数组，里边放的东西都是指针。char *p[2]=&#123;&quot;china&quot;,&quot;linux&quot;&#125;; 仔细来说，从运算符优先级来看，[]的优先级比*高，所以p先和[]结合。所以这就是个数组，再与指针结合，所以叫指针数组。 二重指针可以指向指针数组。 （2）数组指针数组指针，是个指针，指向数组的指针. 12int a[2][5]=&#123;0&#125;; int (*p)[5]=a; //指向二维数组 int b[2][3][4] = &#123;0&#125;; // 多维数组 int(*q)[3][4] = b; 这里指针是在()中放着，())和[]优先级都是最高的，结合性是从左向右，所以先与*结合，这是个指针，然后与[]结合，就是指针数组。 （3）函数指针1int (*p)(int a,char b);// 函数指针p指向返回值类型为int的，两个参数为int和char的函数 使用方法如下， p(a,b); 或者 (*p)(a,b); void *类型可以指向任何一个类型的指针 void (*signal(int sig, void (*func) (int))) (int) signal仍然是一个函数，他返回一个函数指针，这个指针指向的函数没有返回值，只有一个int类型的参数 （4）二维数组a[5][7];//用指针访问就是*（*（p+5）+7） int (*p)[7]=a; （5）字符数组与指向字符串指针的问题其中char *p=&quot;linux&quot; 这种情况字符串Linux只存在于只读数据段中（rodata），所以p所指向的内容不可以被更改，如*（p+1）=a;这是实现不了的，但是可以更改指针p 指向的地址，例如p&#x3D;”mengchao”,但是这里的p&#x3D;”mengchao”这段话放在子函数中是不可以的，字符串mengchao是存在于栈中，子函数结束就被释放了，不能够达到改变的目的。可以使用二重指针来实现。 char p[]&#x3D;”linux” 这个是字符数组，相当于初始化数组，可以更改内容，如p[1]&#x3D;’a’;* 这里Linux存在于栈上 所以有的字符串操作函数例如​​char *strcat(char *dst,char const *src);​​前面的参数dst,需要修改，只能传数组，不能直接传一个字符串，因为字符串不可改变 所以想修改字符串，请将他放在字符数组中。 另外关于这个程序 12345678char c = &#x27;a&#x27;; char *p = &amp;c;char *q = &quot;china&quot;; printf(&quot;%p &quot;,p); //006DFEE7 printf(&quot;%c &quot;,*p); //a cout &lt;&lt; *p &lt;&lt; endl; //a printf(&quot;%p &quot;,q); //004B9024 printf(&quot;%s &quot;,q); //china cout &lt;&lt; q &lt;&lt; endl; //china cout &lt;&lt; *q &lt;&lt; endl; //c 这里想插一句关于strlen和sizeof的区别。比如我们定义char buf[100]&#x3D;{“helloworld”}; strlen(buf);就是里边字符串的长度，而sizeof(buf);就是数组长度100. 一定程度上可以认为一级指针与一维数组名等价，二级指针与指针数组名等价，数组指针与二维数组名等价。而二级指针和二维数组名没有一毛钱关系。 （6）数组名数组名可以看成是首元素的首地址，也可以当成一个整体来看。数组名是常量，才可以唯一的确定数组元素的起始地址。设有一维数组int a[5]: a[1] = *(a+1); //a代表首元素首地址,加1跨度为int大小为4 对一维数组名和二维数组名引用(取地址)对一维数组名进行引用会将使其升级为二维数组名。 (&amp;a+1)//这个东西加1，加的大小是整个数组的大小，是20. 二维数组名解引用，降维为一维数组名。二维数组名是首元素首地址，设有int a[4][3],则 *(a+1) //代表的是二维数组的第二维 a[1][2] = *(*(a+1)+2) 注意下面的问题 1234567*p++：等同于：*p; p += 1;先运算再++ 解析：实际上*p++符号整体对外表现的值是*p的值，运算完成后p再加1. 【注意】是运算后p再加1，而不是p所指向的变量*p再加1 *++p：等同于 p += 1; *p;先++再运算 解析：由于++在p的前面，++前置的含义是，先加1，得到一个新的p（它的值是原来p的值加1）。然后这个新的p再与前面的*结合. 【总结】无论是*p++还是*++p，都是指针p += 1，即p的值+1，而不是p所指向的变量*p的值+1。 ++前置与++后置，只是决定了到底是先p += 1，还是先*p。++前置表示先p += 1，再*p。++后置表示先*p，在p += 1； --前置与--后置的的分析方法++前置与++后置的一样。 2、进程空间 123全局变量：不初始化的默认为0，放在.bss段，初始化为0的也放在.bss段 初始化为非0的全局变量放在.data段中，生命周期全局 局部变量放在栈上，当调用结束，生命周期结束 3、结构体《道德经》 曰：”一生二，二生三，三生万物”。结构体用关键字 struct 定义，表达出多个不同变量在一起的类型。我们由此可以使用struct自定义几乎所有想要的类型。 结构体的定义： 12345678struct student&#123; char name[30]; char sex; int age; float high;&#125;stu1;//这里定义了一个变量stu1struct student stu2;//这里定义了一个变量stu2 这种定义出来的结构体类型在定义变量时必须跟着struct，就像struct student stu1;一样，我们引入typedef，避免这种情况。 12345678typedef struct student&#123; char name[30]; char sex; int age; float high;&#125;STUDENT;//将struct student类型重命名为STUDENTSTUDENT stu, stu2;//使用STUDENT替换struct student定义变量 结构体变量初始化及成员访问定义的结构体变量用点成员运算符（.）访问成员变量，比如stu.sex就这样访问成员变量。如果是结构体类型的指针变量则使用-&gt;访问成员变量。STUDENT stu; stu-&gt;sex = &#39;x&#39;;初始化大概有三种方法。 举例： 12345typede struct block &#123; char name[32]; int type; int size; &#125;block; 方法一： 1block test = &#123;&quot;version&quot;, 1, 32&#125;； 需要注意对应的顺序，不能错位。 方法二： 1234block test; test.name = &quot;version&quot;; test.type = 1; test.size= 3; 方法三： 12345block test = &#123; .type= 1, .size = 12, .name= &quot;version&quot; &#125;; 结构体大小设计内存对齐 1234567struct Date &#123; char a; int b; int64_t c; char d;&#125;; Date data [2][10]; 结构体所占的内存大小 a.整体所占的内存大小应该是结构中成员类型最大的整数倍，此处最大的类型是int_64t，占8个字节。即最后所占字节的总数应该是8的倍数，不足的补足 b.数据对齐原则-内存按结构体成员的先后顺序排列，当排到该成员变量时，其前面所有成员已经占用的空间大小必须是该成员类型大小的整数倍，如果不够，则前面的成员占用的空间要补齐，使之成为当前成员类型的整数倍。假设是地址是从0开始，结构体中第一个成员类型char型占一个字节，则内存地址0-1，第二成员从2开始，int型所占内存4个字节根据原则b，第一个成员所占内存补齐4的倍数，故第一个成员所占内存:1＋3＝4；第二个成员占5-8.第三个成员占8个字节，满足原则b，不需要补齐，占9-16第四个成员占一个字节，占17.故总内存为1＋3＋4＋8＋1＝17个字节，但根据原则1总字节数需是8的倍数，需将17补齐到24.故此结构体总字节数为:24字节 4、一些关键字的详解inline在c&#x2F;c++中，为了解决一些频繁调用的小函数大量消耗栈空间（栈内存）的问题，特别的引入了inline修饰符，表示为内联函数。栈空间就是指放置程序的局部数据（也就是函数内数据）的内存空间。 inline的使用是有所限制的，inline只适合涵数体内代码简单的涵数使用，不能包含复杂的结构控制语句例如while、switch，并且不能内联函数本身不能是直接递归函数（即，自己内部还调用自己的函数）。 inline函数仅仅是一个对编译器的建议，所以最后能否真正内联，看编译器的意思，它如果认为函数不复杂，能在调用点展开，就会真正内联，并不是说声明了内联就会内联，声明内联只是一个建议而已。 inline函数的定义放在头文件中其次，因为内联函数要在调用点展开，所以编译器必须随处可见内联函数的定义，要不然就成了非内联函数的调用了。所以，这要求每个调用了内联函数的文件都出现了该内联函数的定义。 因此，将内联函数的定义放在头文件里实现是合适的，省却你为每个文件实现一次的麻烦。 声明跟定义要一致：如果在每个文件里都实现一次该内联函数的话，那么，最好保证每个定义都是一样的，否则，将会引起未定义的行为。如果不是每个文件里的定义都一样，那么，编译器展开的是哪一个，那要看具体的编译器而定。所以，最好将内联函数定义放在头文件中。 注：之所以定义放在头文件中，是因为inline是在编译阶段展开的，并不是连接源文件。 staticstatic别的东西不想说，就说static在修饰局部变量的时候，函数结束此时局部变量并不会被释放，并且修饰的局部变量的值是一直保存的，类似于全局变量，但是还是只能在这个函数内才能访问 constconst又叫常变量，修饰的变量一般不能被更改。但是在C语言中这是假的，通过定义一个指针，修改指针指向的内存依旧可以更改const修饰的变量。在C++中才是真正的const，无法修改。 const一般出现在参数列表中，意味着这个变量在函数中并不会被修改，是输入型参数。 volatile这个volatile，英文名易变的。因为访问寄存器要比访问内存单元快的多,所以编译器一般都会作减少存取内存的优化，但有可能会读脏数据。当要求使用volatile声明变量值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。 精确地说就是，遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问；如果不使用valatile，则编译器将对所声明的语句进行优化。 5、多文件编程一个简单的例子 全局变量最好声明为 static，只在当前文件中可见，不要对外暴露；如果必须对外暴露，可以使用宏定义代替，全局变量最好只在本文件内使用，如果其他文件必须使用，最好封装get接口set接口，请看下面的代码。 main.c 源码： 1234567891011#include &lt;stdio.h&gt;#include &lt;conio.h&gt;#include &quot;module.h&quot;int main()&#123; int n1 = 1, n2 = 100; printf(&quot;从%d 加到%d 的和为%ld [By %s]&quot;, n1, n2, sum(n1, n2), OS); getch(); return 0;&#125; module.c 源码：如果使用了头文件中的宏定义，这里也是需要包含头文件的 123456789101112131415161718#include &lt;stdio.h&gt;#include &quot;module.h&quot;long sum(int fromNum, int endNum)&#123; int i; long result = 0; // 参数不符合规则，返回 -1 if(fromNum&lt;0 || endNum&lt;0 || endNum&lt;fromNum)&#123; return -1; &#125; for(i=fromNum; i&lt;=endNum; i++)&#123; result += i; &#125; // 返回大于等于 0 的值 return result;&#125; module.h 源码： 1234567#ifndef __MODULE_H_ #define __MODULE_H_ // 用宏定义来代替全局变量 #define OS &quot;Windows 7&quot; // 也可以省略 extern；不过为了程序可读性，建议写上 extern long sum(int, int);#endif 多个.c文件的时候，也可以只用一个.h头文件，然后都包含一下这个.h文件 6、文件操作https://www.cnblogs.com/wuqianling/p/5340719.html这篇文章写的就不错。 主要是文件操作分为二进制文件和文本文件，fopen打开的时候设置打开模式，返回值问FILE*类型的一个文件指针。通过这个文件指针就可以访问这个文件。 7、编码规范 for while等关键字和括号之间留出一个空格，突出关键字，for后哪怕只有一行也写{} 注释的双斜线之后要有一个空格，突出注释 函数名和类使用大驼峰命名法首个单词大写，变量使用小驼峰命名法第一个字母小写 类和函数写完之后要空一行 分号、逗号前边不空格，后边留空格。双目运算符两边留空格","tags":["C语言"],"categories":["C语言"]},{"title":"proc目录下pid各文件目录含义","path":"/posts/proc目录下pid各文件目录含义.html","content":"Linux 内核提供了一种通过 proc 文件系统，在运行时访问内核内部数据结构、改变内核设置的机制。proc 文件系统是一个伪文件系统，它只存在内存当中，而不占用外存空间。它以文件系统的方式为访问系统内核数据的操作提供接口。 用户和应用程序可以通过 proc 得到系统的信息，并可以改变内核的某些参数。由于系统的信息，如进程，是动态改变的，所以用户或应用程序读取 proc 文件时，proc 文件系统是动态从系统内核读出所需信息并提交的。 下面列出的这些文件或子文件夹，并不是都是在你的系统中存在，这取决于你的内核配置和装载的模块。另外，在 proc 下还有三个很重要的目录：net，scsi 和 sys。 sys 目录是可写的，可以通过它来访问或修改内核的参数，而 net 和 scsi 则依赖于内核配置。例如，如果系统不支持 scsi，则 scsi 目录不存在。 除了以上介绍的这些，还有的是一些以数字命名的目录，它们是进程目录。系统中当前运行的每一个进程都有对应的一个目录在 proc 下，以进程的 PID 号为目录名，它们是读取进程信息的接口。而 self 目录则是读取进程本身的信息接口，是一个 link。 &#x2F;proc&#x2F;[pid]&#x2F;auxv&#x2F;proc&#x2F;[pid]&#x2F;auxv 包含传递给进程的 ELF 解释器信息，格式是每一项都是一个 unsigned long长度的 ID 加上一个 unsigned long 长度的值。最后一项以连续的两个 0x00 开头。举例如下： $ hexdump -x &#x2F;proc&#x2F;2406&#x2F;auxv 0000000 0021 0000 0000 0000 f000 f7fa 7fff 00000000010 0010 0000 0000 0000 fbff 1f8b 0000 00000000020 0006 0000 0000 0000 1000 0000 0000 00000000030 0011 0000 0000 0000 0064 0000 0000 00000000040 0003 0000 0000 0000 0040 0040 0000 00000000050 0004 0000 0000 0000 0038 0000 0000 00000000060 0005 0000 0000 0000 0007 0000 0000 00000000070 0007 0000 0000 0000 0000 0000 0000 00000000080 0008 0000 0000 0000 0000 0000 0000 00000000090 0009 0000 0000 0000 55e0 0045 0000 000000000a0 000b 0000 0000 0000 0000 0000 0000 000000000b0 000c 0000 0000 0000 0000 0000 0000 000000000c0 000d 0000 0000 0000 0000 0000 0000 000000000d0 000e 0000 0000 0000 0000 0000 0000 000000000e0 0017 0000 0000 0000 0000 0000 0000 000000000f0 0019 0000 0000 0000 f079 f7f6 7fff 00000000100 001f 0000 0000 0000 ffea f7f6 7fff 00000000110 000f 0000 0000 0000 f089 f7f6 7fff 00000000120 0000 0000 0000 0000 0000 0000 0000 00000000130 &#x2F;proc&#x2F;[pid]&#x2F;cmdline&#x2F;proc&#x2F;[pid]&#x2F;cmdline 是一个只读文件，包含进程的完整命令行信息。如果该进程已经被交换出内存或者这个进程是 zombie 进程，则这个文件没有任何内容。该文件以空字符 null 而不是换行符作为结束标志。举例如下： $ ps aux|grep frpsroot 2406 0.1 0.1 54880 10524 ? Sl Dec11 21:30 frps -c .&#x2F;frps.ini $ cat &#x2F;proc&#x2F;2406&#x2F;cmdlinefrps-c.&#x2F;frps.ini &#x2F;proc&#x2F;[pid]&#x2F;comm&#x2F;proc&#x2F;[pid]&#x2F;comm 包含进程的命令名。举例如下： $ cat &#x2F;proc&#x2F;2406&#x2F;commfrps &#x2F;proc&#x2F;[pid]&#x2F;cwd&#x2F;proc&#x2F;[pid]&#x2F;cwd 是进程当前工作目录的符号链接。举例如下： $ ls -lt &#x2F;proc&#x2F;2406&#x2F;cwdlrwxrwxrwx 1 root root 0 Dec 12 20:39 &#x2F;proc&#x2F;2406&#x2F;cwd -&gt; &#x2F;home&#x2F;mike&#x2F;frp_0.13.0_linux_amd64 &#x2F;proc&#x2F;[pid]&#x2F;environ&#x2F;proc&#x2F;[pid]&#x2F;environ 显示进程的环境变量。举例如下： $ strings &#x2F;proc&#x2F;2406&#x2F;environ SUPERVISOR_GROUP_NAME&#x3D;sshTERM&#x3D;linuxSUPERVISOR_SERVER_URL&#x3D;unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;supervisor.sockSUPERVISOR_PROCESS_NAME&#x3D;sshRUNLEVEL&#x3D;2UPSTART_EVENTS&#x3D;runlevelPREVLEVEL&#x3D;NPATH&#x3D;&#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;sbin:&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;binUPSTART_INSTANCE&#x3D;UPSTART_JOB&#x3D;rcSUPERVISOR_ENABLED&#x3D;1runlevel&#x3D;2PWD&#x3D;&#x2F;previous&#x3D;N &#x2F;proc&#x2F;[pid]&#x2F;exe&#x2F;proc&#x2F;[pid]&#x2F;exe 为实际运行程序的符号链接。举例如下： $ ls -lt &#x2F;proc&#x2F;2406&#x2F;exelrwxrwxrwx 1 root root 0 Dec 11 19:00 &#x2F;proc&#x2F;2406&#x2F;exe -&gt; &#x2F;usr&#x2F;bin&#x2F;frps &#x2F;proc&#x2F;[pid]&#x2F;fd&#x2F;proc&#x2F;[pid]&#x2F;fd 是一个目录，包含进程打开文件的情况。举例如下： $ ls -lt &#x2F;proc&#x2F;2406&#x2F;fd lrwx—— 1 root root 64 Dec 24 09:39 77 -&gt; socket:[44377722]lrwx—— 1 root root 64 Dec 17 15:07 47 -&gt; socket:[29482617]lr-x—— 1 root root 64 Dec 12 20:18 0 -&gt; pipe:[13282]l-wx—— 1 root root 64 Dec 12 20:18 1 -&gt; pipe:[13283]lrwx—— 1 root root 64 Dec 12 20:18 10 -&gt; socket:[12238218]lrwx—— 1 root root 64 Dec 12 20:18 4 -&gt; anon_inode:[eventpoll]lrwx—— 1 root root 64 Dec 12 20:18 40 -&gt; socket:[19378614] 目录中的每一项都是一个符号链接，指向打开的文件，数字则代表文件描述符。 &#x2F;proc&#x2F;[pid]&#x2F;latency&#x2F;proc&#x2F;[pid]&#x2F;latency 显示哪些代码造成的延时比较大。如果要使用这个特性需要执行： $ echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;latencytop 举例如下 $ cat &#x2F;proc&#x2F;2406&#x2F;latency Latency Top version : v0.130667 10650491 4891 poll_schedule_timeout do_sys_poll SyS_poll system_call_fastpath 0x7f636573dc1d8 105 44 futex_wait_queue_me futex_wait do_futex SyS_futex system_call_fastpath 0x7f6365a167bc 每一行前三个数字分别是后面代码执行的次数、总共执行延迟时间(单位是微秒)和最长执行延迟时间(单位是微秒)。后面则是代码完整的调用栈。 &#x2F;proc&#x2F;[pid]&#x2F;maps&#x2F;proc&#x2F;[pid]&#x2F;maps 显示进程的内存区域映射信息。举例如下： $ cat &#x2F;proc&#x2F;2406&#x2F;maps00400000-006ea000 r-xp 00000000 fd:01 1727569 &#x2F;usr&#x2F;bin&#x2F;frps006ea000-00a6c000 r–p 002ea000 fd:01 1727569 &#x2F;usr&#x2F;bin&#x2F;frps00a6c000-00ab1000 rw-p 0066c000 fd:01 1727569 &#x2F;usr&#x2F;bin&#x2F;frps00ab1000-00ad4000 rw-p 00000000 00:00 0c000000000-c00000b000 rw-p 00000000 00:00 0c41feac000-c420000000 rw-p 00000000 00:00 0c420000000-c420400000 rw-p 00000000 00:00 0c420400000-c420700000 rw-p 00000000 00:00 0c420700000-c420800000 rw-p 00000000 00:00 0c420800000-c420900000 rw-p 00000000 00:00 0c420900000-c420a00000 rw-p 00000000 00:00 0c420a00000-c421ea0000 rw-p 00000000 00:00 0c421ea0000-c422a00000 rw-p 00000000 00:00 0c422a00000-c422a60000 rw-p 00000000 00:00 07f0418c01000-7f0418ee1000 rw-p 00000000 00:00 07ffff7f4f000-7ffff7f70000 rw-p 00000000 00:00 0 [stack:5121]7ffff7fad000-7ffff7faf000 r–p 00000000 00:00 0 [vvar]7ffff7faf000-7ffff7fb1000 r-xp 00000000 00:00 0 [vdso]ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0 [vsyscall] 其中注意的一点是 [stack:] 是线程的堆栈信息，对应于 &#x2F;proc&#x2F;[pid]&#x2F;task&#x2F;[tid]&#x2F; 路径。 &#x2F;proc&#x2F;[pid]&#x2F;root&#x2F;proc&#x2F;[pid]&#x2F;root 是进程根目录的符号链接。举例如下： $ ls -lt &#x2F;proc&#x2F;2406&#x2F;rootlrwxrwxrwx 1 root root 0 Dec 12 20:39 &#x2F;proc&#x2F;2406&#x2F;root -&gt; &#x2F; &#x2F;proc&#x2F;[pid]&#x2F;stack&#x2F;proc&#x2F;[pid]&#x2F;stack 示当前进程的内核调用栈信息，只有内核编译时打开了 CONFIG_STACKTRACE 编译选项，才会生成这个文件。举例如下： 1234567$ cat /proc/2406/stack[&lt;ffffffff810fa996&gt;] futex_wait_queue_me+0xc6/0x130[&lt;ffffffff810fb05d&gt;] futex_wait+0x17d/0x270[&lt;ffffffff810fd2d5&gt;] do_futex+0xd5/0x520[&lt;ffffffff810fd791&gt;] SyS_futex+0x71/0x150[&lt;ffffffff8180cc76&gt;] entry_SYSCALL_64_fastpath+0x16/0x75[&lt;ffffffffffffffff&gt;] 0xffffffffffffffff &#x2F;proc&#x2F;[pid]&#x2F;statm&#x2F;proc&#x2F;[pid]&#x2F;statm 显示进程所占用内存大小的统计信息。包含七个值，度量单位是 page(page大小可通过 getconf PAGESIZE 得到)。举例如下： $ cat &#x2F;proc&#x2F;2406&#x2F;statm13720 2617 493 746 0 12007 0 各个值含义： a）进程占用的总的内存b）进程当前时刻占用的物理内存c）同其它进程共享的内存d）进程的代码段e）共享库(从2.6版本起，这个值为0)f）进程的堆栈g）dirty pages(从2.6版本起，这个值为0) &#x2F;proc&#x2F;[pid]&#x2F;status&#x2F;proc&#x2F;[pid]&#x2F;status 包含进程的状态信息。其很多内容与 &#x2F;proc&#x2F;[pid]&#x2F;stat 和 &#x2F;proc&#x2F;[pid]&#x2F;statm 相同，但是却是以一种更清晰地方式展现出来。举例如下： $ cat &#x2F;proc&#x2F;2406&#x2F;statusName: frpsState: S (sleeping)Tgid: 2406Ngid: 0Pid: 2406PPid: 2130TracerPid: 0Uid: 0 0 0 0Gid: 0 0 0 0FDSize: 128Groups: 0NStgid: 2406NSpid: 2406NSpgid: 2406NSsid: 2130VmPeak: 54880 kBVmSize: 54880 kBVmLck: 0 kBVmPin: 0 kBVmHWM: 34872 kBVmRSS: 10468 kBVmData: 47896 kBVmStk: 132 kBVmExe: 2984 kBVmLib: 0 kBVmPTE: 68 kBVmPMD: 20 kBVmSwap: 0 kBHugetlbPages: 0 kBThreads: 11SigQ: 0&#x2F;31834SigPnd: 0000000000000000ShdPnd: 0000000000000000SigBlk: 0000000000000000SigIgn: 0000000000000000SigCgt: fffffffe7fc1feffCapInh: 0000000000000000CapPrm: 0000003fffffffffCapEff: 0000003fffffffffCapBnd: 0000003fffffffffCapAmb: 0000000000000000Seccomp: 0Cpus_allowed: fCpus_allowed_list: 0-3Mems_allowed: 00000000,00000001Mems_allowed_list: 0voluntary_ctxt_switches: 2251028nonvoluntary_ctxt_switches: 18031 关于信号（signal）的信息：SigQ 分为两部分（例如 0&#x2F;31834），前面表示当前处在队列中的信号（0），后面则表示队列一共可以存储多少信号（31834）；SigPnd 表示当前线程 pending 的信号，而ShdPnd 则表示整个进程 pending 的信号；SigBlk、SigIgn 和 SigCgt 分别表示对信号的处理是阻塞，忽略，还是捕获。（关于Unix信号的相关知识，可以参考 Unix: Dealing with signals）。 &#x2F;proc&#x2F;[pid]&#x2F;syscall&#x2F;proc&#x2F;[pid]&#x2F;syscall 显示当前进程正在执行的系统调用。举例如下： $ cat &#x2F;proc&#x2F;2406&#x2F;syscall202 0xab3730 0x0 0x0 0x0 0x0 0x0 0x7ffff7f6ec68 0x455bb3 第一个值是系统调用号（202代表poll），后面跟着 6 个系统调用的参数值（位于寄存器中），最后两个值依次是堆栈指针和指令计数器的值。如果当前进程虽然阻塞，但阻塞函数并不是系统调用，则系统调用号的值为 -1，后面只有堆栈指针和指令计数器的值。如果进程没有阻塞，则这个文件只有一个 running 的字符串。 内核编译时打开了 CONFIG_HAVE_ARCH_TRACEHOOK 编译选项，才会生成这个文件。 &#x2F;proc&#x2F;[pid]&#x2F;wchan&#x2F;proc&#x2F;[pid]&#x2F;wchan 显示当进程 sleep 时，kernel 当前运行的函数。举例如下： $ cat &#x2F;proc&#x2F;2406&#x2F;wchanfutex_wait_queue_meadmin","tags":["Linux"],"categories":["Linux"]},{"title":"查找内核符号","path":"/posts/查找内核符号.html","content":"一、&#x2F;proc&#x2F;kallsyms 内核符号可以通过&#x2F;proc&#x2F;kallsyms查看。 (1)符号类型说明 在Linux内核中，kallsyms是一个符号表，它包含了内核中所有的符号信息，包括函数、变量、常量等等。这些符号信息可以被内核模块和其他程序使用，这些符号类型可以帮助开发人员更好地理解内核中的符号信息，从而更好地进行内核开发和调试。 在kallsyms中，每个符号都有一个类型，表示它的用途。下面是一些常见的符号类型： T：表示该符号是一个函数，可以被其他代码调用。 t：表示该符号是一个局部函数，只能在当前文件中使用。 D：表示该符号是一个全局变量，可以被其他代码访问和修改。 d：表示该符号是一个局部变量，只能在当前文件中使用。 R：表示该符号是一个只读变量，不能被修改。 r：表示该符号是一个只读局部变量，只能在当前文件中使用 A：表示该符号是一个可读写的变量，可以被其他代码访问和修改。 a：表示该符号是一个可读写的局部变量，只能在当前文件中使用。 B：表示该符号是一个未初始化的全局变量，它的值在程序启动时被初始化为0。 b：表示该符号是一个未初始化的局部变量，它的值在程序启动时被初始化为0。 G：表示该符号是一个全局变量，但是它的值在程序运行时可能会被修改。 C：表示该符号是一个常量，它的值在程序运行时不能被修改。 W：表示该符号是一个弱符号， ?: 表示该符号的类型未知。 (2)弱符号关于弱符号的一些说明：__weak 是一个关键字，用于声明一个弱符号。在 C 语言中，如果一个符号被定义了多次，编译器会报错。但是，如果一个符号被声明为弱符号，那么编译器就不会报错，而是在链接时选择其中一个符号作为最终的符号。这个特性在编写库时非常有用，因为它允许用户在链接时覆盖库中的函数。 如下为一个例子： 123456789101112131415161718192021222324252627282930313233/** * probe_kernel_read(): safely attempt to read from a location * @dst: pointer to the buffer that shall take the data * @src: address to read from * @size: size of the data chunk * * Safely read from address @src to the buffer at @dst. If a kernel fault * happens, handle that and return -EFAULT. * * We ensure that the copy_from_user is executed in atomic context so that * do_page_fault() doesn&#x27;t attempt to take mmap_sem. This makes * probe_kernel_read() suitable for use within regions where the caller * already holds mmap_sem, or other locks which nest inside mmap_sem. */long __weak probe_kernel_read(void *dst, const void *src, size_t size) __attribute__((alias(&quot;__probe_kernel_read&quot;)));long __probe_kernel_read(void *dst, const void *src, size_t size)&#123; long ret; mm_segment_t old_fs = get_fs(); set_fs(KERNEL_DS); pagefault_disable(); ret = __copy_from_user_inatomic(dst, (__force const void __user *)src, size); pagefault_enable(); set_fs(old_fs); return ret ? -EFAULT : 0;&#125;EXPORT_SYMBOL_GPL(probe_kernel_read); (3)内核驱动获取符号地址符号存在于&#x2F;proc&#x2F;kallsyms 文件中，可以通过kallsyms_lookup_name获取其符号的地址。在内核版本 2.6.33 - 5.7.0 可以用kallsyms_lookup_name来获取该函数的地址。在内核2.6.33 以下和 5.7.0 以上可以用 kprobe 来获取该函数的地址 kallsyms_lookup_name是内核API，源码如下： 使用kallsyms_lookup_name函数需要#include &lt;linux/kallsyms.h&gt; 12345678910111213141516/* Lookup the address for this symbol. Returns 0 if not found. */unsigned long kallsyms_lookup_name(const char *name)&#123; char namebuf[KSYM_NAME_LEN]; unsigned long i; unsigned int off; for (i = 0, off = 0; i &lt; kallsyms_num_syms; i++) &#123; off = kallsyms_expand_symbol(off, namebuf, ARRAY_SIZE(namebuf)); if (strcmp(namebuf, name) == 0) return kallsyms_sym_address(i); &#125; return module_kallsyms_lookup_name(name);&#125;EXPORT_SYMBOL_GPL(kallsyms_lookup_name); 上述函数可以使用符号名找到在内核中的地址，使用该方法可以使用内核中未导出的内核函数。如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * text_poke - Update instructions on a live kernel * @addr: address to modify * @opcode: source of the copy * @len: length to copy * * Only atomic text poke/set should be allowed when not doing early patching. * It means the size must be writable atomically and the address must be aligned * in a way that permits an atomic write. It also makes sure we fit on a single * page. */void *text_poke(void *addr, const void *opcode, size_t len)&#123; unsigned long flags; char *vaddr; struct page *pages[2]; int i; /* * While boot memory allocator is runnig we cannot use struct * pages as they are not yet initialized. */ BUG_ON(!after_bootmem); lockdep_assert_held(&amp;text_mutex); if (!core_kernel_text((unsigned long)addr)) &#123; pages[0] = vmalloc_to_page(addr); pages[1] = vmalloc_to_page(addr + PAGE_SIZE); &#125; else &#123; pages[0] = virt_to_page(addr); WARN_ON(!PageReserved(pages[0])); pages[1] = virt_to_page(addr + PAGE_SIZE); &#125; BUG_ON(!pages[0]); local_irq_save(flags); set_fixmap(FIX_TEXT_POKE0, page_to_phys(pages[0])); if (pages[1]) set_fixmap(FIX_TEXT_POKE1, page_to_phys(pages[1])); vaddr = (char *)fix_to_virt(FIX_TEXT_POKE0); memcpy(&amp;vaddr[(unsigned long)addr &amp; ~PAGE_MASK], opcode, len); clear_fixmap(FIX_TEXT_POKE0); if (pages[1]) clear_fixmap(FIX_TEXT_POKE1); local_flush_tlb(); sync_core(); /* Could also do a CLFLUSH here to speed up CPU recovery; but that causes hangs on some VIA CPUs. */ for (i = 0; i &lt; len; i++) BUG_ON(((char *)addr)[i] != ((char *)opcode)[i]); local_irq_restore(flags); return addr;&#125; text_poke为非导出函数，在驱动中无法使用，可以使用kallsyms_lookup_name获取函数地址并赋值给函数指针，便可以使用该函数。 12void *(*text_poke_fn)(void *addr, const void *opcode, size_t len);text_poke_fn = (void *(*)(void *, const void *, size_t))kallsyms_lookup_nama(&quot;text_poke&quot;);","tags":["Linux"],"categories":["Linux"]},{"title":"OOM","path":"/posts/OOM.html","content":"在Linux操作系统中，OOM（Out of Memory）指的是系统可用内存耗尽，无法再为任何进程分配所需的内存，从而导致系统必须采取某些极端措施的情况。当系统面临OOM时，可能会选择杀死某些进程以释放内存，这是通过Linux内核的OOM Killer机制实现的。 OOM发生的原因： 物理内存不足：实际物理内存资源耗尽，无法满足所有进程的内存需求，尤其是当大量进程同时运行且内存占用较大时更容易出现。 交换空间不足：即使有交换分区（Swap），但当系统试图将物理内存中的页换出到交换空间时，发现交换空间也已满，无法继续进行内存交换。 内存泄漏：应用程序存在内存泄漏问题，随着时间推移不断消耗内存，直至耗尽整个系统资源。 一次性加载大量数据：某个进程瞬间请求大量内存，超出了系统所能提供的范围。 内存限制：在容器环境下，单个容器可能存在严格的内存限制，超出限制后也会触发OOM。","tags":["Linux"],"categories":["Linux"]},{"title":"ftpget","path":"/posts/ftpget.html","content":"ftpget -u username -p passwd IP source target ftpput -u username -p passwd IP target source 举个例子： 12ftpput -u zhangsan -p 000000 192.168.10.10 target.txt source.txt // 将本地的 source.txt 文件传输到 192.168.10.10 /home/zhangsan/ 目录下，并以target.txt 保存","tags":["Linux工具"],"categories":["Linux工具"]},{"title":"scp","path":"/posts/scp.html","content":"一、从本地复制到远程主机命令格式如下： scp &#x2F;path&#x2F;to&#x2F;local&#x2F;file.txt user@remote_host:&#x2F;path&#x2F;on&#x2F;remote&#x2F; 这会将本地的 file.txt 文件复制到远程主机 remote_host 的 /path/on/remote/ 目录下。 二、从远程主机复制到本地（1）命令解释命令格式如下：scp user@remote_host:&#x2F;path&#x2F;on&#x2F;remote&#x2F;file.txt &#x2F;path&#x2F;to&#x2F;local&#x2F; 这会将远程主机 remote_host 的 /path/on/remote/file.txt 文件复制到本地的 /path/to/local/ 目录下。 （2）实际操作实操命令如下：scp &#114;&#x6f;&#x6f;&#116;&#x40;&#x31;&#x39;&#x32;&#x2e;&#x31;&#x36;&#x38;&#x2e;&#x31;&#46;&#x31;&#48;&#x39;:&#x2F;home&#x2F;DataBaseMysql.zip .&#x2F; 这会将远程主机 192.168.1.109 的&#x2F;home&#x2F;DataBaseMysql.zip 文件复制到本地的当前目录下 三、递归复制目录实操命令如下：scp -r user@remote_host:&#x2F;path&#x2F;on&#x2F;remote&#x2F;directory &#x2F;path&#x2F;to&#x2F;local&#x2F; 这会将远程主机 remote_host 的 /path/on/remote/directory 目录及其所有内容复制到本地的 /path/to/local/ 目录下。 四、指定 SSH 端口如果远程主机的 SSH 端口不是默认的 22，可以使用 -P 选项指定端口： scp -P 2222 user@remote_host:&#x2F;path&#x2F;on&#x2F;remote&#x2F;file.txt &#x2F;path&#x2F;to&#x2F;local&#x2F;","tags":["Linux工具"],"categories":["Linux工具"]},{"title":"find","path":"/posts/find.html","content":"find . -name “my_file” find . -name &#x2F;etc -type d","tags":["Linux工具"],"categories":["Linux工具"]},{"title":"grep","path":"/posts/grep.html","content":"文本搜索工具，根据用户指定的“模式”（过滤条件），对目标文本逐行进行匹配，并打印输出匹配到的行。 完整语法： 123grep [options] [pattern] file 命令 参数 匹配模式 文件数据 常用参数： 常用参数 描述 -i 忽略大小写 -n 显示匹配行与行号 -r 递归查找子目录 -v 显示不能被匹配到的字符串 常用正则表达式 表达式\t解释 ^\t用于模式最左侧，如 “^yu” 即匹配以yu开头的单词 $\t用于模式最右侧，如 “yu$” 即匹配以yu结尾的单词 ^$\t组合符，表示空行 .\t匹配任意一个且只有一个字符，不能匹配空行 |\t使用egrep命令 重匹配前一个字符连续出现0次或1次以上 .*\t匹配任意字符 ^.*\t组合符，匹配任意多个字符开头的内容 .*$\t组合符，匹配任意多个字符结尾的内容 [abc]\t匹配 [] 内集合中的任意一个字符，a或b或c，也可以写成 [ac] [^abc]\t匹配除了 ^后面的任意一个字符，a或b或c，[]内 ^ 表示取反操作 常用： 1grep -nr &quot;xxx&quot; .","tags":["Linux工具"],"categories":["Linux工具"]},{"title":"内存检测工具","path":"/posts/内存检测工具.html","content":"在写大型C&#x2F;C++工程时难免会发生内存泄漏现象，系统编程中一个重要的方面就是有效地处理与内存相关的问题。你的工作越接近系统，你就需要面对越多的内存问题。有时这些问题非常琐碎，而更多时候它会演变成一个调试内存问题的恶梦。 常见的内存问题一共七种： 动态内存泄露； 资源泄露，比如文件指针不关闭； 动态内存越界； 4.数组内存越界； 5.动态内存double free； 6.使用野指针，即未初始化的指针； 7.释放野指针，即未初始化的指针。 内存问题非常难定位，对于小工程来说，简单去检查代码中new和delete的匹配对数就基本能定位到问题，但是一旦代码量上升到以万单位时，仅靠肉眼检查来定位问题那就非常困难了，所以我们需要利用工具帮助我们找出问题所在。在Linux系统下内存检测工具首推Valgrind，一款非常好用的开源内存管理框架。Valgrind其实是一个工具集，内存错误检测只是它众多功能的一个，但我们用得最多的功能正是它——memcheck。 该工具可以检测下列与内存相关的问题 : 未释放内存的使用 对释放后内存的读&#x2F;写 对已分配内存块尾部的读&#x2F;写 内存泄露 不匹配的使用malloc&#x2F;new&#x2F;new[] 和 free&#x2F;delete&#x2F;delete[] 重复释放内存 首先安装Valgrind非常简单： 123456789//valgrind下载：http://valgrind.org/downloads/valgrind-3.12.0.tar.bz2valgrind安装：1. tar -jxvf valgrind-3.12.0.tar.bz22. cd valgrind-3.12.03. ./configure4. make5. sudo make install 下面开始讲解Valgrind的应用场景。 注意: 下面讨论的所有测试代码都应该使用gcc&#x2F;g++并且加上-g选项。 1. 使用未初始化的内存（使用野指针）这里我们定义了一个指针p，但并未给他开辟空间，即他是一个野指针，但我们却使用它了。 Valgrind检测出我们程序使用了未初始化的变量，但并未检测出内存泄漏。 2.在内存被释放后进行读&#x2F;写（使用野指针）p所指向的内存被释放了，p变成了野指针，但是我们却继续使用这片内存。 Valgrind检测出我们使用了已经free掉的内存，并给出这片内存是哪里分配哪里释放的。 3.从已分配内存块的尾部进行读&#x2F;写（动态内存越界）我们动态地分配了一段数组，但我们在访问个数组时发生了越界读写，程序crash掉。 Valgrind检测出越界的位置。 注意：Valgrind不检查静态分配数组的使用情况！所以对静态分配的数组，Valgrind表示无能为力！比如下面的例子，程序crash掉，我们却不知道为什么。 4.内存泄漏内存泄漏的原因在于没有成对地使用malloc&#x2F;free和new&#x2F;delete，比如下面的例子。 Valgrind会给出程序中malloc和free的出现次数以判断是否发生内存泄漏，比如对上面的程序运行memcheck，Valgrind的记录显示上面的程序用了1次malloc，却调用了0次free，明显发生了内存泄漏！ 上面提示了我们可以使用–leak-check&#x3D;full进一步获取内存泄漏的信息，比如malloc和free的具体行号。 5. 不匹配地使用malloc&#x2F;new&#x2F;new[] 和 free&#x2F;delete&#x2F;delete[]正常使用new&#x2F;delete和malloc&#x2F;free是这样子的： 而不匹配地使用malloc&#x2F;new&#x2F;new[] 和 free&#x2F;delete&#x2F;delete[]则会被提示mismacth： 6.两次释放内存double free的情况同样是根据malloc&#x2F;free的匹配对数来体现的，比如free多了一次，Valgrind也会提示。 当然，Valgrind也不是万能的。Valgrind也有无法找到问题的时候，有些问题只能通过不断的review代码找到了症结。发现问题，解决问题，毕竟是末流。最好的方法，就是不引入内存问题。这可以通过良好的代码风格和设计来实现的。","tags":["Linux工具"],"categories":["Linux工具"]},{"title":"top","path":"/posts/top.html","content":"1ps -ef | grep xxx //xxx为进程名字 通过ps找到进程号，通过如下命令可以查看该进程下的所有线程CPU利用率，注意这里是该进程PID下对应的所有线程 1top -H -p pid 例如进程pid为5810，则命令为： 1top -H -p 5810 一、top命令的使用帮助1、top命令的选项top命令的使用方法：top [-d number] | top [-bnp] 选项 解析 -b 以批处理模式操作； -c 显示完整的治命令； -d 屏幕刷新间隔时间； -I 忽略失效过程； -s 保密模式； -S 累积模式； -i&lt;时间&gt; 设置间隔时间； -u&lt;用户名&gt; 指定用户名； -p&lt;进程号&gt; 指定进程； -n&lt;次数&gt; 循环显示的次数。 二、top命令的交换命令在top命令执行过程中可以使用的一些交互命令。这些命令都是单字母的，如果在命令行中使用了-s选项， 其中一些命令可能会被屏蔽。 也就是在top命令运行过程中，可以按下如下案件，会按照相应指令显示 1234567891011121314151617h：显示帮助画面，给出一些简短的命令总结说明；k：终止一个进程；i：忽略闲置和僵死进程，这是一个开关式命令；q：退出程序；r：重新安排一个进程的优先级别；S：切换到累计模式；s：改变两次刷新之间的延迟时间（单位为s），如果有小数，就换算成ms。输入0值则系统将不断刷新，默认值是5s；f或者F：从当前显示中添加或者删除项目；o或者O：改变显示项目的顺序；l：切换显示平均负载和启动时间信息；m：切换显示内存信息；t：切换显示进程和CPU状态信息；c：切换显示命令名称和完整命令行；M：以内存的使用资源排序显示；P：根据CPU使用百分比大小进行排序；T：根据时间/累计时间进行排序；w：将当前设置写入~/.toprc文件中。 三、top显示信息解释1、top的第一行解释在命令行输入top，进入系统监控信息的交互界面，第一行解释如下： 123410:40:53 表示当前时间up 7:09 系统运行时间，格式为时：分。3 users 当前登录用户数load average: 0.05, 0.03, 0.05 系统负载，即任务队列的平均长度。 三个数值分别为 1分钟、5分钟、15分钟前到现在的平均值。 2、top的第二、三行信息解释在命令行输入top，进入系统监控信息的交互界面，第2、3行为进程和CPU的信息，当有多个CPU时，这些内容可能会超过两行， 第二行解释如下： 12345678910111213216 total 进程总数1 running 正在运行的进程数215 sleeping 睡眠的进程数0 stopped 停止的进程数0 zombie 僵尸进程数0.0 us 用户空间占用CPU百分比0.1 sy 内核空间占用CPU百分比0.0 ni 用户进程空间内改变过优先级的进程占用CPU百分比99.9 id 空闲CPU百分比0.0 wa 等待输入输出的CPU时间百分比0.0 hi 硬中断（Hardware IRQ）占用CPU的百分比0.0 si 软中断（Software Interrupts）占用CPU的百分比0.0 st 虚拟CPU等待实际CPU的时间的百分比。 3、top的第四、五行信息解释第四行及第五行主要显示系统的内存信息。 123456789KiB Mem: 12119056 tota 物理内存总量10016948 free 空闲内存总量923252 used 使用的物理内存总量1178856 buff/cache 用作内核缓存的内存量KiB Swap: 2093052 total 交换区总量267544 used 使用的交换区总量2093052 free 空闲交换区总量0 used 缓冲的交换区总量。10742188 avail Mem 代表可用于进程下一次分配的物理内存数量 4、top的进程信息top命令的交换界面主要区域，监控系统进程的实时状态信息。 123456789101112PID 进程idUSER 进程所有者的用户名PR 优先级NI nice值，负值表示高优先级，正值表示低优先级。VIRT 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RESRES 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATASHR 共享内存大小，单位kbS 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程%CPU 上次更新到现在的CPU时间占用百分比%MEM 进程使用的物理内存百分比TIME+ 进程使用的CPU时间总计，单位1/100秒COMMAND 命令名/命令行 其余监控项解释 1234567891011121314PPID 父进程idRUSER Real user nameUID 进程所有者的用户idGROUP 进程所有者的组名TTY 启动进程的终端名。不是从终端启动的进程则显示为 ?P 最后使用的CPU，仅在多CPU环境下有意义TIME 进程使用的CPU时间总计，单位秒SWAP 进程使用的虚拟内存中，被换出的大小，单位kbCODE 可执行代码占用的物理内存大小，单位kbDATA 可执行代码以外的部分(数据段+栈)占用的物理内存大小，单位kbnFLT 页面错误次数nDRT 最后一次写入到现在，被修改过的页面数。WCHAN 若该进程在睡眠，则显示睡眠中的系统函数名Flags 任务标志 四、top命令的基本使用1、查看当前系统cpu占用最高的进程 进入top交互界面后，按P键对CPU负载的进程进行排列。 2、查看当前系统内存使用最高的进程 进入top交互界面后，按M键对CPU负载的进程进行排列。 3、对排序的列进行高亮显示 敲击键盘‘x’（打开&#x2F;关闭排序列的加亮效果） 4、对运行的进程进行高亮显示 敲击键盘‘b’（打开关闭加亮效果），对运行的进程进行高亮显示","tags":["Linux工具"],"categories":["Linux工具"]},{"title":"tcpdump","path":"/posts/tcpdump.html","content":"tmpdump用于抓包，一个例子： 1tcpdump -i any host 192.168.x.x -s0 -vvv -w 1.cap -i any 任何网络 -s0 防止截断 -w写入文件 -vvv详细的信息 最终得到一个名为1.cap的文件，可以使用wireshark工具打开","tags":["Linux工具"],"categories":["Linux工具"]},{"title":"sed","path":"/posts/sed.html","content":"https://blog.csdn.net/2301_78315274/article/details/133880462 1、将每行第一个111替换为AAA 1sed -i &quot;s/111/AAA/&quot; a.txt -i作用会修改源文件，如这里的a.txt，如果不加-i就不会修改，只是命令回显改变了 2、替换所有的111为AAA 11. sed -i &quot;s/111/AAA/g&quot; a.txt 3、替换第一到四行的所有111为AAA 1sed &quot;1,4s/111/AAA/g&quot; a.txt","tags":["Linux工具"],"categories":["Linux工具"]},{"title":"tar","path":"/posts/tar.html","content":"tar全称是tape archive，初衷是将多个文件写入磁带。首先，需要分清两个概念——打包与压缩。打包：将多个文件汇总成一个文件。压缩：将一个大文件通过压缩算法变成一个小文件。而tar命令执行的打包流程，真正执行压缩的是使用的压缩算法，比如gzip、bzip2、xz。tar命令在Linux社区内十分受欢迎，其中一个原因就是灵活性强，可以根据需要选择不同的压缩算法。 一、常用参数 打包过程 -c或--create。创建档案文件（可以理解为压缩包名） -x或--extract。解压（提取）文件 -f或--file。指定档案文件，告诉tar命令，后面是文件名 -t或--list。列出档案文件的内容 -v或--verbose。显示处理文件的详细信息 当多个参数简写在一起的时候，可以只用一个-。在实际使用中，最常使用的参数就是-cvf，即创建压缩包，并以显示详细处理信息。 压缩过程 gzip：参数-z或--gzip；文件拓展名：.tar.gz或.tgz bzip2：-j或--bzip2；.tar.bz2 xz：-J或--xz；.tar.xz 压缩算法之间的区别： 压缩算法 gzip bzip2 xz 参数 -z -j -J 文件拓展名 .tar.gz .tar.bz2 .tar.xz 压缩速度 快 中 慢 解压速度 快 中 中 压缩比 低 中 高 资源占用 少 中 高 适用场景 快速压缩&#x2F;解压 高压缩比 最大压缩比 在日常使用中，使用gzip压缩就可以了，虽然压缩比低，但是它十分的快。并且如果被压缩的文件本身就比较小，使用xz压缩的结果也不会少太多。因此，日常使用建议gzip，既想要速度也想要压缩比建议bzip2，超大文件建议xz。 二、示例流程相似，只需更换压缩算法的参数。 1234567# 压缩。压缩包名 + 被压缩的目录或者文件路径tar -czvf archive_name.tar.gz path_to_compress# 解压。用什么压缩算法压缩的，就用什么压缩算法解压tar -xzvf archive_name.tar.gz # 解压到当前目录tar -xzvf archive_name.tar.gz -C path_to_extract # 解压至指定目录。 -C （change directory）指出目录地址","tags":["Linux工具"],"categories":["Linux工具"]},{"title":"objdump","path":"/posts/objdump.html","content":"objdump提供了对二进制文件进行反汇编和查看目标文件信息的能力。用于分析目标文件（object file）和可执行文件（executable file）。它可以显示二进制文件的汇编代码、符号表、段信息等，是理解程序底层实现、调试和逆向工程的有力助手。 一、objdump的基本用法显示目标文件的反汇编代码： 1objdump -d your_binary 该命令会显示目标文件中所有段的反汇编代码。这是一种深入了解程序执行逻辑的方式。 显示符号表信息： 1objdump -t your_binary 该命令会显示目标文件的符号表，包括函数名、变量名等信息。 显示文件头信息： 1objdump -f your_binary 该命令显示目标文件的文件头信息，包括文件格式、入口点地址等。objdump 的使用还可以根据需求加入一些参数来获取更详细的信息。 显示所有段的详细信息： 1objdump -p your_binary 这将显示目标文件中所有段的详细信息，包括每个段的大小、偏移量等。 显示特定段的反汇编代码： 1objdump -s -j section_name your_binary 这将显示指定段（section_name）的反汇编代码。 只显示符号表的信息： 1objdump -T your_binary 该命令显示符号表的信息，但不显示反汇编代码。 显示源代码和反汇编代码： 1objdump -S your_binary 这将显示源代码和反汇编代码的混合视图，方便理解源代码和汇编之间的对应关系。 以指定格式显示反汇编代码： 1objdump -M intel -d your_binary -M 参数允许你指定反汇编代码的输出格式，例如 intel 或 att。 以上是一些常见的 objdump 用法和参数。通过组合使用这些参数，你可以根据具体的需求更深入地了解目标文件的内部结构和代码执行逻辑。","tags":["Linux工具"],"categories":["Linux工具"]},{"title":"objcopy","path":"/posts/objcopy.html","content":"objcopy转换elf文件为bin文件，以下是一个将boot.elf转为boot.bin的命令 1arm-linux-objcopy -O binary -R .note -R .comment -S boot.elf boot.bin 使用 -O binary (或–out-target&#x3D;binary) 输出为原始的二进制文件 使用 -R .note (或–remove-section) 输出文件中不要.note这个section，缩小了文件尺寸 使用 -S (或 –strip-all) 输出文件中不要重定位信息和符号信息，缩小了文件尺寸","tags":["Linux工具"],"categories":["Linux工具"]},{"title":"nm","path":"/posts/nm.html","content":"nm命令是linux下针对某些特定文件的分析工具，能够列出库文件（.a、.lib）、目标文件（*.o）、可执行文件的符号表。 一、nm命令的常用参数 -A 或 -o 或 –print-file-name：打印出每个符号属于的文件 -a 或 –debug-syms：显示调试符号。 -B：等同于–format&#x3D;bsd，用来兼容MIPS的nm。 -C 或 –demangle：将低级符号名解码(demangle)成用户级名字。这样可以使得C++函数名具有可读性。 -D 或 –dynamic：显示动态符号。该任选项仅对于动态目标(例如特定类型的共享库)有意义。 -f forma 或 –format&#x3D;formatt：使用format格式输出。format可以选取bsd、sysv或posix，该选项在GNU的nm中有用。默认为bsd。 -g 或 –extern-only：仅显示外部符号。 -n 、-v 或 –numeric-sort：按符号对应地址的顺序排序，而非按符号名的字符顺序。 -p 或 –no-sort：按目标文件中遇到的符号顺序显示，不排序。 -P 或 –portability：使用POSIX.2标准输出格式代替默认的输出格式。等同于使用任选项-f posix。 -s 或 –print-armap：当列出库中成员的符号时，包含索引。索引的内容包含：哪些模块包含哪些名字的映射。 -r 或 –reverse-sort：反转排序的顺序(例如，升序变为降序)。 –size-sort：按大小排列符号顺序。该大小是按照一个符号的值与它下一个符号的值进行计算的。 -t radix 或 –radix&#x3D;radix：使用radix进制显示符号值。radix只能为“d”表示十进制、“o”表示八进制或“x”表示十六进制。 –target&#x3D;bfdname：指定一个目标代码的格式，而非使用系统的默认格式。 -u 或 –undefined-only：仅显示没有定义的符号(那些外部符号)。 -l 或 –line-numbers：对每个符号，使用调试信息来试图找到文件名和行号。对于已定义的符号，查找符号地址的行号。对于未定义符号，查找指向符号重定位入口的行号。如果可以找到行号信息，显示在符号信息之后。 -V 或 –version：显示nm的版本号。 –help：显示nm的任选项。 举个栗子 编写源文件test.c 1234567891011#include &lt;stdio.h&gt;const char ch = &#x27;x&#x27;;int uninit;int init = 10;void function() &#123; int *ref = &amp;init; static int sta_int = 10; printf(&quot;%c&quot;, ch);&#125; 编译test.c文件 生成test.o gcc -c test.c 用nm命令分析符号表 nm -n test.o（-n以地址排序，方便查看） 输出结果： 123456 U putchar0000000000000000 R ch0000000000000000 T function0000000000000000 D init0000000000000004 d sta_int.21820000000000000004 C uninit 二、nm信息的含义第一列：符号值，即该符号的起始地址第二列：符号类型，各字母代表什么类型在下一小节中介绍第三列：符号名称 三、输出符号类型详解符号类型大写代表全局符号，小写代表本地符号 A 该符号的值是绝对的，在以后的链接过程中，不允许进行改变。这样的符号值，常常出现在中断向量表中，例如用符号来表示各个中断向量函数在中断向量表中的位置。 B 该符号的值出现在非初始化数据段(bss)中。例如，在一个文件中定义全局static int test。则该符号test的类型为b，位于bss section中。其值表示该符号在bss段中的偏移。一般而言，bss段分配于RAM中。 C 该符号为common。common symbol是未初始话数据段。该符号没有包含于一个普通section中。只有在链接过程中才进行分配。符号的值表示该符号需要的字节数。例如在一个c文件中，定义int test，并且该符号在别的地方会被引用，则该符号类型即为C。否则其类型为B。 D 该符号位于初始话数据段中。一般来说，分配到data section中。例如定义全局int baud_table[5] &#x3D; {9600, 19200, 38400, 57600, 115200}，则会分配于初始化数据段中。 G 该符号也位于初始化数据段中。主要用于small object提高访问small data object的一种方式。 I 该符号是对另一个符号的间接引用。 N 该符号是一个debugging符号。 R 该符号位于只读数据区。例如定义全局const int test[] &#x3D; {123, 123};则test就是一个只读数据区的符号。注意在cygwin下如果使用gcc直接编译成MZ格式时，源文件中的test对应_test，并且其符号类型为D，即初始化数据段中。但是如果使用m6812-elf-gcc这样的交叉编译工具，源文件中的test对应目标文件的test,即没有添加下划线，并且其符号类型为R。一般而言，位于rodata section。值得注意的是，如果在一个函数中定义const char *test &#x3D; “abc”, const char test_int &#x3D; 3。使用nm都不会得到符号信息，但是字符串“abc”分配于只读存储器中，test在rodata section中，大小为4。 S 符号位于非初始化数据区，用于small object。 T 该符号位于代码区text section。 U 该符号在当前文件中是未定义的，即该符号的定义在别的文件中。例如，当前文件调用另一个文件中定义的函数，在这个被调用的函数在当前就是未定义的；但是在定义它的文件中类型是T。但是对于全局变量来说，在定义它的文件中，其符号类型为C，在使用它的文件中，其类型为U。 V 该符号是一个weak object。 W 该符号是没有被明确标记为weak object的弱符号类型。 该符号是a.out格式文件中的stabs symbol。 ? 该符号类型没有定义。","tags":["Linux工具"],"categories":["Linux工具"]},{"title":"readelf","path":"/posts/readelf.html","content":"一、三类目标文件（ELF）：1.可重定位目标文件 (.o ) 每个 .o 文件都是由对应的 .c 文件通过编译器和汇编器生成；包含代码和数据，代码和数据地址都从0开始。通过 gcc -c xxx.c 得到。 2.可执行目标文件（默认为a.out） 由链接器生成，包含的代码和数据可以直接通过加载器加载到内存中并被执行。通过gcc -o xxx.c 得到。 3.共享目标文件 (.so） 特殊的可重定位目标文件，可以在链接(静态共享库)时加入目标文件或加载时或运行时(动态共享库)被动态的加载到内存并执行。在 windows 中被称为 Dynamic Link Libraries(DLLs)。 gcc xxx.c -fPIC -shared -o libxxx.so （-fPIC 作用于编译阶段，告诉编译器产生与位置无关代码。） readelf命令： 通过readelf来区分上面三种类型的ELF文件，每种类型文件的头部信息是不一样的。 二、readelf -hreadelf -h main.o -h等价于–file-header 1234567891011121314151617181920 1 ELF Header: 2 Magic: 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 3 Class: ELF64 4 Data: 2&#x27;s complement, little endian 5 Version: 1 (current) 6 OS/ABI: UNIX - System V 7 ABI Version: 0 8 Type: REL (Relocatable file) 9 Machine: Advanced Micro Devices X86-6410 Version: 0x111 Entry point address: 0x012 Start of program headers: 0 (bytes into file)13 Start of section headers: 720 (bytes into file)14 Flags: 0x015 Size of this header: 64 (bytes)16 Size of program headers: 0 (bytes)17 Number of program headers: 018 Size of section headers: 64 (bytes)19 Number of section headers: 1220 Section header string table index: 11 第 1 行，ELF Header: 指名 ELF 文件头开始。 第 2 行，Magic 魔数，用来指名该文件是一个 ELF 目标文件。第一个字节 7F 是个固定的数；后面的 3 个字节正是 E, L, F 三个字母的 ASCII 形式。 第 3 行，CLASS 表示文件类型，这里是 64位的 ELF 格式。 第 4 行，Data 表示文件中的数据是按照什么格式组织(大端或小端)的，不同处理器平台数据组织格式可能就不同，如x86平台为小端存储格式。 第 5 行，当前 ELF 文件头版本号，这里版本号为 1 。 第 6 行，OS&#x2F;ABI ，指出操作系统类型，ABI 是 Application Binary Interface 的缩写。 第 7 行，ABI 版本号，当前为 0 。 第 8 行，Type 表示文件类型。ELF 文件有 3 种类型，一种是如上所示的 Relocatable file 可重定位目标文件，一种是可执行文件(Executable)，另外一种是共享库(Shared Library) 。 [这里就是区分上面三种类型的ELF文件] 第 9 行，机器平台类型，这里是在X86-64位机器。 第 10 行，当前目标文件的版本号。 第 11 行，程序的虚拟地址入口点，因为这还不是可运行的程序，故而这里为零。如果是可运行程序，这个地址并不是main函数的地址，而是_start函数的地址，_start由链接器创建，_start是为了初始化程序。通过这个命令可以看到_start函数，objdump -d -j .text a.out(默认，改名之后需更改此处)。 第 12 行，与 11 行同理，这个目标文件没有 Program Headers。 第 13 行，sections 头开始处，这里 720 是十进制，表示从地址偏移 0x450 处开始。 第 14 行，是一个与处理器相关联的标志，x86 平台上该处为 0 。 第 15 行，ELF 文件头的字节数。64bytes 第 16 行，因为这个不是可执行程序，故此处大小为 0。 第 17 行，同理于第 16 行。 第 18 行，sections header 的大小，这里每个 section 头大小为 64bytes。 第 19 行，一共有多少个 section 头，这里是 12个。 第 20 行，section 头字符串表索引号。区中存储的信息是用来链接使用的，主要包括：程序代码、程序数据（变量）、重定向信息等。比如：Code section保存的是代码，data section保存的是初始化或未初始化的数据，等等。 三、readelf -S main功能：查看区内容 1234567891011121314151617181920212223242526272829303132333435361 There are 29 section headers, starting at offset 0x1948: 2 Section Headers: 3 [Nr] Name Type Address Offset Size EntSize Flags Link Info Align 4 [ 0] NULL 0000000000000000 00000000 0000000000000000 0000000000000000 0 0 0 5 [ 1] .interp PROGBITS 0000000000000238 00000238 000000000000001c 0000000000000000 A 0 0 1 6 [ 2] .note.ABI-tag NOTE 0000000000000254 00000254 0000000000000020 0000000000000000 A 0 0 4 7 [ 3] .note.gnu.build-i NOTE 0000000000000274 00000274 0000000000000024 0000000000000000 A 0 0 4 8 [ 4] .gnu.hash GNU_HASH 0000000000000298 00000298 000000000000001c 0000000000000000 A 5 0 8 9 [ 5] .dynsym DYNSYM 00000000000002b8 000002b8 0000000000000090 0000000000000018 A 6 1 810 [ 6] .dynstr STRTAB 0000000000000348 00000348 000000000000007d 0000000000000000 A 0 0 111 [ 7] .gnu.version VERSYM 00000000000003c6 000003c6 000000000000000c 0000000000000002 A 5 0 212 [ 8] .gnu.version_r VERNEED 00000000000003d8 000003d8 0000000000000020 0000000000000000 A 6 1 813 [ 9] .rela.dyn RELA 00000000000003f8 000003f8 00000000000000c0 0000000000000018 A 5 0 814 [10] .init PROGBITS 00000000000004b8 000004b8 0000000000000017 0000000000000000 AX 0 0 415 [11] .plt PROGBITS 00000000000004d0 000004d0 0000000000000010 0000000000000010 AX 0 0 1616 [12] .plt.got PROGBITS 00000000000004e0 000004e0 0000000000000008 0000000000000008 AX 0 0 817 [13] .text PROGBITS 00000000000004f0 000004f0 00000000000001e2 0000000000000000 AX 0 0 1618 [14] .fini PROGBITS 00000000000006d4 000006d4 0000000000000009 0000000000000000 AX 0 0 419 [15] .rodata PROGBITS 00000000000006e0 000006e0 0000000000000004 0000000000000004 AM 0 0 420 [16] .eh_frame_hdr PROGBITS 00000000000006e4 000006e4 0000000000000044 0000000000000000 A 0 0 421 [17] .eh_frame PROGBITS 0000000000000728 00000728 0000000000000128 0000000000000000 A 0 0 822 [18] .init_array INIT_ARRAY 0000000000200df0 00000df0 0000000000000008 0000000000000008 WA 0 0 823 [19] .fini_array FINI_ARRAY 0000000000200df8 00000df8 0000000000000008 0000000000000008 WA 0 0 824 [20] .dynamic DYNAMIC 0000000000200e00 00000e00 00000000000001c0 0000000000000010 WA 6 0 825 [21] .got PROGBITS 0000000000200fc0 00000fc0 0000000000000040 0000000000000008 WA 0 0 826 [22] .data PROGBITS 0000000000201000 00001000 0000000000000018 0000000000000000 WA 0 0 827 [23] .bss NOBITS 0000000000201018 00001018 0000000000000008 0000000000000000 WA 0 0 128 [24] .comment PROGBITS 0000000000000000 00001018 000000000000002b 0000000000000001 MS 0 0 129 [25] .symtab SYMTAB 0000000000000000 00001048 0000000000000600 0000000000000018 26 43 830 [26] .strtab STRTAB 0000000000000000 00001648 0000000000000200 0000000000000000 0 0 131 [27] .shstrtab STRTAB 0000000000000000 00001848 00000000000000f9 0000000000000000 0 0 132 Key to Flags:33 W (write), A (alloc), X (execute), M (merge), S (strings), I (info),34 L (link order), O (extra OS processing required), G (group), T (TLS),35 C (compressed), x (unknown), o (OS specific), E (exclude),36 l (large), p (processor specific) .text：已编译程序的机器代码（二进制指令），该区的标志为X表示可执行。 .rodata：只读数据，比如printf语句中的格式串和开关（switch）语句的跳转表。 .data：已初始化的全局C变量。局部C变量在运行时被保存在栈中，既不出现在.data中，也不出现在.bss节中。 .bss：未初始化的全局C变量。在目标文件中并没有分配实际的空间给它，它只是一个占位符。目标文件格式区分初始化和未初始化变量是为了空间效率在：在目标文件中，未初始化变量不需要占据任何实际的磁盘空间。 .symtab：一个符号表（symbol table），它存放在程序中被定义和引用的函数和全局变量的信息。一些程序员错误地认为必须通过-g选项来编译一个程序，得到符号表信息。实际上，每个可重定位目标文件在.symtab中都有一张符号表。然而，和编译器中的符号表不同，.symtab符号表不包含局部变量的表目。 .rel.text：当链接噐把这个目标文件和其他文件结合时，.text节中的许多位置都需要修改。一般而言，任何调用外部函数或者引用全局变量的指令都需要修改。另一方面调用本地函数的指令则不需要修改。注意，可执行目标文件中并不需要重定位信息，因此通常省略，除非使用者显式地指示链接器包含这些信息。 .rel.data：被模块定义或引用的任何全局变量的信息。一般而言，任何已初始化全局变量的初始值是全局变量或者外部定义函数的地址都需要被修改。 .strtab：一个字符串表，其内容包括.symtab和.debug节中的符号表，以及节头部中的节名字。字符串表就是以null结尾的字符串序列。 .init和.fini保存了进程初始化和结束所用的代码，这通常是由编译器自动添加的。 四、readelf -sreadelf -s main.o 功能：查看符号表，Value的值是符号的地址。 1234567891011121314Symbol table &#x27;.symtab&#x27; contains 12 entries: Num: Value Size Type Bind Vis Ndx Name 0: 0000000000000000 0 NOTYPE LOCAL DEFAULT UND 1: 0000000000000000 0 FILE LOCAL DEFAULT ABS main.c 2: 0000000000000000 0 SECTION LOCAL DEFAULT 1 3: 0000000000000000 0 SECTION LOCAL DEFAULT 3 4: 0000000000000000 0 SECTION LOCAL DEFAULT 4 5: 0000000000000000 0 SECTION LOCAL DEFAULT 6 6: 0000000000000000 0 SECTION LOCAL DEFAULT 7 7: 0000000000000000 0 SECTION LOCAL DEFAULT 5 8: 0000000000000000 8 OBJECT GLOBAL DEFAULT 3 array 9: 0000000000000000 33 FUNC GLOBAL DEFAULT 1 main 10: 0000000000000000 0 NOTYPE GLOBAL DEFAULT UND _GLOBAL_OFFSET_TABLE_ 11: 0000000000000000 0 NOTYPE GLOBAL DEFAULT UND sum 符号表保存了程序实现或使用的所有全局变量和函数，如果程序引用一个自身代码未定义的符号，则称之为未定义符号，这类引用必须在静态链接期间用其他目标模块或库解决，或在加载时通过动态链接解决。","tags":["Linux工具"],"categories":["Linux工具"]},{"title":"dm-verity","path":"/posts/dm-verity.html","content":"一、技术模块简介 Dm-verity 是 device-mapper 架构下的一个目标设备类型， 通过它来保障设备或者设备分区的完整性。 dm-verity通常用于验证镜像的完整性。比如常规的系统启动的对根文件系统的验签，耗时很长。可以使用dm-verity替代，由于dm-verity是使用时才进行hash计算校验，所以对启动性能的提高有很大帮助。 Dm-verity类型的目标设备有两个底层设备，一个是数据设备(data device), 是用来存储实际数据的，另一个是hash设备(hash device), 用来存储hash数据的，这个是用来校验data device数据的完整性的。 简单的架构图如下： 图中映射设备(Mapper Device)和目标设备(Target Device)是一对一关系，对映射设备的读操作被映射成对目标设备的读操作，在目标设备中，dm-verity又将读操作映射为数据设备（Data Device）的读操作。但是在读操作的结束处，dm-verity加了一个额外的校验操作，对读到的数据计算一个hash值，用这个哈希值和存储在哈希设备(Hash Device) 二、设计原理 对于本文要介绍的dm-verity功能模块，笔者选择在当前移动终端应用的角度来展开讲解，也就是Android平台在dm-verity的应用。 Android 端主要是在镜像启动时验证这个功能场景上使用到了 dm-verity 技术，该技术可以对块存储设备进行完整性检查，有助于阻止某些恶意程序对镜像的修改，有助于Android用户在启动设备时确认设备状态与上次使用时是否相同。在系统镜像(比如 system、vendor等)启动时以及运行时可以实时性监测当前镜像是否被篡改。 通过dm-verity技术，可以确认块设备内容是否跟预期一致，具体的实现原理是利用哈希树(hashtree)做到的。用以下图来形象说明 (图来自：https://source.android.com/security/verifiedboot/dm-verity) 简单说明一下这个插图背后的原理： 在编译(一般应该是运行open)阶段，首先会对系统镜像(比如system.img、vendor.img)按照每4k大小计算对应hash，将这些hash信息存起来，形成上面图中的layer 0层，紧接着会对 layer 0 层同样按照每4k大小计算hash，并将这层的hash信息存起来，形成layer 1层，以此类推，直至最后的hash信息存放在一个4k大小的块中(未填满使用0填充)，这里边存储的hash信息称为 root hash。 在运行阶段，对于镜像里的文件进行访问时，操作对应所在块设备的存储区域时，会计算当前存储块(按4k大小)的hash值，然后会跟存储在哈希树上对应块的hash值进行比较，如果匹配不上，则认为当前该文件在底层存储被篡改或是损坏了。 为了更形象的描述下镜像运行时如何利用哈希树做校验的，下面以一个1G大小的镜像为例，来说明一下这个过程： 根据 hashtree 的生成方式，以 1G 的镜像为例： 1）按照 4K 大小划分，将1G 大小的镜像依顺序划分可得到 262144 个 4k 大小的块 2）对这 262144 块数据块进行第一层(Level 0) hash 计算，由于 SHA256(具体的hash算法可配置，此例以SHA256为参考) 计算出来的hash值占 256 个字节，一个 4K 的块可以存储 128 个hash值，所以存储这 262144 块数据块的hash值需要花费 2048 块 3）对第一层存储 hash 值的数据块进行第二层(Level 1) 的 hash 计算，同理，计算这 2048 块hash数据块需要花费 16 块 4）对第二层存储 hash 值的数据块进行第三层(Level 2) 的 hash 计算，由于第二层的hash数据块小于128块，所以第三层是最后一层，直接计算得到 root hash 数据块(不够4K大小补齐0)。 细心的读者可能已经发现了，Level 0 层其实已经包含了所有raw data数据块的hash信息了，也就说明Level 0 层已经具备可以验证 raw data 的能力了，为何还需要在 Level 0 的基础上继续算hash组装下一个 Level 层级呢？ 这里要引入一个安全策略设计问题，镜像raw data数据块是由对应的hash信息来校验保证的，为了保证镜像raw data是我们“想要的”，我们还需要对 hash 信息进行合法性验证，简单理解就是要确认这个hash信息是我们“想要的”， 方法就是对这个hash信息再次计算一次hash值，这里称为 root hash，然后添加一些类似于签名保护并保存起来（通常在实际工作中，在镜像编译阶段将root hash计算出来，保存在镜像的某个地方，通过cms等签名方式保存，启动阶段会进行cms验签以保证root_hash的正确性），主要是为了防止 root hash 被非法篡改。在一次 raw data 数据块的校验过程中，需要对 hash 信息计算一次 hash，然后跟保存的 root hash 进行比较，验证了 hash 信息的合法性之后，再来校验对应的 raw data 数据块。 有了以上背景，再回到刚刚这个“为何还需要在 Level 0 的基础上继续算hash组装下一个 Level 层级”的问题，按照上面的安全策略，如果 hash 信息只有 Level 0 一层的话，接下来对 raw data 数据块的校验将会是这样：每操作一个raw data数据块，都需要计算一次 Level 0 的 hash 值，跟 root hash 进行比较，验证合法之后再对 raw data 数据块进行校验。本文中举例是 1G 的镜像，Level 0用来保存 hash 信息的数据块已经达到 2048 块，如果对面对更大的镜像，Level 0 所占的数据块也会更大，如果是按照上面的计算方法，对 raw data 数据块的校验效率将会非常非常低。 作为对比，哈希树机制是如何体现出效率呢，下面以具体某一块 raw data 数据块的读取过程来说明其设计原理： 1）假设目前正需要读取第 200000 块的数据块，通过前面哈希树的构造，可以比较快速的计算出在 Level 0 层，也就是直接对应这个数据块的hash值存储位置，通过对 128 相除以及求余的方式就可以分别计算出该 hash 值存储在具体某一块(块A)以及这一块上的偏移(偏移A)。 2）确定了 Level 0 层的具体块A后，利用相同的方式可以得到 Level 0 块A在 Level 1 层存储其 hash 值的块B位置以及块B上的偏移(偏移B) 3）同上述原理，可以最终定位到 Level 1 层块 B 在 Level 2 上的数据块(只有一块)上偏移(偏移C) 4）在获取到该数据块对应hashtree关联的各个层级的块以及偏移后，接下来就是做一层一层的验证： 步骤1. 优先验证的是Level 2 中的数据块(只有一个4k的数据块)， 计算这个数据块的hash，跟保存的 root hash进行比对，验证Level 2的数据块块是否正确。 步骤2. 在Level 2中的数据块得到验证后，由上面计算到的Level 2中数据块上的偏移 C 去校验 Level 1 层的 B 块。 步骤3. 在 Level 1 层的 B 数据块得到验证后，由上面计算到的 Level 1 中 B 数据块上的偏移B去验证 Level 0 层的 A块。 步骤4. Level 0层中的 A 数据块得到验证后，最终会由 Level 0 层的偏移A来校验最终的 raw data数据块(第 200000 块). 可以看到，在使用哈希树的设计之后，对数据块验证整个过程中，涉及到的数据块hash计算只有3块(有N层就计算N块)，相比于一层校验模式，效率要高很多。 三、应用层面 读者到目前为止应该大致了解到了移动终端在镜像完整性校验上相关的设计原理，接下来会从应用端层面来说明如何使用 dm-verity 底层提供的接口来初始化 dm 设备，并为后续实时校验做好准备，内核绝大多数功能模块存在的意义都要靠跟应用端的交互来体现，作为对内核某个模块的研究，初步从应用层出发不乏是一个好办法。 通常系统启动阶段，使用veritysetup工具指定data device和hash device，以及指定的root hash值，hash device的具体位置，hash device通常位于data device的后面一部分。通过veritysetup工具执行后，会生成dm设备，如我们原来使用的文件系统为&#x2F;dev&#x2F;sda3，则此时可以生成一个dm设备为sda3-dm，后续通过mount挂载sda3-dm到&#x2F;sysroot即可实现挂载根文件系统，后续读取根文件系统数据，均会通过sda3-dm设备中转，通过IO定向映射访问&#x2F;dev&#x2F;sda3，并进行hash校验 如下为veritysetup应用层的3个常规步骤： 步骤一. Create dm device 创建 dm 设备主要有如下小步骤： open &#x2F;dev&#x2F;device-mapper 设备节点 传入逻辑分区name、随机生成的uuid参数，调用 DM_DEV_CREATE ioctl 命令 步骤二. Load verity table 这里需要引入一个 verity table 的概念，先简单介绍以下 verity table 所包含的内容： 1）Verity target version(verity target 版本号) 2）Data block device(存储实际待校验数据的块设备) 3）Hash block device(存储校验使用到hash的块设备，一般情况跟data block device是同一个) 4）Data block size(数据块设备的每块存储size) 5）Hash block size（hash块设备的每块存储size） 6）Num data block(数据块设备占用的块数量) 7）Hash start block(hash设备在存储设备的起始位置) 8）Hash algo(hash算法) 9）root digest(对应上面说的 root hash) 10）Salt(用于计算hash的盐值) 这些信息主要是跟最终数据块在校验计算过程中会被使用到的，比如说 hash 设备的起始位置、hash算法、root hash、salt，这些都在实际运行时校验数据块时会用到，这些信息是存储是镜像的固定位置上，这些信息在编译阶段构建镜像的时候就已经计算好的，并存储在镜像的固定位置。 Verity table 初始化代码具体如下： 上层通过从镜像固定位置获取到信息并初始化好 verity table， 通过调用DM_TABLE_LOAD Ioctl 命令将 verity table 传递至kernel。 步骤三. Active dm device 调用DM_DEV_SUSPEND ioctl 指令激活 dm device，对应底层，该 cmd 对应 suspend &amp; resume的实现，如果不设置 DM_SUSPEND_FLAG 标志位，默认走 resume 流程。 应用端在实现上比较简单，主要通过 create -&gt; load verity table -&gt; active dm device 的流程完成了对dm设备的创建、verity table的读取以及传递以及dm设备的激活，为后续实时进行的数据块校验做好了初始化工作。 四、内核层面 有了以上应用层面的流程讲解，那对应内核，自然而然就是对每一步应用端的系统调用做对应的内核实现做讲解。 相应的，内核层面也有以下3个步骤： 步骤一. dev_create 对应应用端的DM_DEV_CREATE ioctl cmd，kernel端的大致实现如下： 这部分比较简单： 1). 检测传入参数的partition name是否合法 2). 开始尝试分配内存初始化 mapped device 结构体以及分配设备minor号（最终用于 dm 设备的设备号，比如 dm-1），使用内核提供的blk_queue_make_request函数注册该mapped device对应的请求队列dm_make_request, 该请求队列最终会在IO重定向中被使用到。并将该mapped device作为磁盘块设备注册到内核中。 3). 将创建好的mapped device插入到一个全局hash表中，该表中保存了内核中当前创建的所有mapped device。 步骤二. dm_ctl_ioctl(DM_TABLE_LOAD_CMD(table_load)) 对应应用端的DM_TABLE_LOAD ioctl cmd，kernel端的大致实现可看下面的思维导图： 总的来说，这个步骤主要是根据入参初始化相应的dm_table、dm_target结构，并且根据参数所指定的target类型，调用相应的target类型的构建函数ctr在内存中构建target device， 在结构上形成 dm_table –&gt; dm_target –&gt; target type –&gt; target device 的链路结构。 步骤三. dm_ctl_ioctl(DM_DEV_SUSPEND_CMD(dev_suspend)) 很显然，这一个步骤主要是建立 mapped device 与 dm_table 的关联。 通过以上几个步骤，在内核中就建立一个可以提供给用户使用的mapped device逻辑块设备 综上涉及到了几个关键的数据结构： mapped device、dm_table、dm_target、target_type、target device(以dm-verity为例) 其实这几个步骤主要是对上述数据结构进行初始化，并且更重要是互相建立了关联关系。他们之间的关联关系如下： 内核经过了这3个步骤，一方面是创建了一个可以提供给应用端使用的 mapped device 逻辑块设备，另一方面是内部建立了 mapped device - target device 的联系， 应用层可以通过对 mapped device 进行策略逻辑操作，最终会通过 mapped device - target device 的联系作用到 对应的target device 上。 五、核心数据流 在上面介绍了dm-verity的设计原理、应用层面以及内核层面的实现之后，读者可能比较关心整个链路的数据流，或者说镜像在校验链路具体流程是如何的，接下来以下主要是围绕着访问镜像文件时的IO流是如何的。 上面说到，应用层在经过 create -&gt; load verity table -&gt; active dm device 的流程完成了dm块设备的初始化工作，之后应用层会对该逻辑块设备进行文件系统挂载，在挂载的过程中，需要访问到实际存储设备(读取文件系统的super block等)，这个过程中就需要透过这个逻辑块设备，最终操作到与其关联的target device。 在这个过程中， 对块设备的IO请求会从逻辑设备mapped device转发相应的target device上，并且会根据对应target_type描述的IO处理规则对IO请求进行处理。以本文讨论的 dm-verity 类型的 target device 来说，对于 mapped device 转发过来的IO，会在 hashtree 里找到该 IO data 对应的 hash 数据，并进行比较，完成校验，返回此次的校验结果并结束本次IO请求。 同时dm-verity通常有两种模式，一般可以通过上述说的veritysetup工具或自研工具指定，两种模式为EIO模式和Loggin模式，EIO模式在校验到数据块的hash不对时直接返回错误，而Loggin模式在校验错误还可以正常使用，Loggin一般为debug使用","tags":["dm-verity"],"categories":["dm-verity"]},{"title":"98、验证二叉搜索树","path":"/posts/98、验证二叉搜索树.html","content":"一、题目描述给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。 有效 二叉搜索树定义如下： 节点的左子树只包含 小于 当前节点的数。节点的右子树只包含 大于 当前节点的数。所有左子树和右子树自身必须也是二叉搜索树。 示例 1： 输入：root &#x3D; [2,1,3]输出：true 示例 2： 输入：root &#x3D; [5,1,4,null,null,3,6]输出：false解释：根节点的值是 5 ，但是右子节点的值是 4 。 提示： 树中节点数目范围在[1, 10^4] 内-2^31 &lt;&#x3D; Node.val &lt;&#x3D; 2^31 - 1 二、C语言代码根据二叉搜索树的性质，二叉搜索树的中序遍历后，结果为有序且从小到大，所以我们遍历二叉树，将结果保存到数组中，然后判断数组是否有序即可。 12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * struct TreeNode *left; * struct TreeNode *right; * &#125;; */bool isValidBST(struct TreeNode* root) &#123; int returnSize = 0; int *res = (int *)malloc(10000 * sizeof(int)); if (res == NULL) &#123; return false; &#125; traverse(root, res, &amp;returnSize); for (int i = 0; i &lt; returnSize - 1; i++) &#123; if (res[i] &gt;= res[i + 1]) &#123; return false; &#125; &#125; return true;&#125;void traverse(struct TreeNode* root, int *res, int *returnSize) &#123; if (root == NULL) &#123; return; &#125; traverse(root-&gt;left, res, returnSize); res[*returnSize] = root-&gt;val; (*returnSize)++; traverse(root-&gt;right, res, returnSize);&#125;","tags":["二叉树"],"categories":["二叉树"]},{"title":"96、不同的二叉搜索树","path":"/posts/96、不同的二叉搜索树.html","content":"一、题目描述给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。 示例 1：输入：n &#x3D; 3输出：5示例 2： 输入：n &#x3D; 1输出：1 提示：1 &lt;&#x3D; n &lt;&#x3D; 19 二、C++代码解法一： 这种题目，我一般是计算出前面多个例子，根据计算出来的多个例子，进行归纳总结，利用数学归纳法，找规律，推算出第n个的结果，然后利用类似如下方法，根据第0个，第1个，第2个……，以此计算出第n个。 n&#x3D;1,搜索二叉树种数：1 ,只有一个节点，所以为1 n&#x3D;2,搜索二叉树种数：2 ,只有二个节点，要么1为根节点，要么2为根节点，所以结果为2 n&#x3D;3,搜索二叉树种数：5 ,有三个节点(1)、1为根节点，另外两个节点，均大于1，根据二叉搜索树的性质，大于根节点的数字，即另外两个节点2和3只能作为右子树，再作为一个整体，构成二叉搜索树，此时另外两个节点构成结果等同于n&#x3D;2时的结果，为2(2)、2为根节点，根据二叉搜索树性质，1只能作为左子树，3只能作为右子树，只有一种情况，所以结果为1(3)、3为根节点，根据二叉搜索树性质，1和2只能作为左子树,1和2作为一个整体再构成二叉搜索树，此时与(1)一样，结果等于n&#x3D;2时的结果为2所以n&#x3D;3时，搜索二叉树种数为2+1+2&#x3D;5 n&#x3D;4,搜索二叉树种数：14(1)、1为根节点，另外三个节点，均大于1，另外节点只能作为右子树，其他节点再作为一个整体，构成二叉搜索树，此时另外三个节点构成结果等同于n&#x3D;3时的结果，为5(2)、2为根节点，根据二叉搜索树性质，1只能作为左子树，3,4只能作为右子树，此时进行排列组合，即为n&#x3D;1和n&#x3D;2的结果相乘，为2(3)、3为根节点，结果等于(2)时的结果为2(3)、4为根节点，结果等于(1)时的结果为5 n&#x3D;5,搜索二叉树种数：42……所以我总结规律为当输入数字为100,结果应该为n=0 * n=99 + n=1 * n=98 + …… + n=99 * n=0, n&#x3D;0时为1 1234567891011121314151617181920212223242526class Solution &#123;public: int numTrees(int n) &#123; int i = 0; int res = 0; if (n == 0) &#123; return 1; &#125; if (n == 1) &#123; return 1; &#125; if (n == 2) &#123; return 2; &#125; if (n == 3) &#123; return 5; &#125; for (i = 0; i &lt; n; ++i) &#123; res += (numTrees(i) * numTrees(n- 1 - i)); &#125; return res; &#125;&#125;; 解法二：解法一比较耗时，所以在解法一基础上进行优化，可以把中间的结果都保存到数组nums中，后续就不需要每次都遍历才拿到结果了。 1234567891011121314151617181920212223class Solution &#123;public: int numTrees(int n) &#123; vector&lt;int&gt; nums(20, 0); nums[0] = 1; traverse(n, nums); return nums[n]; &#125; int traverse(int n, vector&lt;int&gt; &amp;nums) &#123; int res = 0; int i = 0; if (nums[n] != 0) &#123; return nums[n]; &#125; for (i = 0; i &lt; n; ++i) &#123; nums[n] += (traverse(i, nums) * traverse(n- 1 - i, nums)); &#125; return nums[n]; &#125;&#125;; 解法3：动态规划，后续再写具体思路吧： 123456789101112class Solution &#123;public: int numTrees(int n) &#123; // 二叉搜索数的特征，左子树小于根，右子树大于根 vector&lt;int&gt; dp(n+1, 0); dp[0]=1; // dp[0]初始化为1 for(int i=1; i&lt;=n; i++) // 从1...n的二叉搜索数数目 for(int j=1; j&lt;=i; j++) // 逐步选用1...n作为根节点 dp[i]+=dp[j-1]*dp[i-j]; // 左侧j-1个数，右侧i-j个数 return dp[n]; &#125;&#125;;","tags":["二叉树"],"categories":["二叉树"]},{"title":"94、二叉树的中序遍历","path":"/posts/94、二叉树的中序遍历.html","content":"一、题目描述给定一个二叉树的根节点root，返回它的中序遍历 。 示例 1： 输入：root &#x3D; [1,null,2,3]输出：[1,3,2]示例 2： 输入：root &#x3D; []输出：[]示例 3： 输入：root &#x3D; [1]输出：[1] 提示： 树中节点数目在范围 [0, 100] 内-100 &lt;&#x3D; Node.val &lt;&#x3D; 100 进阶: 递归算法很简单，你可以通过迭代算法完成吗？ 二、C语言题解递归算法很简单，只需要按照左右根的顺序递归即可，代码如下：不过需要注意的是，leetcode中尽量最好不要使用全局变量吧，因为leetcode网站的题目，所有的用例是共享全局变量的，也就是第一个用例执行完后，第二个用例会继承第一个用例执行后的全局变量的值，导致后续的用例执行失败 123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * struct TreeNode *left; * struct TreeNode *right; * &#125;; *//** * Note: The returned array must be malloced, assume caller calls free(). */int* inorderTraversal(struct TreeNode* root, int* returnSize) &#123; int* res = (int *)malloc(100 * sizeof(int)); if (res == NULL) &#123; return NULL; &#125; *returnSize = 0; traverse(root, res, returnSize); return res;&#125;void traverse(struct TreeNode* root, int* res, int* returnSize)&#123; if (root == NULL) &#123; return; &#125; traverse(root-&gt;left, res, returnSize); res[*returnSize] = root-&gt;val; (*returnSize)++; traverse(root-&gt;right, res, returnSize);&#125; 迭代方法： 三、C++题解递归方法： 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; traverse(root, res); return res; &#125; void traverse(TreeNode* root, vector&lt;int&gt; &amp;res) &#123; if (root == nullptr) &#123; return; &#125; traverse(root-&gt;left, res); res.push_back(root-&gt;val); traverse(root-&gt;right, res); &#125;&#125;;","tags":["二叉树"],"categories":["二叉树"]},{"title":"二叉树算法核心纲领","path":"/posts/二叉树算法核心纲领.html","content":"一、二叉树基本概念二叉树二叉搜索树完全二叉树 二、二叉树的前中后序遍历二叉树的前中后序对应的不只是三种顺序不同的列表。前中后序是遍历二叉树过程中处理每一个节点的三个特殊时间点，绝不仅仅是三个顺序不同的 List：前序位置的代码在刚刚进入一个二叉树节点的时候执行；后序位置的代码在将要离开一个二叉树节点的时候执行；中序位置的代码在一个二叉树节点左子树都遍历完，即将开始遍历右子树的时候执行。 三、二叉树解题的思维方式1、是否可以通过遍历一遍二叉树得到答案？如果可以，用一个 traverse 函数配合外部变量来实现，这叫「遍历」的思维模式。 2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「分解问题」的思维模式。 无论使用哪种思维模式，你都需要思考： 如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前&#x2F;中&#x2F;后序位置）做？其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作。 四、后序位置的特殊之处五、二叉树的层序遍历六、N叉树","tags":["二叉树"],"categories":["二叉树"]},{"title":"dd命令","path":"/posts/dd命令.html","content":"dd命令可以从一个文件或设备向另一个文件或设备进行复制 一、dd命令常用语法1dd if=input_file of=output_file [options] options是一些可选参数，if和of是必须有的 if 表示输入文件 of 表示输出文件 bs：设置每次读取和写入的块大小（单位为字节或者是可以添加的后缀，如b、k、m等），默认为512字节。 count：设置要复制的块数。 iflag：设置输入选项，常用的选项有direct（绕过缓存直接读取）和sync（同步数据到磁盘）。 oflag：设置输出选项，常用的选项有direct（绕过缓存直接写入）和sync（同步数据到磁盘）。 skip&#x3D;xxx 是在备份时对if 后面的部分也就是原文件跳过多少块再开始备份； seek&#x3D;xxx则是在备份时对of 后面的部分也就是目标文件跳过多少块再开始写 二、dd常用命令-读磁盘1dd if=/dev/sde1 of=tee-test.img bs=1M skip=4 count=16 含义为从&#x2F;dev&#x2F;sde1设备起始位置，跳过4M，读取16M内容到tee-test.img中想要查看tee-test.img，可以使用hexdump命令 1hexdump -C tee-test.img 只查看部分内容，例如前100个字节： 1hexdump -C -n 100 tee-test.img 三、dd常用命令-写磁盘1dd if=/dev/zero of=/dev/sda bs=1k seek=8224 count=32 含义为从&#x2F;dev&#x2F;zero中也就是将后面的of目标文件写0，将&#x2F;dev&#x2F;sda设备的起始地址，跳过8224KB后，连续写入32KB 0数据 四、通过fdisk -l确认分区的实际起始地址使用fdisk -l显示磁盘分区情况 12345678# fdisk -lDisk /dev/sde: 19.16 GB, 20577255424 bytes, 5023744 sectorsSector size (logical/physical): 4096 bytes / 4096 bytes Device Start End/dev/sde1 256 131327 这里显示sde1的起始地址为256，那么实际地址为：256 ✖️ 4096 &#x3D; 1048576 &#x3D; 1024 ✖️ 1024 &#x3D; 1MB，所以sde1的位置为&#x2F;dev&#x2F;sde的起始地址偏移1M，其实起始1M，存放的应该是磁盘分区信息","tags":["Linux工具"],"categories":["Linux工具"]},{"title":"Makefile基础语法","path":"/posts/Makefile基础语法.html","content":"一、Makefile规则一个简单的 Makefile 文件包含一系列的“规则”，其样式如下： 12目标(target)…: 依赖(prerequiries)…&lt;tab&gt;命令(command) 目标(target)通常是要生成的文件的名称，可以是可执行文件或OBJ文件， 也可以是一个执行的动作名称，诸如‘ clean ’。依赖是用来产生目标的材料(比如源文件)，一个目标经常有几个依赖。命令是生成目标时执行的动作，一个规则可以含有几个命令，每个命令占一行。注意：每个命令行前面必须是一个 Tab 字符，即命令行第一个字符是 Tab。这是容易出错的地方。通常，如果一个依赖发生了变化，就需要规则调用命令以更新或创建目标。 但是并非所有的目标都有依赖，例如，目标“ clean ”的作用是清除文件，它有依赖。 一个 Makefile 文件可以包含规则以外的其他文本，但一个简单的 Makefile 文件仅仅需要包含规则。虽然真正的规则比这里展示的例子复杂，但格式是完全一样的 二、make命令介绍make 命令的使用： 执行 make 命令时，它会去当前目录下查找名为“Makefile”的文件，并根 据它的指示去执行操作，生成第一个目标。我们可以使用“ -f ”选项指定文件，不再使用名为“Makefile”的文件，比 如： 1make -f Makefile.build 我们可以使用“ -C ”选项指定目录，切换到其他目录里去，比如： 1make -C a/ -f Makefile.build 我们可以指定目标，不再默认生成第一个目标： 1make -C a/ -f Makefile.build other_target 三、Makefile变量介绍1234A = xxx // 延时变量B ?= xxx // 延时变量，只有第一次定义时赋值才成功；如果曾定义过，此赋值无效C := xxx // 立即变量D += yyy // 如果 D 在前面是延时变量，那么现在它还是延时变量；// 如果 D 在前面是立即变量，那么现在它还是立即变量 四、Makefile通配符&amp;一些符号%通配符 %.o：表示所用的.o文件%. %.c：表示所有的.c文件 $@：表示目标$&lt;：表示第一个依赖文件$^：表示所有依赖文件 五、Makefile假想目标我们的 Makefile 中有这样的目标： 123clean: rm -f $(shell find -name &quot;\\*.o&quot;) rm -f $(TARGET) 如果当前目录下恰好有名为“clean”的文件，那么执行“ make clean ”时它 就不会执行那些删除命令。这时我们需要把“ clean ”这个目标，设置为“假想目标”，这样可以确保执行“ make clean ”时那些删除命令肯定可以得到执行。 使用下面的语句把“clean”设置为假想目标： 1.PHONY : clean 六、Makefile常用函数1.$(foreach var,list,text)简单地说，就是 for each var in list, change it to text。对 list 中的每一个 元素，取出来赋给 var，然后把 var 改为 text 所描述的形式。 2.$(wildcard pattern)pattern 所列出的文件是否存在，把存在的文件都列出来。 3.$(filter pattern…,text)把 text 中符合 pattern 格式的内容，filter(过滤)出来、留下来。 4.$(filter-out pattern…,text)把 text 中符合 pattern 格式的内容，filter-out(过滤)出来、扔掉。 5.$(patsubst pattern,replacement,text)寻找’ text ‘中符合格式’ pattern ‘的字，用’ replacement ‘替换它们。 ‘ pattern ‘和’ replacement ‘中可以使用通配符。 七、Makefile的例子，包含子目录八、Makefile中的EXTRA_CFLAGSEXTRA_CFLAGS是Makefile中预定义的一个变量，作为CFLGAS，在make时可以传递给gcc一些编译选项等，如—O2 EXTRA_CFLAGS +&#x3D; -D等价于gcc -D，相当于在源代码中定义一个宏假如定义一个宏CONFIG_DEBUG在.c里面定义为：#define CONFIG_DEBUG在makefile里定义为: CONFIG_DEBUG&#x3D;y 假如说我们想在makefile里为.c文件进入一个宏定义，就用EXTRA_CFLAGS +&#x3D; DCONFIG_DEBUG( 等价于在.c文件里定义#define CONFIG_DEBUG) 这时CONFIG_DEBUG&#x3D;y与EXTRA_CFLAGS +&#x3D; DCONFIG_DEBUG的区别应该你已经看出来的，前者是对makefile编译时用的，比如说obj-(CONFIG_DEBUG) +&#x3D; test.o,而后者则是对.c源文件里的用的 九、Makefile编译内核驱动ko内核源代码中obj-m表示以模块ko的方式编译obj-y表示将源代码编译到内核源码中在工作的过程中，经常需要编译一些Ko模块，如果是单个的c文件编译直接在内核源码里面 obj-y&#x3D;xxx.o就好如果这个ko文件需要多个c文件共同编译生成的话，最好以如下的模板来完成编译较好 1234567891011121314151617181920212223242526272829303132#首先指定好编译链工具CROSS_COMPILE=/opt/gcc-linaro-7.3.1-2018.05-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-#指定用哪个内核去编译KDIR=/mnt/nfsroot/zhengshuai.zhu/IPCSDK/ipc-sdk-full-release/kernel-4.19#目标是编译成一个test.ko文件obj-m += test.o#test.o文件由当前目录下n个c文件编译成test-objs += ./*.o#包含当前目录下的头文件INCLUDE_DIRS := $(addprefix -I,$(shell find ../ -type d ))#包含当前目录下，内核目录下的头文件ccflags-y:= -I$(_KDIR)/include/linux/ -I$(PWD)/platform/#忽略一些编译警告，类如什么变量未使用ccflags-y += -Wno-declaration-after-statement#添加c文件中的环境变量，比如在代码中会有#ifdef CONFIG_ANDROID #xxxx#endififeq ($(SYSTEM_VERSION),) ccflags-y += -DCONFIG_LINUX_OSelse ccflags-y += -DCONFIG_ANDROIDendifall: make ARCH=$&#123;ARCH&#125; -C $(KDIR) M=$(PWD) modulesclean: make ARCH=$&#123;ARCH&#125; -C $(KDIR) M=$(PWD) clean make ARCH=$&#123;ARCH&#125; -C ( K D I R ) M = (KDIR) M=(KDIR)M=(PWD) modules如何理解这句话?-C的选项可以理解为:进入所指定的位置，$(KDIR)，也就是内核目录中，目的是什么？ 去读取内核目录顶层的Makefile文件，相当于编译的时候 选择一个内核，我要用这个内核去编译。因为你这个目录没有被配置到kernel config里面去，也就是说没有指定用哪个内核版本，有了 -C $(KDIR),就相当于选了内核，如果你选择了kernel-4.19目录下，或者 kernel-5.0目录下， M&#x3D;的选项可以理解为:当我选好内核版本后，我用这个 版本的内核 要去编译哪个目录，然后进入$(PWD)目录去编译当前指定的文件，将其编译成ko文件","tags":["Makefile"],"categories":["Makefile"]},{"title":"git提交流程","path":"//posts/1.html","content":"一、Git下载及配置我们第一次用git或者是新电脑上重新安装git工具的时候，都需要重新配置一下这个工具。 Windows安装git官网网址https://git-scm.com/downloads下载速度慢，且有可能安装不成功。 附快速下载地址（国内下载站）：https://github.com/waylau/git-for-win 。 下载完之后，Windows中你在桌面上或者文件管理器中鼠标右键就可以看见Git Bash here，就是用来打开git bash的。 Linux安装gitlinux在终端中，输入sudo apt-get install git 下载完可以用命令git --version打印当前的git版本验证是否成功。下面正式开始Git的配置。 配置git基本信息接下来就是不管我们是第一次使用git工具，还是后来换电脑了，还是换成linux系统了，要想使用git都按照下面的方法配置一遍，才可以使用。 安装成功之后，在命令行中敲下如下命令 git config --list,显示当前的配置信息。 接下来设置提交仓库时的用户名信息 git config --global user.name &quot;张三&quot; 设置提交仓库是的邮箱信息 git config --global user.email &quot;xxxxxxxx@qq.com&quot; git设置关闭自动换行git config --global core.autocrlf false 为了保证文件的换行符是以安全的方法，避免windows与unix的换行符混用的情况，最好也加上这么一句 git config --global core.safecrlf true 其实这些信息都在一个配置文件中，就在当前用户的主目录下边的**.gitconfig**文件中，也可以直接打开这个文件cd ~,vim .gitconfig进行编辑。 git协议及秘钥配置git有四种协议：Git协议，http协议，本地协议，ssh协议。使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https。大部分都是用ssh协议。这个不仅速度快，而且不用每次提交输入密码，可谓是省心省力。 下面就说一下ssh配置过程。(这个协议配置的过程不可缺少，不然就用不了这种协议。) 首先生成 RSA 密钥对 : ssh-keygen -t rsa -C &quot;xxxxxxxx@qq.com&quot;注意格式，一定要正确。 ssh和-keygen无空格 此时在用户主目录下就会有一个.ssh隐藏文件，进入该目录有一个id_rsa.pub文件，cat命令查看这个文件，复制下来然后在 github网站添加公钥 ，方法如下 在 Github 网站添加公钥：在右上角头像处点settings进入设置，然后点SSH and GPG keys,进入之后点击New SSH key 粘贴进去，随便给这个秘钥命个名，方便管理就行了。钥匙显示黑色即可。 此时配置就完成了。接下来就可以使用git了。 执行此命令验证是否成功ssh -T git@github.com 成功显示为：Hi XXX! You’ve successfully authenticated, but GitHub does not provide shell access. 二、先有本地库，后有远程库创建版本库可以理解为版本库就是本地文件的一个目录，也叫仓库。可以用git来管理和回退等 创建版本库：找到一个想被管理的文件夹，进入到文件夹里，输入命令git init,此时git就可以管理这个目录了，并且在文件夹下多出来了一个.git的隐藏文件夹。这个.git就是版本库。 Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。 工作区：就是你在电脑里能看到的目录，比如刚才的文件夹就是一个工作区 第一步：将文件添加到暂存区当我们想添加文件或者修改文件是需要添加到版本库中的，否则无法被git跟踪管理呀，所以当我们添加或者修改文件时，先要用git add filename添加到暂存区中，filename为.的时候代表当前目录下所有文件都添加到暂存区 第二步：将文件提交到分支git commit -m &quot;message&quot;，将文件提交到了分支。 添加远程库我们已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。 首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库，在Repository name填入项目名字，比如我们叫learngit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库 目前，在GitHub上的这个learngit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。 现在，我们根据GitHub的提示，在本地的learngit仓库下运行命令： git remote add origin git@github.com:mengchao666/learngit.git 请千万注意，把上面的mengchao666替换成你自己的GitHub账户名，否则，你在本地关联的就是我的远程库，你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。 添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。下一步，就可以把本地库的所有内容推送到远程库上： git push -u origin master把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样,从现在起，只要本地作了提交，就可以通过命令： git push origin master 三、先有远程库，后有本地库现在，远程库已经准备好了，下一步是用命令git clone克隆一个本地库： git clone git@github.com:mengchao666/learngit.git 可以使用git clone -b branch克隆指定的分支后续修改可以使用如下命令提交 123git add .git commit -m &quot;message&quot;git push 四、企业开发流程在公司中做项目，一般项目代码都在公共仓库中，我们将其称为远程仓，一般按照如下步骤开发1、将远程仓fork一份到个人仓2、git clone个人仓代码到本地3、使用git remote -v命令查看，此时本地关联的origin为个人仓4、将本地代码关联到公司的远程仓，方便拉取最新代码，命令如下： 1git remote add upstream 公共仓地址 此时再次使用git remote -v可以看到已经关联了upstream为远程仓5、在开发需求和问题单修改之前，一般使用git pull upstream命令将远程仓代码更新至本地6、修改代码后提交 123git add .git commit -m &quot;message&quot;git push origin branch 7、在github&#x2F;gitlab页面创建MR申请，一般此时就可以了，找人加分就合入了8、但是如果在创建MR申请时，提示冲突，此时需要解决冲突，解决如下： 1git pull upstream 此时会提示哪些文件有冲突，使用ctrl + F搜索&gt;&gt;&gt;,有此标志的即为冲突的地方，保留自己想要的代码，重新提交add commit push即可。 企业开发流程中，通常有远程仓新建了一个分支，个人远程仓没有此分支，需要更新，可按照如下步骤更新个人仓代码分支 123git checkout -b 新分支名称 upstream/新分支名称git pull upstream 新分支名称git push origin 新分支名称 五、代码回退等操作工作区的恢复(此时还没有add，代码回退)使用checkout恢复工作区 git checkout . （全部修改），git checkout --file改回一个文件,工作区—&gt;还没add add的撤销git reset就是回退到指定的commitID,,使用git commit –amend时追加，不会生成新的commitID,是在原来的commitID基础上进行修改的。 HEAD指向当前最新的commitID，所以仅仅add,没有commit，此时的最新的commitID还是之前的 12git reset --hard HEAD // 不保留本地修改，回退git reset --mixed HEAD //保留本地修改，可以重新git add 简单理解git reset –xxx HEAD命令，就是将代码回退到了最新的一次commitID的代码状态，hard不保留本地代码工作空间的修改，而mixed保留 commit后的撤销123git reset --hard HEAD^ // 不保留本地修改，回退到上一次的commitID状态git reset --mixed HEAD^ // 保留本地修改，撤销git commit,并且撤销git addgit reset --soft HEAD^ //保留本地修改，撤销commit,不撤销add 六、git的一些其他操作查看分支：git branch 创建分支：git branch &lt;name&gt; 切换分支：git checkout &lt;name&gt;或者git switch &lt;name&gt; 创建+切换分支：git checkout -b &lt;name&gt;或者git switch -c &lt;name&gt; 合并某分支到当前分支：git merge &lt;name&gt; 删除分支：git branch -d &lt;name&gt; 当代码仓有子仓情形下的一些命令：git submodule update --init --remotegit submodule foreach git checkout branchgit submodule foreach --recursive 七、同时提交两个MR当我们同时修改多个问题单，或者同时处理需求时，可能需要同时提交多分不同代码，此时处理方法如下： 1、本地创建一个新的分支来处理第一个MR 1git checkout -b mr1-branch 2、提交第一个MR。修改代码，git add、git commit，git push 1git push -u origin mr1-branch 3、切换回原来的分支，以main分支为例 1git checkout main 4、创建第二个分支处理第二个MR 1git checkout -b mr2-branch 5、提交第二个MR。修改代码，git add、git commit，git push 1git push -u origin mr2-branch","tags":["git"],"categories":["git"]},{"title":"addr2line","path":"/posts/addr2line.html","content":"addr2line是一个将地址转换为文件名和行号的工具。给定可执行文件(如exe&#x2F;a.out等)中的地址或可重定位对象(如so,ko等)部分中的偏移量，它会使用调试信息来确定与之相关的文件名和行数。 用户态coredump，一般使用gdb调试接口，gdb一般封装了addr2line，可以解析文件名和行号。如果环境配置了不生成coredump，可以使用addr2line调试。所以addr2line一般解析内核Call trace使用较多。 一、使用方法12基本用法：addr2line [选项] [地址] 常用选项如下： 选项 描述 -e 设置输入文件名称，默认为a.out -i 解析内联函数 -f 显示函数名 -C 解析函数名 -p 以好读的方式显示 需要注意的是使用addr2line的时候，可执行文件或重定位文件一定是要带调试信息的 二、用户态普通程序崩溃使用方法 1addr2line -e 进程名 IP指令地址 -f 用户态程序崩溃，当没有coredump产生时，可以使用如下方法假设我们的程序名称为segfault,当程序崩溃是，dmesg日志中会有报错信息: 123[root@localhost ~]# dmesg[134563.793925] segfault[53791]: segfault at 0 ip 0000000000400546 sp 00007fff7956af70 error 6 in segfault[400000+1000][134563.793946] Code: 01 5d c3 90 c3 66 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 f3 0f 1e fa eb 8a 55 48 89 e5 48 c7 45 f8 00 00 00 00 48 8b 45 f8 &lt;c7&gt; 00 00 00 00 00 b8 00 00 00 00 5d c3 66 2e 0f 1f 84 00 00 00 00 此时我们注意到IP指令地址为0000000000400546使用addr2line查看程序挂的位置： 1addr2line -e segfault 0x0000000000400546 -f 三、动态链接库程序崩溃使用方法 1addr2line -e 动态链接库名称 IP指令地址-基地址 -f 假设我们有一个程序名为test，链接了一个libfoo.so，程序运行时崩溃，dmesg查看日志如下： 123[root@localhost ~]# dmesg[70567.416655] test[27722]: segfault at 0 ip 00007ffa1f588580 sp 00007fffa964e698 error 6 in libfoo.so[7ffa1f588000+1000][70567.427374] Code: ff e8 64 ff ff ff c6 05 bd 0a 20 00 01 5d c3 0f 1f 00 c3 0f 1f 80 00 00 00 00 f3 0f 1e fa e9 77 ff ff ff 0f 1f 80 00 00 00 00 &lt;c7&gt; 04 25 00 00 00 00 00 00 00 00 0f 0b 00 00 00 f3 0f 1e fa 48 83 根据日志可知，段错误发生的位置是在test进程调用的libfoo.so库里，我们先使用ldd找到动态库的位置，如下： 12345[root@localhost 69]# ldd test linux-vdso.so.1 (0x00007ffd15b24000) libfoo.so =&gt; ./libfoo.so (0x00007f8c01879000) libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f8c014b4000) /lib64/ld-linux-x86-64.so.2 (0x00007f8c01a7b000) 00007ffa1f588580为程序崩溃点IP指令地址，使用dmesg消息中ip指令地址减去动态库基址值(00007ffa1f588580 -7ffa1f588000&#x3D;580), 差值0x580为错误点在动态库的地址，调用addr2line, 注意-e参数后文件名改为动态库名: 1addr2line -e libfoo.so 580 -f -p 四、内核驱动程序运行崩溃使用方法： 1addr2line -e xxx.ko 地址偏移量 -f 本人所用主机即属于一旦发生Oops，就会触发panic，因此总是无法查看Oops时的dmesg日志，经查阅资料，发现是内核参数panic_on_oops的原因导致的，因为该参数被设置为1，所以Oops会触发panic，从而导致机器总是死机重启，无法查看Oops时的dmesg日志。下面提供两种方法修改Oops内核参数，使其不会在Oops的时候触发panic导致死机重启。 方法一：修改 &#x2F;proc下内核参数文件内容，临时生效，重启后失效。 1echo 0 &gt; /proc/sys/kernel/panic_on_oops 方法二：修改&#x2F;etc&#x2F;sysctl.conf 文件的内核参数来永久更改。 1234567891011121314151617181920[root@localhost ~]# vi /etc/sysctl.conf[root@localhost ~]# cat /etc/sysctl.conf# sysctl settings are defined through files in# /usr/lib/sysctl.d/, /run/sysctl.d/, and /etc/sysctl.d/.## Vendors settings live in /usr/lib/sysctl.d/.# To override a whole file, create a new file with the same in# /etc/sysctl.d/ and put new settings there. To override# only specific settings, add a file with a lexically later# name in /etc/sysctl.d/ and put new settings there.## For more information, see sysctl.conf(5) and sysctl.d(5).kernel.panic_on_oops=0[root@localhost ~]# cat /proc/sys/kernel/panic_on_oops1 [root@localhost ~]# sysctl -pkernel.panic_on_oops = 0[root@localhost ~]#[root@localhost ~]# cat /proc/sys/kernel/panic_on_oops0 假设内核某ko运行后发生如下错误： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051[root@localhost ~]# dmesg[ 1039.918606] my_oops_init[ 1039.918616] BUG: unable to handle kernel NULL pointer dereference at 0000000000000000[ 1039.926442] PGD 0 P4D 0[ 1039.928979] Oops: 0002 [#1] SMP NOPTI[ 1039.932637] CPU: 34 PID: 3843 Comm: insmod Kdump: loaded Tainted: G OE --------- - - 4.18.0-394.el8.x86_64 #1[ 1039.943756] Hardware name: New H3C Technologies Co., Ltd. H3C UniServer R4950 G5/RS45M2C9SB, BIOS 5.37 09/30/2021[ 1039.954000] RIP: 0010:do_oops+0x5/0x11 [oops][ 1039.958364] Code: Unable to access opcode bytes at RIP 0xffffffffc02e6fdb.[ 1039.965231] RSP: 0018:ffffb9d40a8c7cb0 EFLAGS: 00010246[ 1039.970449] RAX: 000000000000000c RBX: 0000000000000000 RCX: 0000000000000000[ 1039.977573] RDX: 0000000000000000 RSI: ffff98942ee96758 RDI: ffff98942ee96758[ 1039.984697] RBP: ffffffffc02e7011 R08: 0000000000000000 R09: c0000000ffff7fff[ 1039.991822] R10: 0000000000000001 R11: ffffb9d40a8c7ad8 R12: ffffffffc02e9000[ 1039.998944] R13: ffffffffc02e9018 R14: ffffffffc02e91d0 R15: 0000000000000000[ 1040.006069] FS: 00007f1b8d93b740(0000) GS:ffff98942ee80000(0000) knlGS:0000000000000000[ 1040.014145] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033[ 1040.019884] CR2: ffffffffc02e6fdb CR3: 0000000145c02000 CR4: 0000000000350ee0[ 1040.027008] Call Trace:[ 1040.029454] my_oops_init+0x16/0x19 [oops][ 1040.033550] do_one_initcall+0x46/0x1d0[ 1040.037390] ? do_init_module+0x22/0x220[ 1040.041318] ? kmem_cache_alloc_trace+0x142/0x280[ 1040.046023] do_init_module+0x5a/0x220[ 1040.049777] load_module+0x14ba/0x17f0[ 1040.053530] ? __do_sys_finit_module+0xb1/0x110[ 1040.058059] __do_sys_finit_module+0xb1/0x110[ 1040.062411] do_syscall_64+0x5b/0x1a0[ 1040.066077] entry_SYSCALL_64_after_hwframe+0x65/0xca[ 1040.071130] RIP: 0033:0x7f1b8c8509bd[ 1040.074701] Code: ff c3 66 2e 0f 1f 84 00 00 00 00 00 90 f3 0f 1e fa 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 &lt;48&gt; 3d 01 f0 ff ff 73 01 c3 48 8b 0d 9b 54 38 00 f7 d8 64 89 01 48[ 1040.093446] RSP: 002b:00007ffc4df0a968 EFLAGS: 00000246 ORIG_RAX: 0000000000000139[ 1040.101004] RAX: ffffffffffffffda RBX: 00005653fb1997d0 RCX: 00007f1b8c8509bd[ 1040.108126] RDX: 0000000000000000 RSI: 00005653f980c8b6 RDI: 0000000000000003[ 1040.115251] RBP: 00005653f980c8b6 R08: 0000000000000000 R09: 00007f1b8cbd9760[ 1040.122375] R10: 0000000000000003 R11: 0000000000000246 R12: 0000000000000000[ 1040.129498] R13: 00005653fb1997b0 R14: 0000000000000000 R15: 0000000000000000[ 1040.136623] Modules linked in: oops(OE+) binfmt_misc xt_CHECKSUM ipt_MASQUERADE xt_conntrack ipt_REJECT nf_reject_ipv4 nft_compat nft_counter nft_chain_nat nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 nf_tables nfnetlink rpcsec_gss_krb5 auth_rpcgss nfsv4 dns_resolver nfs lockd grace fscache bridge stp llc intel_rapl_msr intel_rapl_common amd64_edac_mod edac_mce_amd amd_energy kvm_amd kvm irqbypass ipmi_ssif pcspkr crct10dif_pclmul crc32_pclmul ghash_clmulni_intel rapl joydev ccp sp5100_tco i2c_piix4 k10temp ptdma acpi_ipmi ipmi_si sunrpc vfat fat xfs libcrc32c sd_mod t10_pi sg crc32c_intel ast drm_vram_helper drm_kms_helper syscopyarea sysfillrect sysimgblt fb_sys_fops drm_ttm_helper ttm ahci drm libahci nfp(OE) igb libata dca i2c_algo_bit dm_mirror dm_region_hash dm_log dm_mod ipmi_devintf ipmi_msghandler[ 1040.208357] CR2: 0000000000000000[ 1040.211668] ---[ end trace b69c1e8998070273 ]---[ 1040.230185] RIP: 0010:do_oops+0x5/0x11 [oops][ 1040.234540] Code: Unable to access opcode bytes at RIP 0xffffffffc02e6fdb.[ 1040.241409] RSP: 0018:ffffb9d40a8c7cb0 EFLAGS: 00010246[ 1040.246626] RAX: 000000000000000c RBX: 0000000000000000 RCX: 0000000000000000[ 1040.253750] RDX: 0000000000000000 RSI: ffff98942ee96758 RDI: ffff98942ee96758[ 1040.260876] RBP: ffffffffc02e7011 R08: 0000000000000000 R09: c0000000ffff7fff[ 1040.267998] R10: 0000000000000001 R11: ffffb9d40a8c7ad8 R12: ffffffffc02e9000[ 1040.275124] R13: ffffffffc02e9018 R14: ffffffffc02e91d0 R15: 0000000000000000[ 1040.282247] FS: 00007f1b8d93b740(0000) GS:ffff98942ee80000(0000) knlGS:0000000000000000[ 1040.290323] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033[ 1040.296061] CR2: ffffffffc02e6fdb CR3: 0000000145c02000 CR4: 0000000000350ee0 Oops: 0002 – 错误码Oops: [#1] – Oops发生的次数CPU: 34 – 表示Oops是发生在CPU34上关键信息如下，这里提示在操作函数do_oops的时候出现异常，地址偏移量0x5： 1[ 1039.954000] RIP: 0010:do_oops+0x5/0x11 [oops] 为什么这条信息关键? 因为其含有指令指针RIP；指令指针IP&#x2F;EIP&#x2F;RIP的基本功能是指向要执行的下一条地址。在8080 8位微处理器上的寄存器名称是PC（program counter，程序计数器），从8086起，被称为IP（instruction pointer，指令指针）。主要区别在与PC指向正在执行的指令，而IP指向下一条指令。在64位模式下，指令指针是RIP寄存器。这个寄存器保存着下一条要执行的指令的64位地址偏移量。64位模式支持一种新的寻址模式，被称为RIP相对寻址。使用这个模式，有效地址的计算方式变为RIP（指向下一条指令）加上位移量。 由此可以看出内核执行到do_oops+0x5&#x2F;0x11这个地址的时候出现异常，我们只需要找到这个地址对应的代码即可。 do_oops指示了是在do_oops函数中出现的异常， 0x5表示出错的地址偏移量， 0x11表示do_oops函数的大小。 123打印格式：do_oops+0x5/0x11 [oops] 即：symbol+offset/size [module] symbol: 符号 offset：地址偏移量 size：函数的长度 module: 所属内核模块 使用如下命令解析 1addr2line -e oops.ko 0x5 -f -p","tags":["Linux工具"],"categories":["Linux工具"]},{"title":"个人博客网站部署&文章提交","path":"/posts/网站部署-写作.html","content":"一、网站部署1、首先在github上创建自己的一个仓库，仓库名字为mengchao666.github.io 2、将https://github.com/mengchao666/blog-demo代码下载到本地，用VScode打开 3、安装node.js，pnpm，hexo 123node.js官网安装：https://nodejs.cn/download/pnpm安装：npm install pnpm -ghexo安装：npm install hexo-cli -g 4、在Vscode打开的项目终端下执行如下命令： 12pnpm ipnpm dev 5、使用hexo deploy命令部署，打开mengchao666.github.io即可 6、新增文章使用如下命令新增 例如：hexo new post “网站部署” 1hexo new post &lt;title&gt; 7、新增文章后，使用命令部署提交到github 12hexo cleanhexo deploy 更多操作可以参考：https://xaoxuu.com/wiki/stellar/topic.html","tags":["网站"],"categories":["网站"]},{"title":"友链","path":"/about/index.html","content":"我的小伙伴们 github 如何交换友链？ 您的网站应满足以下全部条件： 安全合规：合法的、非营利性、无木马植入的 HTTPS 站点。 非空壳网站：网站内发布至少 五篇 原创文章，内容题材不限。 我们需要有一定的有效互动： 先友后链：与 我 有至少 半年 的有效互动"},{"title":"探索者笔记","path":"/explore/notes/探索者笔记.html","content":"memos 说说 本页面数据来源于：memos"},{"title":"工具库","path":"/explore/sites/工具库.html","content":"工具库 VIP电影在线观看https://vip1280.net/文件格式转换https://convertio.co/zh/"},{"path":"/static/js/snow.js","content":"const message = { toast: (msg, duration) => { const d = Number(isNaN(duration) ? 2000 : duration); var el = document.createElement('div'); el.classList.add('toast'); el.classList.add('show'); el.innerHTML = msg; document.body.appendChild(el); setTimeout(function () { document.body.removeChild(el) }, d); }, } const Config = { snow: ['❄️', '☃️', '❄', '※', '❅', '❆', '❈', '❉', '❊', '❋'], color: '#d9e2e7', speed: 10, dom: document.getElementsByTagName('body')[0], interval: 800, active: false }; // 从 localStorage 获取雪花模式状态 const storedSnowActive = localStorage.getItem('snowActive'); Config.active = storedSnowActive === 'true'; // 确保 DOM 元素存在 if (!Config.dom) { throw Error('请获取存在的DOM'); } const $canvas = document.createElement('div'); function useStyle(dom, style) { for (let sKey in style) { dom.style[sKey] = style[sKey]; } } useStyle($canvas, { width: '100%', height: '100%', position: 'fixed', top: 0, left: 0, pointerEvents: 'none', zIndex: 100 }); const matchDarkMode = window.matchMedia('(prefers-color-scheme: dark)'); function handleColorSchemeChange(e) { Config.color = e.matches ? 'rgb(255, 255, 255)' : 'rgb(149, 141, 186)'; } matchDarkMode.addEventListener('change', handleColorSchemeChange); handleColorSchemeChange(matchDarkMode); let snowInterval; function startSnowInterval() { return setInterval(() => { const $snow = document.createElement('div'); $snow.innerText = Config.snow[Math.floor(Math.random() * Config.snow.length)]; useStyle($snow, { display: 'inline-block', color: Config.color, fontSize: Math.floor(Math.random() * (25 - 14 + 1) + 14) + 'px', position: 'absolute', top: 0, left: Math.floor(Math.random() * 100) + '%', transition: 'transform ' + Config.speed + 's linear,opacity ' + Config.speed + 's linear', transform: 'translateY(-100%)', opacity: Math.random() + 0.3 }); setTimeout(() => { useStyle($snow, { transform: 'translate(0, ' + window.innerHeight + 'px) rotate(480deg)', opacity: 0 }); $snow.addEventListener('transitionend', () => { $snow.remove(); }); }, 100); $canvas.appendChild($snow); }, Config.interval); } function toggleSnow() { if (Config.active) { clearInterval(snowInterval); $canvas.innerHTML = ''; Config.active = false; message.toast(\"切换到晴天模式\"); } else { snowInterval = startSnowInterval() Config.active = true; message.toast(\"切换到下雪模式\"); } localStorage.setItem('snowActive', Config.active); } // 在页面加载时应用之前的状态 if (Config.active) { snowInterval = startSnowInterval() } Config.dom.appendChild($canvas);"},{"title":"牛客零基础入门前端","path":"/wiki/niuke/牛客零基础入门前端.html","content":"01 HTMLFED1 表单类型描述请依次写出以下类型的输入框。 类型为密码，默认值为 “nowcoder” 类型为复选框，且状态为已勾选 我的解答1234&lt;form&gt; &lt;input type=&quot;password&quot; value=&quot;nowcoder&quot; /&gt; &lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot; /&gt;&lt;/form&gt; 注意点： 类型为复选框，input 属性的 checked &#x3D; “checked” FED2 表格结构描述请写出具有表格标题为 “nowcoder” 的 2 行 3 列表格结构。 我的解答1234567891011121314151617&lt;table&gt; &lt;caption&gt; nowcoder &lt;/caption&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; mdn 示例 Council budget (in £) 2018 Items Expenditure Donuts 3,000 Stationery 18,000 Totals 21,000 FED3 图像标签属性描述请写出具有标题属性和代替文本属性的图片标签。 我的解答1&lt;img src=&quot;&quot; alt=&quot;&quot; title=&quot;&quot; /&gt; FED4 新窗口打开文档描述请写出可以在新窗口打开文档的 a 标签。 我的解答1&lt;a href=&quot;&quot; target=&quot;_blank&quot;&gt;&lt;/a&gt; 注意点target 规定在何处打开目标 URL。仅在 href 属性存在时使用 _blank：新窗口打开。 _parent：在父窗口中打开链接。 _self：默认，当前页面跳转。 _top：在当前窗体打开链接，并替换当前的整个窗体(框架页)。 FED5 自定义列表描述请写出列表项为 “nowcoder” 且列表项内容也为 “nowcoder” 的自定义列表。 我的解答1234&lt;dl&gt; &lt;dt&gt;nowcoder&lt;/dt&gt; &lt;dd&gt;nowcoder&lt;/dd&gt;&lt;/dl&gt; 注意点 html5 前用得多，普通列表标签，既不是 ul，也不是 ol FED6 语义化标签描述请使用语义化标签创建头部标签且包含导航标签。注意：只需在 html 模块填写标签结构，有且仅有一个头部标签和一个导航标签。 我的解答123&lt;header&gt; &lt;nav&gt;&lt;/nav&gt;&lt;/header&gt; 注意点 就普通嵌套，看报错才知道标签名 FED7 音频媒体标签属性描述请写出具有控件功能的音频媒体标签。 我的解答1&lt;audio src=&quot;&quot; controls&gt;&lt;/audio&gt; 注意点 controls：如果声明了该属性，浏览器将提供一个包含声音，播放进度，播放暂停的控制面板，让用户可以控制音频的播放。 FED8 视频媒体标签属性描述请写出具有当视频的媒体数据加载期间发生错误时执行某个方法事件的视频媒体标签。 我的解答1&lt;video src=&quot;&quot; onerror=&quot;fn()&quot; controls&gt;&lt;/video&gt;&lt;audio src=&quot;&quot; controls&gt;&lt;/audio&gt; 注意点 controls：如果存在该属性，浏览器会在视频底部提供一个控制面板，允许用户控制视频的播放，包括音量、拖动进度、暂停或恢复播放。 02 CSSFED9 CSS 选择器——标签、类、ID 选择器描述请将 html 模块中字体内容是 “红色” 的字体颜色设置为 “rgb(255, 0, 0)”，”绿色” 设置为 “rgb(0, 128, 0)”，”黑色” 设置为 “rgb(0, 0, 0)”，且字体大小都为 20px。 我的解答1234567891011121314&lt;style&gt; .green &#123; color: rgb(0, 128, 0); font-size: 20px; &#125; #black &#123; color: rgb(0, 0, 0); font-size: 20px; &#125;&lt;/style&gt;&lt;div style=&quot;color:rgb(255, 0, 0);font-size:20px&quot;&gt;红色&lt;/div&gt;&lt;div class=&quot;green&quot;&gt;绿色&lt;/div&gt;&lt;div id=&quot;black&quot;&gt;黑色&lt;/div&gt; 注意点 类选择器：. id 选择器：# FED10 CSS 选择器——伪类选择器描述请将 html 模块中 ul 列表的第 2 个 li 标签和第 4 个 li 标签的背景颜色设置成 “rgb(255, 0, 0)”。 我的解答1234567891011&lt;style&gt; li:nth-child(2n) &#123; background-color: rgb(255, 0, 0); &#125;&lt;/style&gt;&lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt;&lt;/ul&gt; 注意点 伪类选择器 nth-child(2n)：偶数个 nth-child(2n-1)：奇数个 FED11 CSS 选择器——伪元素描述请给 html 模块的 div 元素加一个后伪元素，且后伪元素的宽度和高度都是 20px，背景颜色为 “rgb(255, 0, 0)”。 我的解答12345678910&lt;style&gt; div::after &#123; content: &quot;&quot;; height: 20px; width: 20px; background-color: rgb(255, 0, 0); display: inline-block; &#125;&lt;/style&gt;&lt;div&gt;&lt;/div&gt; 注意点 ::after 会创建一个 伪元素，作为所选元素的最后一个子元素 包含 content，可以表示文字，图片等 display: inline-block; 要设置为块级元素才能给其设置宽高 FED12 按要求写一个圆描述请将 html 模块的 div 元素设置为一个半径是 50px 的圆，且边框为 1px 的黑色实线。要求： 圆角属性仅设置一个值 圆角属性单位请使用 px 注意：由于圆角属性设置广泛且都可以实现题目效果，所以请按照要求规范书写。 我的解答123456789&lt;style&gt; div &#123; width: 100px; height: 100px; border-radius: 50px; border: 1px solid black; &#125;&lt;/style&gt;&lt;div&gt;&lt;/div&gt; 注意点 border-radius 设置为 50%就是一个圆 FED13 设置盒子宽高描述请将 html 模块类为 “box” 的 div 元素宽度和高度都设置为 100px，且内间距为 20px、外间距为 10px。 我的解答123456789&lt;style&gt; .box &#123; width: 100px; height: 100px; padding: 20px; margin: 10px; &#125;&lt;/style&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt; 注意点 padding 内边距，margin 外边距 FED14 浮动和清除浮动描述请将类为 “left” 的 div 元素和类为 “right” 的 div 元素在同一行上向左浮动，且清除类为 “wrap” 的父级 div 元素内部的浮动。 我的解答123456789101112131415161718192021222324&lt;style&gt; .wrap::after &#123; content: &quot;&quot;; display: block; clear: both; &#125; .left &#123; width: 100px; height: 100px; background-color: red; float: left; &#125; .right &#123; width: 100px; height: 100px; background-color: yellow; float: left; &#125;&lt;/style&gt;&lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;&lt;/div&gt; 注意点 float 属性左右占位，上下不占位，所以下面的元素会浮动上来，所以可以在父类盒子加一个:: after 伪类元素，设置 clear:both 闭合父盒子的边界以达到清除浮动的目的。 css - 清除浮动（clearfix）的常见方法 - front-end development - SegmentFault 思否 FED15 段落标识描述请将下面这句话以段落的形式展示在浏览器中——“牛客网是一个专注于程序员的学习和成长的专业平台。” 我的解答1&lt;p&gt;牛客网是一个专注于程序员的学习和成长的专业平台。&lt;/p&gt; 注意点 考察 p 标签的使用方法 FED16 圣诞树描述圣诞节来啦！请用 CSS 给你的朋友们制作一颗圣诞树吧~这颗圣诞树描述起来是这样的： “topbranch”是圣诞树的上枝叶，该上枝叶仅通过边框属性、左浮动、左外边距即可实现。边框的属性依次是：宽度为 100px、是直线、颜色为 green（未显示的边框颜色都为透明） “middleBranch”是圣诞树的中枝叶，该上枝叶仅通过边框属性即可实现。边框的属性依次是：宽度为 200px、是直线、颜色为 green（未显示的边框颜色都为透明） “base”是圣诞树的树干，该树干仅通过左外边距实现居中于中枝叶。树干的宽度、高度分别为 70px、200px，颜色为 gray。 注意： 上枝叶、树干的居中都是通过左外边距实现的 没有显示的边框，其属性都是透明（属性） 仅通过 border 属性完成边框的所有属性设置 我的解答12345678910111213141516171819202122232425262728293031323334&lt;style&gt; .topbranch &#123; width: 0px; height: 0px; border-width: 100px; border-color: green; border-left-color: transparent; border-right-color: transparent; border-top-color: transparent; border-style: solid; float: left; margin-left: 100px; &#125; .middleBranch &#123; width: 0px; height: 0px; border-width: 200px; border-color: green; border-left-color: transparent; border-right-color: transparent; border-top-color: transparent; border-style: solid; &#125; .base &#123; width: 70px; height: 200px; background-color: grey; margin-left: 165px; &#125;&lt;/style&gt;&lt;section class=&quot;topbranch&quot;&gt;&lt;/section&gt;&lt;section class=&quot;middleBranch&quot;&gt;&lt;/section&gt;&lt;section class=&quot;base&quot;&gt;&lt;/section&gt; 注意点 1234border-color: green;border-left-color: transparent;border-right-color: transparent;border-top-color: transparent; 这样做会显示出三角形，把其他边颜色设置为 transparent 透明 FED17 固定定位描述请将 html 模块类为”box”的 div 元素固定在视口的左上角。 我的解答12345678&lt;style&gt; .box &#123; position: fixed; top: 0; left: 0; &#125;&lt;/style&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt; 注意点 position: fixed;可以让元素在浏览器某一个位置固定，不随滚动条而移动 FED18 CSS 单位（一）描述请将 html 模块中类为”box”的 div 元素的宽度和高度设置为自身字体大小的 4 倍。 我的解答1234567&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;style&gt; .box &#123; width: 4em; height: 4em; &#125;&lt;/style&gt; 注意点 em 指的相对父级的字体大小 FED19 CSS 单位（二）描述请将 html 模块 div 元素的宽度和高度设置为 html 根元素字体大小的 4 倍。注意：只需在 css 模块补全样式内容，请勿修改 html 模块。 我的解答1234567&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;style&gt; .box &#123; width: 4rem; height: 4rem; &#125;&lt;/style&gt; 注意点 rem 指的相对根级的字体大小(:root&#x2F;html) 03 JAVASCRIPTFED20 基本数据类型检测描述请补全 JavaScript 函数，要求以字符串的形式返回参数的类型。注意：只需检测基本数据类型。 我的解答12345&lt;script&gt; function _typeof(value) &#123; return typeof value; &#125;&lt;/script&gt; 注意点 typeof 可以返回数据类型 FED21 检测复杂数据类型描述请补全 JavaScript 函数，要求以 Boolean 的形式返回第一个参数是否属于第二个参数对象的实例。 我的解答12345&lt;script&gt; function _instanceof(left, right) &#123; return left instanceof right; &#125;&lt;/script&gt; 注意点 instanceof 可以检验参数是否为某个对象的实例 FED22 数据类型转换描述请补全 JavaScript 函数，要求以字符串的形式返回两个数字参数的拼接结果。示例： _splice(223,233) -&gt; “223233” _splice(-223,-233) -&gt; “-223-233” 我的解答123456&lt;script type=&quot;text/javascript&quot;&gt; // 填写JavaScript function _splice(left, right) &#123; return left.toString() + right.toString(); &#125;&lt;/script&gt; 注意点 使用toString把数字类型转为字符串类型，再相加 FED23 阶乘描述请补全 JavaScript 函数，要求返回数字参数的阶乘。注意：参数为大于等于 0 的整数。 我的解答1234567&lt;script type=&quot;text/javascript&quot;&gt; function _factorial(number) &#123; if (number &lt; 0) return; if (number == 1 || number == 0) return 1; return number * _factorial(number - 1); &#125;&lt;/script&gt; 注意点 使用递归完成阶乘更加简洁"}]