[{"title":"ftpget","path":"/posts/ftpget.html","content":"ftpget -u username -p passwd IP source target ftpput -u username -p passwd IP target source 举个例子： 12ftpput -u zhangsan -p 000000 192.168.10.10 target.txt source.txt // 将本地的 source.txt 文件传输到 192.168.10.10 /home/zhangsan/ 目录下，并以target.txt 保存","tags":["Linux工具"],"categories":["Linux工具"]},{"title":"scp","path":"/posts/scp.html","content":"一、从本地复制到远程主机命令格式如下： scp &#x2F;path&#x2F;to&#x2F;local&#x2F;file.txt user@remote_host:&#x2F;path&#x2F;on&#x2F;remote&#x2F; 这会将本地的 file.txt 文件复制到远程主机 remote_host 的 /path/on/remote/ 目录下。 二、从远程主机复制到本地（1）命令解释命令格式如下：scp user@remote_host:&#x2F;path&#x2F;on&#x2F;remote&#x2F;file.txt &#x2F;path&#x2F;to&#x2F;local&#x2F; 这会将远程主机 remote_host 的 /path/on/remote/file.txt 文件复制到本地的 /path/to/local/ 目录下。 （2）实际操作实操命令如下：scp &#114;&#111;&#x6f;&#116;&#64;&#x31;&#57;&#x32;&#46;&#49;&#54;&#56;&#46;&#49;&#46;&#49;&#48;&#x39;:&#x2F;home&#x2F;DataBaseMysql.zip .&#x2F; 这会将远程主机 192.168.1.109 的&#x2F;home&#x2F;DataBaseMysql.zip 文件复制到本地的当前目录下 三、递归复制目录实操命令如下：scp -r user@remote_host:&#x2F;path&#x2F;on&#x2F;remote&#x2F;directory &#x2F;path&#x2F;to&#x2F;local&#x2F; 这会将远程主机 remote_host 的 /path/on/remote/directory 目录及其所有内容复制到本地的 /path/to/local/ 目录下。 四、指定 SSH 端口如果远程主机的 SSH 端口不是默认的 22，可以使用 -P 选项指定端口： scp -P 2222 user@remote_host:&#x2F;path&#x2F;on&#x2F;remote&#x2F;file.txt &#x2F;path&#x2F;to&#x2F;local&#x2F;","tags":["Linux工具"],"categories":["Linux工具"]},{"title":"find","path":"/posts/find.html","content":"find . -name “my_file” find . -name &#x2F;etc -type d","tags":["Linux工具"],"categories":["Linux工具"]},{"title":"grep","path":"/posts/grep.html","content":"文本搜索工具，根据用户指定的“模式”（过滤条件），对目标文本逐行进行匹配，并打印输出匹配到的行。 完整语法： 123grep [options] [pattern] file 命令 参数 匹配模式 文件数据 常用参数： 常用参数 描述 -i 忽略大小写 -n 显示匹配行与行号 -r 递归查找子目录 -v 显示不能被匹配到的字符串 常用正则表达式 表达式\t解释 ^\t用于模式最左侧，如 “^yu” 即匹配以yu开头的单词 $\t用于模式最右侧，如 “yu$” 即匹配以yu结尾的单词 ^$\t组合符，表示空行 .\t匹配任意一个且只有一个字符，不能匹配空行 |\t使用egrep命令 重匹配前一个字符连续出现0次或1次以上 .*\t匹配任意字符 ^.*\t组合符，匹配任意多个字符开头的内容 .*$\t组合符，匹配任意多个字符结尾的内容 [abc]\t匹配 [] 内集合中的任意一个字符，a或b或c，也可以写成 [ac] [^abc]\t匹配除了 ^后面的任意一个字符，a或b或c，[]内 ^ 表示取反操作 常用： 1grep -nr &quot;xxx&quot; .","tags":["Linux工具"],"categories":["Linux工具"]},{"title":"内存检测工具","path":"/posts/内存检测工具.html","content":"在写大型C&#x2F;C++工程时难免会发生内存泄漏现象，系统编程中一个重要的方面就是有效地处理与内存相关的问题。你的工作越接近系统，你就需要面对越多的内存问题。有时这些问题非常琐碎，而更多时候它会演变成一个调试内存问题的恶梦。 常见的内存问题一共七种： 动态内存泄露； 资源泄露，比如文件指针不关闭； 动态内存越界； 4.数组内存越界； 5.动态内存double free； 6.使用野指针，即未初始化的指针； 7.释放野指针，即未初始化的指针。 内存问题非常难定位，对于小工程来说，简单去检查代码中new和delete的匹配对数就基本能定位到问题，但是一旦代码量上升到以万单位时，仅靠肉眼检查来定位问题那就非常困难了，所以我们需要利用工具帮助我们找出问题所在。在Linux系统下内存检测工具首推Valgrind，一款非常好用的开源内存管理框架。Valgrind其实是一个工具集，内存错误检测只是它众多功能的一个，但我们用得最多的功能正是它——memcheck。 该工具可以检测下列与内存相关的问题 : 未释放内存的使用 对释放后内存的读&#x2F;写 对已分配内存块尾部的读&#x2F;写 内存泄露 不匹配的使用malloc&#x2F;new&#x2F;new[] 和 free&#x2F;delete&#x2F;delete[] 重复释放内存 首先安装Valgrind非常简单： 123456789//valgrind下载：http://valgrind.org/downloads/valgrind-3.12.0.tar.bz2valgrind安装：1. tar -jxvf valgrind-3.12.0.tar.bz22. cd valgrind-3.12.03. ./configure4. make5. sudo make install 下面开始讲解Valgrind的应用场景。 注意: 下面讨论的所有测试代码都应该使用gcc&#x2F;g++并且加上-g选项。 1. 使用未初始化的内存（使用野指针）这里我们定义了一个指针p，但并未给他开辟空间，即他是一个野指针，但我们却使用它了。 Valgrind检测出我们程序使用了未初始化的变量，但并未检测出内存泄漏。 2.在内存被释放后进行读&#x2F;写（使用野指针）p所指向的内存被释放了，p变成了野指针，但是我们却继续使用这片内存。 Valgrind检测出我们使用了已经free掉的内存，并给出这片内存是哪里分配哪里释放的。 3.从已分配内存块的尾部进行读&#x2F;写（动态内存越界）我们动态地分配了一段数组，但我们在访问个数组时发生了越界读写，程序crash掉。 Valgrind检测出越界的位置。 注意：Valgrind不检查静态分配数组的使用情况！所以对静态分配的数组，Valgrind表示无能为力！比如下面的例子，程序crash掉，我们却不知道为什么。 4.内存泄漏内存泄漏的原因在于没有成对地使用malloc&#x2F;free和new&#x2F;delete，比如下面的例子。 Valgrind会给出程序中malloc和free的出现次数以判断是否发生内存泄漏，比如对上面的程序运行memcheck，Valgrind的记录显示上面的程序用了1次malloc，却调用了0次free，明显发生了内存泄漏！ 上面提示了我们可以使用–leak-check&#x3D;full进一步获取内存泄漏的信息，比如malloc和free的具体行号。 5. 不匹配地使用malloc&#x2F;new&#x2F;new[] 和 free&#x2F;delete&#x2F;delete[]正常使用new&#x2F;delete和malloc&#x2F;free是这样子的： 而不匹配地使用malloc&#x2F;new&#x2F;new[] 和 free&#x2F;delete&#x2F;delete[]则会被提示mismacth： 6.两次释放内存double free的情况同样是根据malloc&#x2F;free的匹配对数来体现的，比如free多了一次，Valgrind也会提示。 当然，Valgrind也不是万能的。Valgrind也有无法找到问题的时候，有些问题只能通过不断的review代码找到了症结。发现问题，解决问题，毕竟是末流。最好的方法，就是不引入内存问题。这可以通过良好的代码风格和设计来实现的。","tags":["Linux工具"],"categories":["Linux工具"]},{"title":"top","path":"/posts/top.html","content":"1ps -ef | grep xxx //xxx为进程名字 通过ps找到进程号，通过如下命令可以查看该进程下的所有线程CPU利用率，注意这里是该进程PID下对应的所有线程 1top -H -p pid 例如进程pid为5810，则命令为： 1top -H -p 5810 一、top命令的使用帮助1、top命令的选项top命令的使用方法：top [-d number] | top [-bnp] 选项 解析 -b 以批处理模式操作； -c 显示完整的治命令； -d 屏幕刷新间隔时间； -I 忽略失效过程； -s 保密模式； -S 累积模式； -i&lt;时间&gt; 设置间隔时间； -u&lt;用户名&gt; 指定用户名； -p&lt;进程号&gt; 指定进程； -n&lt;次数&gt; 循环显示的次数。 二、top命令的交换命令在top命令执行过程中可以使用的一些交互命令。这些命令都是单字母的，如果在命令行中使用了-s选项， 其中一些命令可能会被屏蔽。 也就是在top命令运行过程中，可以按下如下案件，会按照相应指令显示 1234567891011121314151617h：显示帮助画面，给出一些简短的命令总结说明；k：终止一个进程；i：忽略闲置和僵死进程，这是一个开关式命令；q：退出程序；r：重新安排一个进程的优先级别；S：切换到累计模式；s：改变两次刷新之间的延迟时间（单位为s），如果有小数，就换算成ms。输入0值则系统将不断刷新，默认值是5s；f或者F：从当前显示中添加或者删除项目；o或者O：改变显示项目的顺序；l：切换显示平均负载和启动时间信息；m：切换显示内存信息；t：切换显示进程和CPU状态信息；c：切换显示命令名称和完整命令行；M：以内存的使用资源排序显示；P：根据CPU使用百分比大小进行排序；T：根据时间/累计时间进行排序；w：将当前设置写入~/.toprc文件中。 三、top显示信息解释1、top的第一行解释在命令行输入top，进入系统监控信息的交互界面，第一行解释如下： 123410:40:53 表示当前时间up 7:09 系统运行时间，格式为时：分。3 users 当前登录用户数load average: 0.05, 0.03, 0.05 系统负载，即任务队列的平均长度。 三个数值分别为 1分钟、5分钟、15分钟前到现在的平均值。 2、top的第二、三行信息解释在命令行输入top，进入系统监控信息的交互界面，第2、3行为进程和CPU的信息，当有多个CPU时，这些内容可能会超过两行， 第二行解释如下： 12345678910111213216 total 进程总数1 running 正在运行的进程数215 sleeping 睡眠的进程数0 stopped 停止的进程数0 zombie 僵尸进程数0.0 us 用户空间占用CPU百分比0.1 sy 内核空间占用CPU百分比0.0 ni 用户进程空间内改变过优先级的进程占用CPU百分比99.9 id 空闲CPU百分比0.0 wa 等待输入输出的CPU时间百分比0.0 hi 硬中断（Hardware IRQ）占用CPU的百分比0.0 si 软中断（Software Interrupts）占用CPU的百分比0.0 st 虚拟CPU等待实际CPU的时间的百分比。 3、top的第四、五行信息解释第四行及第五行主要显示系统的内存信息。 123456789KiB Mem: 12119056 tota 物理内存总量10016948 free 空闲内存总量923252 used 使用的物理内存总量1178856 buff/cache 用作内核缓存的内存量KiB Swap: 2093052 total 交换区总量267544 used 使用的交换区总量2093052 free 空闲交换区总量0 used 缓冲的交换区总量。10742188 avail Mem 代表可用于进程下一次分配的物理内存数量 4、top的进程信息top命令的交换界面主要区域，监控系统进程的实时状态信息。 123456789101112PID 进程idUSER 进程所有者的用户名PR 优先级NI nice值，负值表示高优先级，正值表示低优先级。VIRT 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RESRES 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATASHR 共享内存大小，单位kbS 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程%CPU 上次更新到现在的CPU时间占用百分比%MEM 进程使用的物理内存百分比TIME+ 进程使用的CPU时间总计，单位1/100秒COMMAND 命令名/命令行 其余监控项解释 1234567891011121314PPID 父进程idRUSER Real user nameUID 进程所有者的用户idGROUP 进程所有者的组名TTY 启动进程的终端名。不是从终端启动的进程则显示为 ?P 最后使用的CPU，仅在多CPU环境下有意义TIME 进程使用的CPU时间总计，单位秒SWAP 进程使用的虚拟内存中，被换出的大小，单位kbCODE 可执行代码占用的物理内存大小，单位kbDATA 可执行代码以外的部分(数据段+栈)占用的物理内存大小，单位kbnFLT 页面错误次数nDRT 最后一次写入到现在，被修改过的页面数。WCHAN 若该进程在睡眠，则显示睡眠中的系统函数名Flags 任务标志 四、top命令的基本使用1、查看当前系统cpu占用最高的进程 进入top交互界面后，按P键对CPU负载的进程进行排列。 2、查看当前系统内存使用最高的进程 进入top交互界面后，按M键对CPU负载的进程进行排列。 3、对排序的列进行高亮显示 敲击键盘‘x’（打开&#x2F;关闭排序列的加亮效果） 4、对运行的进程进行高亮显示 敲击键盘‘b’（打开关闭加亮效果），对运行的进程进行高亮显示","tags":["Linux工具"],"categories":["Linux工具"]},{"title":"tcpdump","path":"/posts/tcpdump.html","content":"tmpdump用于抓包，一个例子： 1tcpdump -i any host 192.168.x.x -s0 -vvv -w 1.cap -i any 任何网络 -s0 防止截断 -w写入文件 -vvv详细的信息 最终得到一个名为1.cap的文件，可以使用wireshark工具打开","tags":["Linux工具"],"categories":["Linux工具"]},{"title":"sed","path":"/posts/sed.html","content":"https://blog.csdn.net/2301_78315274/article/details/133880462 1、将每行第一个111替换为AAA 1sed -i &quot;s/111/AAA/&quot; a.txt -i作用会修改源文件，如这里的a.txt，如果不加-i就不会修改，只是命令回显改变了 2、替换所有的111为AAA 11. sed -i &quot;s/111/AAA/g&quot; a.txt 3、替换第一到四行的所有111为AAA 1sed &quot;1,4s/111/AAA/g&quot; a.txt","tags":["Linux工具"],"categories":["Linux工具"]},{"title":"tar","path":"/posts/tar.html","content":"tar全称是tape archive，初衷是将多个文件写入磁带。首先，需要分清两个概念——打包与压缩。打包：将多个文件汇总成一个文件。压缩：将一个大文件通过压缩算法变成一个小文件。而tar命令执行的打包流程，真正执行压缩的是使用的压缩算法，比如gzip、bzip2、xz。tar命令在Linux社区内十分受欢迎，其中一个原因就是灵活性强，可以根据需要选择不同的压缩算法。 一、常用参数 打包过程 -c或--create。创建档案文件（可以理解为压缩包名） -x或--extract。解压（提取）文件 -f或--file。指定档案文件，告诉tar命令，后面是文件名 -t或--list。列出档案文件的内容 -v或--verbose。显示处理文件的详细信息 当多个参数简写在一起的时候，可以只用一个-。在实际使用中，最常使用的参数就是-cvf，即创建压缩包，并以显示详细处理信息。 压缩过程 gzip：参数-z或--gzip；文件拓展名：.tar.gz或.tgz bzip2：-j或--bzip2；.tar.bz2 xz：-J或--xz；.tar.xz 压缩算法之间的区别： 压缩算法 gzip bzip2 xz 参数 -z -j -J 文件拓展名 .tar.gz .tar.bz2 .tar.xz 压缩速度 快 中 慢 解压速度 快 中 中 压缩比 低 中 高 资源占用 少 中 高 适用场景 快速压缩&#x2F;解压 高压缩比 最大压缩比 在日常使用中，使用gzip压缩就可以了，虽然压缩比低，但是它十分的快。并且如果被压缩的文件本身就比较小，使用xz压缩的结果也不会少太多。因此，日常使用建议gzip，既想要速度也想要压缩比建议bzip2，超大文件建议xz。 二、示例流程相似，只需更换压缩算法的参数。 1234567# 压缩。压缩包名 + 被压缩的目录或者文件路径tar -czvf archive_name.tar.gz path_to_compress# 解压。用什么压缩算法压缩的，就用什么压缩算法解压tar -xzvf archive_name.tar.gz # 解压到当前目录tar -xzvf archive_name.tar.gz -C path_to_extract # 解压至指定目录。 -C （change directory）指出目录地址","tags":["Linux工具"],"categories":["Linux工具"]},{"title":"objdump","path":"/posts/objdump.html","content":"objdump提供了对二进制文件进行反汇编和查看目标文件信息的能力。用于分析目标文件（object file）和可执行文件（executable file）。它可以显示二进制文件的汇编代码、符号表、段信息等，是理解程序底层实现、调试和逆向工程的有力助手。 一、objdump的基本用法显示目标文件的反汇编代码： 1objdump -d your_binary 该命令会显示目标文件中所有段的反汇编代码。这是一种深入了解程序执行逻辑的方式。 显示符号表信息： 1objdump -t your_binary 该命令会显示目标文件的符号表，包括函数名、变量名等信息。 显示文件头信息： 1objdump -f your_binary 该命令显示目标文件的文件头信息，包括文件格式、入口点地址等。objdump 的使用还可以根据需求加入一些参数来获取更详细的信息。 显示所有段的详细信息： 1objdump -p your_binary 这将显示目标文件中所有段的详细信息，包括每个段的大小、偏移量等。 显示特定段的反汇编代码： 1objdump -s -j section_name your_binary 这将显示指定段（section_name）的反汇编代码。 只显示符号表的信息： 1objdump -T your_binary 该命令显示符号表的信息，但不显示反汇编代码。 显示源代码和反汇编代码： 1objdump -S your_binary 这将显示源代码和反汇编代码的混合视图，方便理解源代码和汇编之间的对应关系。 以指定格式显示反汇编代码： 1objdump -M intel -d your_binary -M 参数允许你指定反汇编代码的输出格式，例如 intel 或 att。 以上是一些常见的 objdump 用法和参数。通过组合使用这些参数，你可以根据具体的需求更深入地了解目标文件的内部结构和代码执行逻辑。","tags":["Linux工具"],"categories":["Linux工具"]},{"title":"objcopy","path":"/posts/objcopy.html","content":"objcopy转换elf文件为bin文件，以下是一个将boot.elf转为boot.bin的命令 1arm-linux-objcopy -O binary -R .note -R .comment -S boot.elf boot.bin 使用 -O binary (或–out-target&#x3D;binary) 输出为原始的二进制文件 使用 -R .note (或–remove-section) 输出文件中不要.note这个section，缩小了文件尺寸 使用 -S (或 –strip-all) 输出文件中不要重定位信息和符号信息，缩小了文件尺寸","tags":["Linux工具"],"categories":["Linux工具"]},{"title":"nm","path":"/posts/nm.html","content":"nm命令是linux下针对某些特定文件的分析工具，能够列出库文件（.a、.lib）、目标文件（*.o）、可执行文件的符号表。 一、nm命令的常用参数 -A 或 -o 或 –print-file-name：打印出每个符号属于的文件 -a 或 –debug-syms：显示调试符号。 -B：等同于–format&#x3D;bsd，用来兼容MIPS的nm。 -C 或 –demangle：将低级符号名解码(demangle)成用户级名字。这样可以使得C++函数名具有可读性。 -D 或 –dynamic：显示动态符号。该任选项仅对于动态目标(例如特定类型的共享库)有意义。 -f forma 或 –format&#x3D;formatt：使用format格式输出。format可以选取bsd、sysv或posix，该选项在GNU的nm中有用。默认为bsd。 -g 或 –extern-only：仅显示外部符号。 -n 、-v 或 –numeric-sort：按符号对应地址的顺序排序，而非按符号名的字符顺序。 -p 或 –no-sort：按目标文件中遇到的符号顺序显示，不排序。 -P 或 –portability：使用POSIX.2标准输出格式代替默认的输出格式。等同于使用任选项-f posix。 -s 或 –print-armap：当列出库中成员的符号时，包含索引。索引的内容包含：哪些模块包含哪些名字的映射。 -r 或 –reverse-sort：反转排序的顺序(例如，升序变为降序)。 –size-sort：按大小排列符号顺序。该大小是按照一个符号的值与它下一个符号的值进行计算的。 -t radix 或 –radix&#x3D;radix：使用radix进制显示符号值。radix只能为“d”表示十进制、“o”表示八进制或“x”表示十六进制。 –target&#x3D;bfdname：指定一个目标代码的格式，而非使用系统的默认格式。 -u 或 –undefined-only：仅显示没有定义的符号(那些外部符号)。 -l 或 –line-numbers：对每个符号，使用调试信息来试图找到文件名和行号。对于已定义的符号，查找符号地址的行号。对于未定义符号，查找指向符号重定位入口的行号。如果可以找到行号信息，显示在符号信息之后。 -V 或 –version：显示nm的版本号。 –help：显示nm的任选项。 举个栗子 编写源文件test.c 1234567891011#include &lt;stdio.h&gt;const char ch = &#x27;x&#x27;;int uninit;int init = 10;void function() &#123; int *ref = &amp;init; static int sta_int = 10; printf(&quot;%c&quot;, ch);&#125; 编译test.c文件 生成test.o gcc -c test.c 用nm命令分析符号表 nm -n test.o（-n以地址排序，方便查看） 输出结果： 123456 U putchar0000000000000000 R ch0000000000000000 T function0000000000000000 D init0000000000000004 d sta_int.21820000000000000004 C uninit 二、nm信息的含义第一列：符号值，即该符号的起始地址第二列：符号类型，各字母代表什么类型在下一小节中介绍第三列：符号名称 三、输出符号类型详解符号类型大写代表全局符号，小写代表本地符号 A 该符号的值是绝对的，在以后的链接过程中，不允许进行改变。这样的符号值，常常出现在中断向量表中，例如用符号来表示各个中断向量函数在中断向量表中的位置。 B 该符号的值出现在非初始化数据段(bss)中。例如，在一个文件中定义全局static int test。则该符号test的类型为b，位于bss section中。其值表示该符号在bss段中的偏移。一般而言，bss段分配于RAM中。 C 该符号为common。common symbol是未初始话数据段。该符号没有包含于一个普通section中。只有在链接过程中才进行分配。符号的值表示该符号需要的字节数。例如在一个c文件中，定义int test，并且该符号在别的地方会被引用，则该符号类型即为C。否则其类型为B。 D 该符号位于初始话数据段中。一般来说，分配到data section中。例如定义全局int baud_table[5] &#x3D; {9600, 19200, 38400, 57600, 115200}，则会分配于初始化数据段中。 G 该符号也位于初始化数据段中。主要用于small object提高访问small data object的一种方式。 I 该符号是对另一个符号的间接引用。 N 该符号是一个debugging符号。 R 该符号位于只读数据区。例如定义全局const int test[] &#x3D; {123, 123};则test就是一个只读数据区的符号。注意在cygwin下如果使用gcc直接编译成MZ格式时，源文件中的test对应_test，并且其符号类型为D，即初始化数据段中。但是如果使用m6812-elf-gcc这样的交叉编译工具，源文件中的test对应目标文件的test,即没有添加下划线，并且其符号类型为R。一般而言，位于rodata section。值得注意的是，如果在一个函数中定义const char *test &#x3D; “abc”, const char test_int &#x3D; 3。使用nm都不会得到符号信息，但是字符串“abc”分配于只读存储器中，test在rodata section中，大小为4。 S 符号位于非初始化数据区，用于small object。 T 该符号位于代码区text section。 U 该符号在当前文件中是未定义的，即该符号的定义在别的文件中。例如，当前文件调用另一个文件中定义的函数，在这个被调用的函数在当前就是未定义的；但是在定义它的文件中类型是T。但是对于全局变量来说，在定义它的文件中，其符号类型为C，在使用它的文件中，其类型为U。 V 该符号是一个weak object。 W 该符号是没有被明确标记为weak object的弱符号类型。 该符号是a.out格式文件中的stabs symbol。 ? 该符号类型没有定义。","tags":["Linux工具"],"categories":["Linux工具"]},{"title":"readelf","path":"/posts/readelf.html","content":"一、三类目标文件（ELF）：1.可重定位目标文件 (.o ) 每个 .o 文件都是由对应的 .c 文件通过编译器和汇编器生成；包含代码和数据，代码和数据地址都从0开始。通过 gcc -c xxx.c 得到。 2.可执行目标文件（默认为a.out） 由链接器生成，包含的代码和数据可以直接通过加载器加载到内存中并被执行。通过gcc -o xxx.c 得到。 3.共享目标文件 (.so） 特殊的可重定位目标文件，可以在链接(静态共享库)时加入目标文件或加载时或运行时(动态共享库)被动态的加载到内存并执行。在 windows 中被称为 Dynamic Link Libraries(DLLs)。 gcc xxx.c -fPIC -shared -o libxxx.so （-fPIC 作用于编译阶段，告诉编译器产生与位置无关代码。） readelf命令： 通过readelf来区分上面三种类型的ELF文件，每种类型文件的头部信息是不一样的。 二、readelf -hreadelf -h main.o -h等价于–file-header 1234567891011121314151617181920 1 ELF Header: 2 Magic: 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 3 Class: ELF64 4 Data: 2&#x27;s complement, little endian 5 Version: 1 (current) 6 OS/ABI: UNIX - System V 7 ABI Version: 0 8 Type: REL (Relocatable file) 9 Machine: Advanced Micro Devices X86-6410 Version: 0x111 Entry point address: 0x012 Start of program headers: 0 (bytes into file)13 Start of section headers: 720 (bytes into file)14 Flags: 0x015 Size of this header: 64 (bytes)16 Size of program headers: 0 (bytes)17 Number of program headers: 018 Size of section headers: 64 (bytes)19 Number of section headers: 1220 Section header string table index: 11 第 1 行，ELF Header: 指名 ELF 文件头开始。 第 2 行，Magic 魔数，用来指名该文件是一个 ELF 目标文件。第一个字节 7F 是个固定的数；后面的 3 个字节正是 E, L, F 三个字母的 ASCII 形式。 第 3 行，CLASS 表示文件类型，这里是 64位的 ELF 格式。 第 4 行，Data 表示文件中的数据是按照什么格式组织(大端或小端)的，不同处理器平台数据组织格式可能就不同，如x86平台为小端存储格式。 第 5 行，当前 ELF 文件头版本号，这里版本号为 1 。 第 6 行，OS&#x2F;ABI ，指出操作系统类型，ABI 是 Application Binary Interface 的缩写。 第 7 行，ABI 版本号，当前为 0 。 第 8 行，Type 表示文件类型。ELF 文件有 3 种类型，一种是如上所示的 Relocatable file 可重定位目标文件，一种是可执行文件(Executable)，另外一种是共享库(Shared Library) 。 [这里就是区分上面三种类型的ELF文件] 第 9 行，机器平台类型，这里是在X86-64位机器。 第 10 行，当前目标文件的版本号。 第 11 行，程序的虚拟地址入口点，因为这还不是可运行的程序，故而这里为零。如果是可运行程序，这个地址并不是main函数的地址，而是_start函数的地址，_start由链接器创建，_start是为了初始化程序。通过这个命令可以看到_start函数，objdump -d -j .text a.out(默认，改名之后需更改此处)。 第 12 行，与 11 行同理，这个目标文件没有 Program Headers。 第 13 行，sections 头开始处，这里 720 是十进制，表示从地址偏移 0x450 处开始。 第 14 行，是一个与处理器相关联的标志，x86 平台上该处为 0 。 第 15 行，ELF 文件头的字节数。64bytes 第 16 行，因为这个不是可执行程序，故此处大小为 0。 第 17 行，同理于第 16 行。 第 18 行，sections header 的大小，这里每个 section 头大小为 64bytes。 第 19 行，一共有多少个 section 头，这里是 12个。 第 20 行，section 头字符串表索引号。区中存储的信息是用来链接使用的，主要包括：程序代码、程序数据（变量）、重定向信息等。比如：Code section保存的是代码，data section保存的是初始化或未初始化的数据，等等。 三、readelf -S main功能：查看区内容 1234567891011121314151617181920212223242526272829303132333435361 There are 29 section headers, starting at offset 0x1948: 2 Section Headers: 3 [Nr] Name Type Address Offset Size EntSize Flags Link Info Align 4 [ 0] NULL 0000000000000000 00000000 0000000000000000 0000000000000000 0 0 0 5 [ 1] .interp PROGBITS 0000000000000238 00000238 000000000000001c 0000000000000000 A 0 0 1 6 [ 2] .note.ABI-tag NOTE 0000000000000254 00000254 0000000000000020 0000000000000000 A 0 0 4 7 [ 3] .note.gnu.build-i NOTE 0000000000000274 00000274 0000000000000024 0000000000000000 A 0 0 4 8 [ 4] .gnu.hash GNU_HASH 0000000000000298 00000298 000000000000001c 0000000000000000 A 5 0 8 9 [ 5] .dynsym DYNSYM 00000000000002b8 000002b8 0000000000000090 0000000000000018 A 6 1 810 [ 6] .dynstr STRTAB 0000000000000348 00000348 000000000000007d 0000000000000000 A 0 0 111 [ 7] .gnu.version VERSYM 00000000000003c6 000003c6 000000000000000c 0000000000000002 A 5 0 212 [ 8] .gnu.version_r VERNEED 00000000000003d8 000003d8 0000000000000020 0000000000000000 A 6 1 813 [ 9] .rela.dyn RELA 00000000000003f8 000003f8 00000000000000c0 0000000000000018 A 5 0 814 [10] .init PROGBITS 00000000000004b8 000004b8 0000000000000017 0000000000000000 AX 0 0 415 [11] .plt PROGBITS 00000000000004d0 000004d0 0000000000000010 0000000000000010 AX 0 0 1616 [12] .plt.got PROGBITS 00000000000004e0 000004e0 0000000000000008 0000000000000008 AX 0 0 817 [13] .text PROGBITS 00000000000004f0 000004f0 00000000000001e2 0000000000000000 AX 0 0 1618 [14] .fini PROGBITS 00000000000006d4 000006d4 0000000000000009 0000000000000000 AX 0 0 419 [15] .rodata PROGBITS 00000000000006e0 000006e0 0000000000000004 0000000000000004 AM 0 0 420 [16] .eh_frame_hdr PROGBITS 00000000000006e4 000006e4 0000000000000044 0000000000000000 A 0 0 421 [17] .eh_frame PROGBITS 0000000000000728 00000728 0000000000000128 0000000000000000 A 0 0 822 [18] .init_array INIT_ARRAY 0000000000200df0 00000df0 0000000000000008 0000000000000008 WA 0 0 823 [19] .fini_array FINI_ARRAY 0000000000200df8 00000df8 0000000000000008 0000000000000008 WA 0 0 824 [20] .dynamic DYNAMIC 0000000000200e00 00000e00 00000000000001c0 0000000000000010 WA 6 0 825 [21] .got PROGBITS 0000000000200fc0 00000fc0 0000000000000040 0000000000000008 WA 0 0 826 [22] .data PROGBITS 0000000000201000 00001000 0000000000000018 0000000000000000 WA 0 0 827 [23] .bss NOBITS 0000000000201018 00001018 0000000000000008 0000000000000000 WA 0 0 128 [24] .comment PROGBITS 0000000000000000 00001018 000000000000002b 0000000000000001 MS 0 0 129 [25] .symtab SYMTAB 0000000000000000 00001048 0000000000000600 0000000000000018 26 43 830 [26] .strtab STRTAB 0000000000000000 00001648 0000000000000200 0000000000000000 0 0 131 [27] .shstrtab STRTAB 0000000000000000 00001848 00000000000000f9 0000000000000000 0 0 132 Key to Flags:33 W (write), A (alloc), X (execute), M (merge), S (strings), I (info),34 L (link order), O (extra OS processing required), G (group), T (TLS),35 C (compressed), x (unknown), o (OS specific), E (exclude),36 l (large), p (processor specific) .text：已编译程序的机器代码（二进制指令），该区的标志为X表示可执行。 .rodata：只读数据，比如printf语句中的格式串和开关（switch）语句的跳转表。 .data：已初始化的全局C变量。局部C变量在运行时被保存在栈中，既不出现在.data中，也不出现在.bss节中。 .bss：未初始化的全局C变量。在目标文件中并没有分配实际的空间给它，它只是一个占位符。目标文件格式区分初始化和未初始化变量是为了空间效率在：在目标文件中，未初始化变量不需要占据任何实际的磁盘空间。 .symtab：一个符号表（symbol table），它存放在程序中被定义和引用的函数和全局变量的信息。一些程序员错误地认为必须通过-g选项来编译一个程序，得到符号表信息。实际上，每个可重定位目标文件在.symtab中都有一张符号表。然而，和编译器中的符号表不同，.symtab符号表不包含局部变量的表目。 .rel.text：当链接噐把这个目标文件和其他文件结合时，.text节中的许多位置都需要修改。一般而言，任何调用外部函数或者引用全局变量的指令都需要修改。另一方面调用本地函数的指令则不需要修改。注意，可执行目标文件中并不需要重定位信息，因此通常省略，除非使用者显式地指示链接器包含这些信息。 .rel.data：被模块定义或引用的任何全局变量的信息。一般而言，任何已初始化全局变量的初始值是全局变量或者外部定义函数的地址都需要被修改。 .strtab：一个字符串表，其内容包括.symtab和.debug节中的符号表，以及节头部中的节名字。字符串表就是以null结尾的字符串序列。 .init和.fini保存了进程初始化和结束所用的代码，这通常是由编译器自动添加的。 四、readelf -sreadelf -s main.o 功能：查看符号表，Value的值是符号的地址。 1234567891011121314Symbol table &#x27;.symtab&#x27; contains 12 entries: Num: Value Size Type Bind Vis Ndx Name 0: 0000000000000000 0 NOTYPE LOCAL DEFAULT UND 1: 0000000000000000 0 FILE LOCAL DEFAULT ABS main.c 2: 0000000000000000 0 SECTION LOCAL DEFAULT 1 3: 0000000000000000 0 SECTION LOCAL DEFAULT 3 4: 0000000000000000 0 SECTION LOCAL DEFAULT 4 5: 0000000000000000 0 SECTION LOCAL DEFAULT 6 6: 0000000000000000 0 SECTION LOCAL DEFAULT 7 7: 0000000000000000 0 SECTION LOCAL DEFAULT 5 8: 0000000000000000 8 OBJECT GLOBAL DEFAULT 3 array 9: 0000000000000000 33 FUNC GLOBAL DEFAULT 1 main 10: 0000000000000000 0 NOTYPE GLOBAL DEFAULT UND _GLOBAL_OFFSET_TABLE_ 11: 0000000000000000 0 NOTYPE GLOBAL DEFAULT UND sum 符号表保存了程序实现或使用的所有全局变量和函数，如果程序引用一个自身代码未定义的符号，则称之为未定义符号，这类引用必须在静态链接期间用其他目标模块或库解决，或在加载时通过动态链接解决。","tags":["Linux工具"],"categories":["Linux工具"]},{"title":"dm-verity","path":"/posts/dm-verity.html","content":"一、技术模块简介 Dm-verity 是 device-mapper 架构下的一个目标设备类型， 通过它来保障设备或者设备分区的完整性。 dm-verity通常用于验证镜像的完整性。比如常规的系统启动的对根文件系统的验签，耗时很长。可以使用dm-verity替代，由于dm-verity是使用时才进行hash计算校验，所以对启动性能的提高有很大帮助。 Dm-verity类型的目标设备有两个底层设备，一个是数据设备(data device), 是用来存储实际数据的，另一个是hash设备(hash device), 用来存储hash数据的，这个是用来校验data device数据的完整性的。 简单的架构图如下： 图中映射设备(Mapper Device)和目标设备(Target Device)是一对一关系，对映射设备的读操作被映射成对目标设备的读操作，在目标设备中，dm-verity又将读操作映射为数据设备（Data Device）的读操作。但是在读操作的结束处，dm-verity加了一个额外的校验操作，对读到的数据计算一个hash值，用这个哈希值和存储在哈希设备(Hash Device) 二、设计原理 对于本文要介绍的dm-verity功能模块，笔者选择在当前移动终端应用的角度来展开讲解，也就是Android平台在dm-verity的应用。 Android 端主要是在镜像启动时验证这个功能场景上使用到了 dm-verity 技术，该技术可以对块存储设备进行完整性检查，有助于阻止某些恶意程序对镜像的修改，有助于Android用户在启动设备时确认设备状态与上次使用时是否相同。在系统镜像(比如 system、vendor等)启动时以及运行时可以实时性监测当前镜像是否被篡改。 通过dm-verity技术，可以确认块设备内容是否跟预期一致，具体的实现原理是利用哈希树(hashtree)做到的。用以下图来形象说明 (图来自：https://source.android.com/security/verifiedboot/dm-verity) 简单说明一下这个插图背后的原理： 在编译(一般应该是运行open)阶段，首先会对系统镜像(比如system.img、vendor.img)按照每4k大小计算对应hash，将这些hash信息存起来，形成上面图中的layer 0层，紧接着会对 layer 0 层同样按照每4k大小计算hash，并将这层的hash信息存起来，形成layer 1层，以此类推，直至最后的hash信息存放在一个4k大小的块中(未填满使用0填充)，这里边存储的hash信息称为 root hash。 在运行阶段，对于镜像里的文件进行访问时，操作对应所在块设备的存储区域时，会计算当前存储块(按4k大小)的hash值，然后会跟存储在哈希树上对应块的hash值进行比较，如果匹配不上，则认为当前该文件在底层存储被篡改或是损坏了。 为了更形象的描述下镜像运行时如何利用哈希树做校验的，下面以一个1G大小的镜像为例，来说明一下这个过程： 根据 hashtree 的生成方式，以 1G 的镜像为例： 1）按照 4K 大小划分，将1G 大小的镜像依顺序划分可得到 262144 个 4k 大小的块 2）对这 262144 块数据块进行第一层(Level 0) hash 计算，由于 SHA256(具体的hash算法可配置，此例以SHA256为参考) 计算出来的hash值占 256 个字节，一个 4K 的块可以存储 128 个hash值，所以存储这 262144 块数据块的hash值需要花费 2048 块 3）对第一层存储 hash 值的数据块进行第二层(Level 1) 的 hash 计算，同理，计算这 2048 块hash数据块需要花费 16 块 4）对第二层存储 hash 值的数据块进行第三层(Level 2) 的 hash 计算，由于第二层的hash数据块小于128块，所以第三层是最后一层，直接计算得到 root hash 数据块(不够4K大小补齐0)。 细心的读者可能已经发现了，Level 0 层其实已经包含了所有raw data数据块的hash信息了，也就说明Level 0 层已经具备可以验证 raw data 的能力了，为何还需要在 Level 0 的基础上继续算hash组装下一个 Level 层级呢？ 这里要引入一个安全策略设计问题，镜像raw data数据块是由对应的hash信息来校验保证的，为了保证镜像raw data是我们“想要的”，我们还需要对 hash 信息进行合法性验证，简单理解就是要确认这个hash信息是我们“想要的”， 方法就是对这个hash信息再次计算一次hash值，这里称为 root hash，然后添加一些类似于签名保护并保存起来（通常在实际工作中，在镜像编译阶段将root hash计算出来，保存在镜像的某个地方，通过cms等签名方式保存，启动阶段会进行cms验签以保证root_hash的正确性），主要是为了防止 root hash 被非法篡改。在一次 raw data 数据块的校验过程中，需要对 hash 信息计算一次 hash，然后跟保存的 root hash 进行比较，验证了 hash 信息的合法性之后，再来校验对应的 raw data 数据块。 有了以上背景，再回到刚刚这个“为何还需要在 Level 0 的基础上继续算hash组装下一个 Level 层级”的问题，按照上面的安全策略，如果 hash 信息只有 Level 0 一层的话，接下来对 raw data 数据块的校验将会是这样：每操作一个raw data数据块，都需要计算一次 Level 0 的 hash 值，跟 root hash 进行比较，验证合法之后再对 raw data 数据块进行校验。本文中举例是 1G 的镜像，Level 0用来保存 hash 信息的数据块已经达到 2048 块，如果对面对更大的镜像，Level 0 所占的数据块也会更大，如果是按照上面的计算方法，对 raw data 数据块的校验效率将会非常非常低。 作为对比，哈希树机制是如何体现出效率呢，下面以具体某一块 raw data 数据块的读取过程来说明其设计原理： 1）假设目前正需要读取第 200000 块的数据块，通过前面哈希树的构造，可以比较快速的计算出在 Level 0 层，也就是直接对应这个数据块的hash值存储位置，通过对 128 相除以及求余的方式就可以分别计算出该 hash 值存储在具体某一块(块A)以及这一块上的偏移(偏移A)。 2）确定了 Level 0 层的具体块A后，利用相同的方式可以得到 Level 0 块A在 Level 1 层存储其 hash 值的块B位置以及块B上的偏移(偏移B) 3）同上述原理，可以最终定位到 Level 1 层块 B 在 Level 2 上的数据块(只有一块)上偏移(偏移C) 4）在获取到该数据块对应hashtree关联的各个层级的块以及偏移后，接下来就是做一层一层的验证： 步骤1. 优先验证的是Level 2 中的数据块(只有一个4k的数据块)， 计算这个数据块的hash，跟保存的 root hash进行比对，验证Level 2的数据块块是否正确。 步骤2. 在Level 2中的数据块得到验证后，由上面计算到的Level 2中数据块上的偏移 C 去校验 Level 1 层的 B 块。 步骤3. 在 Level 1 层的 B 数据块得到验证后，由上面计算到的 Level 1 中 B 数据块上的偏移B去验证 Level 0 层的 A块。 步骤4. Level 0层中的 A 数据块得到验证后，最终会由 Level 0 层的偏移A来校验最终的 raw data数据块(第 200000 块). 可以看到，在使用哈希树的设计之后，对数据块验证整个过程中，涉及到的数据块hash计算只有3块(有N层就计算N块)，相比于一层校验模式，效率要高很多。 三、应用层面 读者到目前为止应该大致了解到了移动终端在镜像完整性校验上相关的设计原理，接下来会从应用端层面来说明如何使用 dm-verity 底层提供的接口来初始化 dm 设备，并为后续实时校验做好准备，内核绝大多数功能模块存在的意义都要靠跟应用端的交互来体现，作为对内核某个模块的研究，初步从应用层出发不乏是一个好办法。 通常系统启动阶段，使用veritysetup工具指定data device和hash device，以及指定的root hash值，hash device的具体位置，hash device通常位于data device的后面一部分。通过veritysetup工具执行后，会生成dm设备，如我们原来使用的文件系统为&#x2F;dev&#x2F;sda3，则此时可以生成一个dm设备为sda3-dm，后续通过mount挂载sda3-dm到&#x2F;sysroot即可实现挂载根文件系统，后续读取根文件系统数据，均会通过sda3-dm设备中转，通过IO定向映射访问&#x2F;dev&#x2F;sda3，并进行hash校验 如下为veritysetup应用层的3个常规步骤： 步骤一. Create dm device 创建 dm 设备主要有如下小步骤： open &#x2F;dev&#x2F;device-mapper 设备节点 传入逻辑分区name、随机生成的uuid参数，调用 DM_DEV_CREATE ioctl 命令 步骤二. Load verity table 这里需要引入一个 verity table 的概念，先简单介绍以下 verity table 所包含的内容： 1）Verity target version(verity target 版本号) 2）Data block device(存储实际待校验数据的块设备) 3）Hash block device(存储校验使用到hash的块设备，一般情况跟data block device是同一个) 4）Data block size(数据块设备的每块存储size) 5）Hash block size（hash块设备的每块存储size） 6）Num data block(数据块设备占用的块数量) 7）Hash start block(hash设备在存储设备的起始位置) 8）Hash algo(hash算法) 9）root digest(对应上面说的 root hash) 10）Salt(用于计算hash的盐值) 这些信息主要是跟最终数据块在校验计算过程中会被使用到的，比如说 hash 设备的起始位置、hash算法、root hash、salt，这些都在实际运行时校验数据块时会用到，这些信息是存储是镜像的固定位置上，这些信息在编译阶段构建镜像的时候就已经计算好的，并存储在镜像的固定位置。 Verity table 初始化代码具体如下： 上层通过从镜像固定位置获取到信息并初始化好 verity table， 通过调用DM_TABLE_LOAD Ioctl 命令将 verity table 传递至kernel。 步骤三. Active dm device 调用DM_DEV_SUSPEND ioctl 指令激活 dm device，对应底层，该 cmd 对应 suspend &amp; resume的实现，如果不设置 DM_SUSPEND_FLAG 标志位，默认走 resume 流程。 应用端在实现上比较简单，主要通过 create -&gt; load verity table -&gt; active dm device 的流程完成了对dm设备的创建、verity table的读取以及传递以及dm设备的激活，为后续实时进行的数据块校验做好了初始化工作。 四、内核层面 有了以上应用层面的流程讲解，那对应内核，自然而然就是对每一步应用端的系统调用做对应的内核实现做讲解。 相应的，内核层面也有以下3个步骤： 步骤一. dev_create 对应应用端的DM_DEV_CREATE ioctl cmd，kernel端的大致实现如下： 这部分比较简单： 1). 检测传入参数的partition name是否合法 2). 开始尝试分配内存初始化 mapped device 结构体以及分配设备minor号（最终用于 dm 设备的设备号，比如 dm-1），使用内核提供的blk_queue_make_request函数注册该mapped device对应的请求队列dm_make_request, 该请求队列最终会在IO重定向中被使用到。并将该mapped device作为磁盘块设备注册到内核中。 3). 将创建好的mapped device插入到一个全局hash表中，该表中保存了内核中当前创建的所有mapped device。 步骤二. dm_ctl_ioctl(DM_TABLE_LOAD_CMD(table_load)) 对应应用端的DM_TABLE_LOAD ioctl cmd，kernel端的大致实现可看下面的思维导图： 总的来说，这个步骤主要是根据入参初始化相应的dm_table、dm_target结构，并且根据参数所指定的target类型，调用相应的target类型的构建函数ctr在内存中构建target device， 在结构上形成 dm_table –&gt; dm_target –&gt; target type –&gt; target device 的链路结构。 步骤三. dm_ctl_ioctl(DM_DEV_SUSPEND_CMD(dev_suspend)) 很显然，这一个步骤主要是建立 mapped device 与 dm_table 的关联。 通过以上几个步骤，在内核中就建立一个可以提供给用户使用的mapped device逻辑块设备 综上涉及到了几个关键的数据结构： mapped device、dm_table、dm_target、target_type、target device(以dm-verity为例) 其实这几个步骤主要是对上述数据结构进行初始化，并且更重要是互相建立了关联关系。他们之间的关联关系如下： 内核经过了这3个步骤，一方面是创建了一个可以提供给应用端使用的 mapped device 逻辑块设备，另一方面是内部建立了 mapped device - target device 的联系， 应用层可以通过对 mapped device 进行策略逻辑操作，最终会通过 mapped device - target device 的联系作用到 对应的target device 上。 五、核心数据流 在上面介绍了dm-verity的设计原理、应用层面以及内核层面的实现之后，读者可能比较关心整个链路的数据流，或者说镜像在校验链路具体流程是如何的，接下来以下主要是围绕着访问镜像文件时的IO流是如何的。 上面说到，应用层在经过 create -&gt; load verity table -&gt; active dm device 的流程完成了dm块设备的初始化工作，之后应用层会对该逻辑块设备进行文件系统挂载，在挂载的过程中，需要访问到实际存储设备(读取文件系统的super block等)，这个过程中就需要透过这个逻辑块设备，最终操作到与其关联的target device。 在这个过程中， 对块设备的IO请求会从逻辑设备mapped device转发相应的target device上，并且会根据对应target_type描述的IO处理规则对IO请求进行处理。以本文讨论的 dm-verity 类型的 target device 来说，对于 mapped device 转发过来的IO，会在 hashtree 里找到该 IO data 对应的 hash 数据，并进行比较，完成校验，返回此次的校验结果并结束本次IO请求。 同时dm-verity通常有两种模式，一般可以通过上述说的veritysetup工具或自研工具指定，两种模式为EIO模式和Loggin模式，EIO模式在校验到数据块的hash不对时直接返回错误，而Loggin模式在校验错误还可以正常使用，Loggin一般为debug使用","tags":["dm-verity"],"categories":["dm-verity"]},{"title":"98、验证二叉搜索树","path":"/posts/98、验证二叉搜索树.html","content":"一、题目描述给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。 有效 二叉搜索树定义如下： 节点的左子树只包含 小于 当前节点的数。节点的右子树只包含 大于 当前节点的数。所有左子树和右子树自身必须也是二叉搜索树。 示例 1： 输入：root &#x3D; [2,1,3]输出：true 示例 2： 输入：root &#x3D; [5,1,4,null,null,3,6]输出：false解释：根节点的值是 5 ，但是右子节点的值是 4 。 提示： 树中节点数目范围在[1, 10^4] 内-2^31 &lt;&#x3D; Node.val &lt;&#x3D; 2^31 - 1 二、C语言代码根据二叉搜索树的性质，二叉搜索树的中序遍历后，结果为有序且从小到大，所以我们遍历二叉树，将结果保存到数组中，然后判断数组是否有序即可。 12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * struct TreeNode *left; * struct TreeNode *right; * &#125;; */bool isValidBST(struct TreeNode* root) &#123; int returnSize = 0; int *res = (int *)malloc(10000 * sizeof(int)); if (res == NULL) &#123; return false; &#125; traverse(root, res, &amp;returnSize); for (int i = 0; i &lt; returnSize - 1; i++) &#123; if (res[i] &gt;= res[i + 1]) &#123; return false; &#125; &#125; return true;&#125;void traverse(struct TreeNode* root, int *res, int *returnSize) &#123; if (root == NULL) &#123; return; &#125; traverse(root-&gt;left, res, returnSize); res[*returnSize] = root-&gt;val; (*returnSize)++; traverse(root-&gt;right, res, returnSize);&#125;","tags":["二叉树"],"categories":["二叉树"]},{"title":"96、不同的二叉搜索树","path":"/posts/96、不同的二叉搜索树.html","content":"一、题目描述给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。 示例 1：输入：n &#x3D; 3输出：5示例 2： 输入：n &#x3D; 1输出：1 提示：1 &lt;&#x3D; n &lt;&#x3D; 19 二、C++代码解法一： 这种题目，我一般是计算出前面多个例子，根据计算出来的多个例子，进行归纳总结，利用数学归纳法，找规律，推算出第n个的结果，然后利用类似如下方法，根据第0个，第1个，第2个……，以此计算出第n个。 n&#x3D;1,搜索二叉树种数：1 ,只有一个节点，所以为1 n&#x3D;2,搜索二叉树种数：2 ,只有二个节点，要么1为根节点，要么2为根节点，所以结果为2 n&#x3D;3,搜索二叉树种数：5 ,有三个节点(1)、1为根节点，另外两个节点，均大于1，根据二叉搜索树的性质，大于根节点的数字，即另外两个节点2和3只能作为右子树，再作为一个整体，构成二叉搜索树，此时另外两个节点构成结果等同于n&#x3D;2时的结果，为2(2)、2为根节点，根据二叉搜索树性质，1只能作为左子树，3只能作为右子树，只有一种情况，所以结果为1(3)、3为根节点，根据二叉搜索树性质，1和2只能作为左子树,1和2作为一个整体再构成二叉搜索树，此时与(1)一样，结果等于n&#x3D;2时的结果为2所以n&#x3D;3时，搜索二叉树种数为2+1+2&#x3D;5 n&#x3D;4,搜索二叉树种数：14(1)、1为根节点，另外三个节点，均大于1，另外节点只能作为右子树，其他节点再作为一个整体，构成二叉搜索树，此时另外三个节点构成结果等同于n&#x3D;3时的结果，为5(2)、2为根节点，根据二叉搜索树性质，1只能作为左子树，3,4只能作为右子树，此时进行排列组合，即为n&#x3D;1和n&#x3D;2的结果相乘，为2(3)、3为根节点，结果等于(2)时的结果为2(3)、4为根节点，结果等于(1)时的结果为5 n&#x3D;5,搜索二叉树种数：42……所以我总结规律为当输入数字为100,结果应该为n=0 * n=99 + n=1 * n=98 + …… + n=99 * n=0, n&#x3D;0时为1 1234567891011121314151617181920212223242526class Solution &#123;public: int numTrees(int n) &#123; int i = 0; int res = 0; if (n == 0) &#123; return 1; &#125; if (n == 1) &#123; return 1; &#125; if (n == 2) &#123; return 2; &#125; if (n == 3) &#123; return 5; &#125; for (i = 0; i &lt; n; ++i) &#123; res += (numTrees(i) * numTrees(n- 1 - i)); &#125; return res; &#125;&#125;; 解法二：解法一比较耗时，所以在解法一基础上进行优化，可以把中间的结果都保存到数组nums中，后续就不需要每次都遍历才拿到结果了。 1234567891011121314151617181920212223class Solution &#123;public: int numTrees(int n) &#123; vector&lt;int&gt; nums(20, 0); nums[0] = 1; traverse(n, nums); return nums[n]; &#125; int traverse(int n, vector&lt;int&gt; &amp;nums) &#123; int res = 0; int i = 0; if (nums[n] != 0) &#123; return nums[n]; &#125; for (i = 0; i &lt; n; ++i) &#123; nums[n] += (traverse(i, nums) * traverse(n- 1 - i, nums)); &#125; return nums[n]; &#125;&#125;; 解法3：动态规划，后续再写具体思路吧： 123456789101112class Solution &#123;public: int numTrees(int n) &#123; // 二叉搜索数的特征，左子树小于根，右子树大于根 vector&lt;int&gt; dp(n+1, 0); dp[0]=1; // dp[0]初始化为1 for(int i=1; i&lt;=n; i++) // 从1...n的二叉搜索数数目 for(int j=1; j&lt;=i; j++) // 逐步选用1...n作为根节点 dp[i]+=dp[j-1]*dp[i-j]; // 左侧j-1个数，右侧i-j个数 return dp[n]; &#125;&#125;;","tags":["二叉树"],"categories":["二叉树"]},{"title":"94、二叉树的中序遍历","path":"/posts/94、二叉树的中序遍历.html","content":"一、题目描述给定一个二叉树的根节点root，返回它的中序遍历 。 示例 1： 输入：root &#x3D; [1,null,2,3]输出：[1,3,2]示例 2： 输入：root &#x3D; []输出：[]示例 3： 输入：root &#x3D; [1]输出：[1] 提示： 树中节点数目在范围 [0, 100] 内-100 &lt;&#x3D; Node.val &lt;&#x3D; 100 进阶: 递归算法很简单，你可以通过迭代算法完成吗？ 二、C语言题解递归算法很简单，只需要按照左右根的顺序递归即可，代码如下：不过需要注意的是，leetcode中尽量最好不要使用全局变量吧，因为leetcode网站的题目，所有的用例是共享全局变量的，也就是第一个用例执行完后，第二个用例会继承第一个用例执行后的全局变量的值，导致后续的用例执行失败 123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * struct TreeNode *left; * struct TreeNode *right; * &#125;; *//** * Note: The returned array must be malloced, assume caller calls free(). */int* inorderTraversal(struct TreeNode* root, int* returnSize) &#123; int* res = (int *)malloc(100 * sizeof(int)); if (res == NULL) &#123; return NULL; &#125; *returnSize = 0; traverse(root, res, returnSize); return res;&#125;void traverse(struct TreeNode* root, int* res, int* returnSize)&#123; if (root == NULL) &#123; return; &#125; traverse(root-&gt;left, res, returnSize); res[*returnSize] = root-&gt;val; (*returnSize)++; traverse(root-&gt;right, res, returnSize);&#125; 迭代方法： 三、C++题解递归方法： 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; traverse(root, res); return res; &#125; void traverse(TreeNode* root, vector&lt;int&gt; &amp;res) &#123; if (root == nullptr) &#123; return; &#125; traverse(root-&gt;left, res); res.push_back(root-&gt;val); traverse(root-&gt;right, res); &#125;&#125;;","tags":["二叉树"],"categories":["二叉树"]},{"title":"二叉树算法核心纲领","path":"/posts/二叉树算法核心纲领.html","content":"一、二叉树基本概念二叉树二叉搜索树完全二叉树 二、二叉树的前中后序遍历二叉树的前中后序对应的不只是三种顺序不同的列表。前中后序是遍历二叉树过程中处理每一个节点的三个特殊时间点，绝不仅仅是三个顺序不同的 List：前序位置的代码在刚刚进入一个二叉树节点的时候执行；后序位置的代码在将要离开一个二叉树节点的时候执行；中序位置的代码在一个二叉树节点左子树都遍历完，即将开始遍历右子树的时候执行。 三、二叉树解题的思维方式1、是否可以通过遍历一遍二叉树得到答案？如果可以，用一个 traverse 函数配合外部变量来实现，这叫「遍历」的思维模式。 2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「分解问题」的思维模式。 无论使用哪种思维模式，你都需要思考： 如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前&#x2F;中&#x2F;后序位置）做？其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作。 四、后序位置的特殊之处五、二叉树的层序遍历六、N叉树","tags":["二叉树"],"categories":["二叉树"]},{"title":"dd命令","path":"/posts/dd命令.html","content":"dd命令可以从一个文件或设备向另一个文件或设备进行复制 一、dd命令常用语法1dd if=input_file of=output_file [options] options是一些可选参数，if和of是必须有的 if 表示输入文件 of 表示输出文件 bs：设置每次读取和写入的块大小（单位为字节或者是可以添加的后缀，如b、k、m等），默认为512字节。 count：设置要复制的块数。 iflag：设置输入选项，常用的选项有direct（绕过缓存直接读取）和sync（同步数据到磁盘）。 oflag：设置输出选项，常用的选项有direct（绕过缓存直接写入）和sync（同步数据到磁盘）。 skip&#x3D;xxx 是在备份时对if 后面的部分也就是原文件跳过多少块再开始备份； seek&#x3D;xxx则是在备份时对of 后面的部分也就是目标文件跳过多少块再开始写 二、dd常用命令-读磁盘1dd if=/dev/sde1 of=tee-test.img bs=1M skip=4 count=16 含义为从&#x2F;dev&#x2F;sde1设备起始位置，跳过4M，读取16M内容到tee-test.img中想要查看tee-test.img，可以使用hexdump命令 1hexdump -C tee-test.img 只查看部分内容，例如前100个字节： 1hexdump -C -n 100 tee-test.img 三、dd常用命令-写磁盘1dd if=/dev/zero of=/dev/sda bs=1k seek=8224 count=32 含义为从&#x2F;dev&#x2F;zero中也就是将后面的of目标文件写0，将&#x2F;dev&#x2F;sda设备的起始地址，跳过8224KB后，连续写入32KB 0数据 四、通过fdisk -l确认分区的实际起始地址使用fdisk -l显示磁盘分区情况 12345678# fdisk -lDisk /dev/sde: 19.16 GB, 20577255424 bytes, 5023744 sectorsSector size (logical/physical): 4096 bytes / 4096 bytes Device Start End/dev/sde1 256 131327 这里显示sde1的起始地址为256，那么实际地址为：256 ✖️ 4096 &#x3D; 1048576 &#x3D; 1024 ✖️ 1024 &#x3D; 1MB，所以sde1的位置为&#x2F;dev&#x2F;sde的起始地址偏移1M，其实起始1M，存放的应该是磁盘分区信息","tags":["Linux工具"],"categories":["Linux工具"]},{"title":"Makefile基础语法","path":"/posts/Makefile基础语法.html","content":"一、Makefile规则一个简单的 Makefile 文件包含一系列的“规则”，其样式如下： 12目标(target)…: 依赖(prerequiries)…&lt;tab&gt;命令(command) 目标(target)通常是要生成的文件的名称，可以是可执行文件或OBJ文件， 也可以是一个执行的动作名称，诸如‘ clean ’。依赖是用来产生目标的材料(比如源文件)，一个目标经常有几个依赖。命令是生成目标时执行的动作，一个规则可以含有几个命令，每个命令占一行。注意：每个命令行前面必须是一个 Tab 字符，即命令行第一个字符是 Tab。这是容易出错的地方。通常，如果一个依赖发生了变化，就需要规则调用命令以更新或创建目标。 但是并非所有的目标都有依赖，例如，目标“ clean ”的作用是清除文件，它有依赖。 一个 Makefile 文件可以包含规则以外的其他文本，但一个简单的 Makefile 文件仅仅需要包含规则。虽然真正的规则比这里展示的例子复杂，但格式是完全一样的 二、make命令介绍make 命令的使用： 执行 make 命令时，它会去当前目录下查找名为“Makefile”的文件，并根 据它的指示去执行操作，生成第一个目标。我们可以使用“ -f ”选项指定文件，不再使用名为“Makefile”的文件，比 如： 1make -f Makefile.build 我们可以使用“ -C ”选项指定目录，切换到其他目录里去，比如： 1make -C a/ -f Makefile.build 我们可以指定目标，不再默认生成第一个目标： 1make -C a/ -f Makefile.build other_target 三、Makefile变量介绍1234A = xxx // 延时变量B ?= xxx // 延时变量，只有第一次定义时赋值才成功；如果曾定义过，此赋值无效C := xxx // 立即变量D += yyy // 如果 D 在前面是延时变量，那么现在它还是延时变量；// 如果 D 在前面是立即变量，那么现在它还是立即变量 四、Makefile通配符&amp;一些符号%通配符 %.o：表示所用的.o文件%. %.c：表示所有的.c文件 $@：表示目标$&lt;：表示第一个依赖文件$^：表示所有依赖文件 五、Makefile假想目标我们的 Makefile 中有这样的目标： 123clean: rm -f $(shell find -name &quot;\\*.o&quot;) rm -f $(TARGET) 如果当前目录下恰好有名为“clean”的文件，那么执行“ make clean ”时它 就不会执行那些删除命令。这时我们需要把“ clean ”这个目标，设置为“假想目标”，这样可以确保执行“ make clean ”时那些删除命令肯定可以得到执行。 使用下面的语句把“clean”设置为假想目标： 1.PHONY : clean 六、Makefile常用函数1.$(foreach var,list,text)简单地说，就是 for each var in list, change it to text。对 list 中的每一个 元素，取出来赋给 var，然后把 var 改为 text 所描述的形式。 2.$(wildcard pattern)pattern 所列出的文件是否存在，把存在的文件都列出来。 3.$(filter pattern…,text)把 text 中符合 pattern 格式的内容，filter(过滤)出来、留下来。 4.$(filter-out pattern…,text)把 text 中符合 pattern 格式的内容，filter-out(过滤)出来、扔掉。 5.$(patsubst pattern,replacement,text)寻找’ text ‘中符合格式’ pattern ‘的字，用’ replacement ‘替换它们。 ‘ pattern ‘和’ replacement ‘中可以使用通配符。 七、Makefile的例子，包含子目录八、Makefile中的EXTRA_CFLAGSEXTRA_CFLAGS是Makefile中预定义的一个变量，作为CFLGAS，在make时可以传递给gcc一些编译选项等，如—O2 EXTRA_CFLAGS +&#x3D; -D等价于gcc -D，相当于在源代码中定义一个宏假如定义一个宏CONFIG_DEBUG在.c里面定义为：#define CONFIG_DEBUG在makefile里定义为: CONFIG_DEBUG&#x3D;y 假如说我们想在makefile里为.c文件进入一个宏定义，就用EXTRA_CFLAGS +&#x3D; DCONFIG_DEBUG( 等价于在.c文件里定义#define CONFIG_DEBUG) 这时CONFIG_DEBUG&#x3D;y与EXTRA_CFLAGS +&#x3D; DCONFIG_DEBUG的区别应该你已经看出来的，前者是对makefile编译时用的，比如说obj-(CONFIG_DEBUG) +&#x3D; test.o,而后者则是对.c源文件里的用的 九、Makefile编译内核驱动ko内核源代码中obj-m表示以模块ko的方式编译obj-y表示将源代码编译到内核源码中在工作的过程中，经常需要编译一些Ko模块，如果是单个的c文件编译直接在内核源码里面 obj-y&#x3D;xxx.o就好如果这个ko文件需要多个c文件共同编译生成的话，最好以如下的模板来完成编译较好 1234567891011121314151617181920212223242526272829303132#首先指定好编译链工具CROSS_COMPILE=/opt/gcc-linaro-7.3.1-2018.05-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-#指定用哪个内核去编译KDIR=/mnt/nfsroot/zhengshuai.zhu/IPCSDK/ipc-sdk-full-release/kernel-4.19#目标是编译成一个test.ko文件obj-m += test.o#test.o文件由当前目录下n个c文件编译成test-objs += ./*.o#包含当前目录下的头文件INCLUDE_DIRS := $(addprefix -I,$(shell find ../ -type d ))#包含当前目录下，内核目录下的头文件ccflags-y:= -I$(_KDIR)/include/linux/ -I$(PWD)/platform/#忽略一些编译警告，类如什么变量未使用ccflags-y += -Wno-declaration-after-statement#添加c文件中的环境变量，比如在代码中会有#ifdef CONFIG_ANDROID #xxxx#endififeq ($(SYSTEM_VERSION),) ccflags-y += -DCONFIG_LINUX_OSelse ccflags-y += -DCONFIG_ANDROIDendifall: make ARCH=$&#123;ARCH&#125; -C $(KDIR) M=$(PWD) modulesclean: make ARCH=$&#123;ARCH&#125; -C $(KDIR) M=$(PWD) clean make ARCH=$&#123;ARCH&#125; -C ( K D I R ) M = (KDIR) M=(KDIR)M=(PWD) modules如何理解这句话?-C的选项可以理解为:进入所指定的位置，$(KDIR)，也就是内核目录中，目的是什么？ 去读取内核目录顶层的Makefile文件，相当于编译的时候 选择一个内核，我要用这个内核去编译。因为你这个目录没有被配置到kernel config里面去，也就是说没有指定用哪个内核版本，有了 -C $(KDIR),就相当于选了内核，如果你选择了kernel-4.19目录下，或者 kernel-5.0目录下， M&#x3D;的选项可以理解为:当我选好内核版本后，我用这个 版本的内核 要去编译哪个目录，然后进入$(PWD)目录去编译当前指定的文件，将其编译成ko文件","tags":["Makefile"],"categories":["Makefile"]},{"title":"git提交流程","path":"//posts/1.html","content":"一、Git下载及配置我们第一次用git或者是新电脑上重新安装git工具的时候，都需要重新配置一下这个工具。 Windows安装git官网网址https://git-scm.com/downloads下载速度慢，且有可能安装不成功。 附快速下载地址（国内下载站）：https://github.com/waylau/git-for-win 。 下载完之后，Windows中你在桌面上或者文件管理器中鼠标右键就可以看见Git Bash here，就是用来打开git bash的。 Linux安装gitlinux在终端中，输入sudo apt-get install git 下载完可以用命令git --version打印当前的git版本验证是否成功。下面正式开始Git的配置。 配置git基本信息接下来就是不管我们是第一次使用git工具，还是后来换电脑了，还是换成linux系统了，要想使用git都按照下面的方法配置一遍，才可以使用。 安装成功之后，在命令行中敲下如下命令 git config --list,显示当前的配置信息。 接下来设置提交仓库时的用户名信息 git config --global user.name &quot;张三&quot; 设置提交仓库是的邮箱信息 git config --global user.email &quot;xxxxxxxx@qq.com&quot; git设置关闭自动换行git config --global core.autocrlf false 为了保证文件的换行符是以安全的方法，避免windows与unix的换行符混用的情况，最好也加上这么一句 git config --global core.safecrlf true 其实这些信息都在一个配置文件中，就在当前用户的主目录下边的**.gitconfig**文件中，也可以直接打开这个文件cd ~,vim .gitconfig进行编辑。 git协议及秘钥配置git有四种协议：Git协议，http协议，本地协议，ssh协议。使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https。大部分都是用ssh协议。这个不仅速度快，而且不用每次提交输入密码，可谓是省心省力。 下面就说一下ssh配置过程。(这个协议配置的过程不可缺少，不然就用不了这种协议。) 首先生成 RSA 密钥对 : ssh-keygen -t rsa -C &quot;xxxxxxxx@qq.com&quot;注意格式，一定要正确。 ssh和-keygen无空格 此时在用户主目录下就会有一个.ssh隐藏文件，进入该目录有一个id_rsa.pub文件，cat命令查看这个文件，复制下来然后在 github网站添加公钥 ，方法如下 在 Github 网站添加公钥：在右上角头像处点settings进入设置，然后点SSH and GPG keys,进入之后点击New SSH key 粘贴进去，随便给这个秘钥命个名，方便管理就行了。钥匙显示黑色即可。 此时配置就完成了。接下来就可以使用git了。 执行此命令验证是否成功ssh -T git@github.com 成功显示为：Hi XXX! You’ve successfully authenticated, but GitHub does not provide shell access. 二、先有本地库，后有远程库创建版本库可以理解为版本库就是本地文件的一个目录，也叫仓库。可以用git来管理和回退等 创建版本库：找到一个想被管理的文件夹，进入到文件夹里，输入命令git init,此时git就可以管理这个目录了，并且在文件夹下多出来了一个.git的隐藏文件夹。这个.git就是版本库。 Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。 工作区：就是你在电脑里能看到的目录，比如刚才的文件夹就是一个工作区 第一步：将文件添加到暂存区当我们想添加文件或者修改文件是需要添加到版本库中的，否则无法被git跟踪管理呀，所以当我们添加或者修改文件时，先要用git add filename添加到暂存区中，filename为.的时候代表当前目录下所有文件都添加到暂存区 第二步：将文件提交到分支git commit -m &quot;message&quot;，将文件提交到了分支。 添加远程库我们已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。 首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库，在Repository name填入项目名字，比如我们叫learngit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库 目前，在GitHub上的这个learngit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。 现在，我们根据GitHub的提示，在本地的learngit仓库下运行命令： git remote add origin git@github.com:mengchao666/learngit.git 请千万注意，把上面的mengchao666替换成你自己的GitHub账户名，否则，你在本地关联的就是我的远程库，你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。 添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。下一步，就可以把本地库的所有内容推送到远程库上： git push -u origin master把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样,从现在起，只要本地作了提交，就可以通过命令： git push origin master 三、先有远程库，后有本地库现在，远程库已经准备好了，下一步是用命令git clone克隆一个本地库： git clone git@github.com:mengchao666/learngit.git 可以使用git clone -b branch克隆指定的分支后续修改可以使用如下命令提交 123git add .git commit -m &quot;message&quot;git push 四、企业开发流程在公司中做项目，一般项目代码都在公共仓库中，我们将其称为远程仓，一般按照如下步骤开发1、将远程仓fork一份到个人仓2、git clone个人仓代码到本地3、使用git remote -v命令查看，此时本地关联的origin为个人仓4、将本地代码关联到公司的远程仓，方便拉取最新代码，命令如下： 1git remote add upstream 公共仓地址 此时再次使用git remote -v可以看到已经关联了upstream为远程仓5、在开发需求和问题单修改之前，一般使用git pull upstream命令将远程仓代码更新至本地6、修改代码后提交 123git add .git commit -m &quot;message&quot;git push origin branch 7、在github&#x2F;gitlab页面创建MR申请，一般此时就可以了，找人加分就合入了8、但是如果在创建MR申请时，提示冲突，此时需要解决冲突，解决如下： 1git pull upstream 此时会提示哪些文件有冲突，使用ctrl + F搜索&gt;&gt;&gt;,有此标志的即为冲突的地方，保留自己想要的代码，重新提交add commit push即可。 企业开发流程中，通常有远程仓新建了一个分支，个人远程仓没有此分支，需要更新，可按照如下步骤更新个人仓代码分支 123git checkout -b 新分支名称 upstream/新分支名称git pull upstream 新分支名称git push origin 新分支名称 五、代码回退等操作工作区的恢复(此时还没有add，代码回退)使用checkout恢复工作区 git checkout . （全部修改），git checkout --file改回一个文件,工作区—&gt;还没add add的撤销git reset就是回退到指定的commitID,,使用git commit –amend时追加，不会生成新的commitID,是在原来的commitID基础上进行修改的。 HEAD指向当前最新的commitID，所以仅仅add,没有commit，此时的最新的commitID还是之前的 12git reset --hard HEAD // 不保留本地修改，回退git reset --mixed HEAD //保留本地修改，可以重新git add 简单理解git reset –xxx HEAD命令，就是将代码回退到了最新的一次commitID的代码状态，hard不保留本地代码工作空间的修改，而mixed保留 commit后的撤销123git reset --hard HEAD^ // 不保留本地修改，回退到上一次的commitID状态git reset --mixed HEAD^ // 保留本地修改，撤销git commit,并且撤销git addgit reset --soft HEAD^ //保留本地修改，撤销commit,不撤销add 六、git的一些其他操作查看分支：git branch 创建分支：git branch &lt;name&gt; 切换分支：git checkout &lt;name&gt;或者git switch &lt;name&gt; 创建+切换分支：git checkout -b &lt;name&gt;或者git switch -c &lt;name&gt; 合并某分支到当前分支：git merge &lt;name&gt; 删除分支：git branch -d &lt;name&gt; 当代码仓有子仓情形下的一些命令：git submodule update --init --remotegit submodule foreach git checkout branchgit submodule foreach --recursive 七、同时提交两个MR当我们同时修改多个问题单，或者同时处理需求时，可能需要同时提交多分不同代码，此时处理方法如下： 1、本地创建一个新的分支来处理第一个MR 1git checkout -b mr1-branch 2、提交第一个MR。修改代码，git add、git commit，git push 1git push -u origin mr1-branch 3、切换回原来的分支，以main分支为例 1git checkout main 4、创建第二个分支处理第二个MR 1git checkout -b mr2-branch 5、提交第二个MR。修改代码，git add、git commit，git push 1git push -u origin mr2-branch","tags":["git"],"categories":["git"]},{"title":"addr2line","path":"/posts/addr2line.html","content":"addr2line是一个将地址转换为文件名和行号的工具。给定可执行文件(如exe&#x2F;a.out等)中的地址或可重定位对象(如so,ko等)部分中的偏移量，它会使用调试信息来确定与之相关的文件名和行数。 用户态coredump，一般使用gdb调试接口，gdb一般封装了addr2line，可以解析文件名和行号。如果环境配置了不生成coredump，可以使用addr2line调试。所以addr2line一般解析内核Call trace使用较多。 一、使用方法12基本用法：addr2line [选项] [地址] 常用选项如下： 选项 描述 -e 设置输入文件名称，默认为a.out -i 解析内联函数 -f 显示函数名 -C 解析函数名 -p 以好读的方式显示 需要注意的是使用addr2line的时候，可执行文件或重定位文件一定是要带调试信息的 二、用户态普通程序崩溃使用方法 1addr2line -e 进程名 IP指令地址 -f 用户态程序崩溃，当没有coredump产生时，可以使用如下方法假设我们的程序名称为segfault,当程序崩溃是，dmesg日志中会有报错信息: 123[root@localhost ~]# dmesg[134563.793925] segfault[53791]: segfault at 0 ip 0000000000400546 sp 00007fff7956af70 error 6 in segfault[400000+1000][134563.793946] Code: 01 5d c3 90 c3 66 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 f3 0f 1e fa eb 8a 55 48 89 e5 48 c7 45 f8 00 00 00 00 48 8b 45 f8 &lt;c7&gt; 00 00 00 00 00 b8 00 00 00 00 5d c3 66 2e 0f 1f 84 00 00 00 00 此时我们注意到IP指令地址为0000000000400546使用addr2line查看程序挂的位置： 1addr2line -e segfault 0x0000000000400546 -f 三、动态链接库程序崩溃使用方法 1addr2line -e 动态链接库名称 IP指令地址-基地址 -f 假设我们有一个程序名为test，链接了一个libfoo.so，程序运行时崩溃，dmesg查看日志如下： 123[root@localhost ~]# dmesg[70567.416655] test[27722]: segfault at 0 ip 00007ffa1f588580 sp 00007fffa964e698 error 6 in libfoo.so[7ffa1f588000+1000][70567.427374] Code: ff e8 64 ff ff ff c6 05 bd 0a 20 00 01 5d c3 0f 1f 00 c3 0f 1f 80 00 00 00 00 f3 0f 1e fa e9 77 ff ff ff 0f 1f 80 00 00 00 00 &lt;c7&gt; 04 25 00 00 00 00 00 00 00 00 0f 0b 00 00 00 f3 0f 1e fa 48 83 根据日志可知，段错误发生的位置是在test进程调用的libfoo.so库里，我们先使用ldd找到动态库的位置，如下： 12345[root@localhost 69]# ldd test linux-vdso.so.1 (0x00007ffd15b24000) libfoo.so =&gt; ./libfoo.so (0x00007f8c01879000) libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f8c014b4000) /lib64/ld-linux-x86-64.so.2 (0x00007f8c01a7b000) 00007ffa1f588580为程序崩溃点IP指令地址，使用dmesg消息中ip指令地址减去动态库基址值(00007ffa1f588580 -7ffa1f588000&#x3D;580), 差值0x580为错误点在动态库的地址，调用addr2line, 注意-e参数后文件名改为动态库名: 1addr2line -e libfoo.so 580 -f -p 四、内核驱动程序运行崩溃使用方法： 1addr2line -e xxx.ko 地址偏移量 -f 本人所用主机即属于一旦发生Oops，就会触发panic，因此总是无法查看Oops时的dmesg日志，经查阅资料，发现是内核参数panic_on_oops的原因导致的，因为该参数被设置为1，所以Oops会触发panic，从而导致机器总是死机重启，无法查看Oops时的dmesg日志。下面提供两种方法修改Oops内核参数，使其不会在Oops的时候触发panic导致死机重启。 方法一：修改 &#x2F;proc下内核参数文件内容，临时生效，重启后失效。 1echo 0 &gt; /proc/sys/kernel/panic_on_oops 方法二：修改&#x2F;etc&#x2F;sysctl.conf 文件的内核参数来永久更改。 1234567891011121314151617181920[root@localhost ~]# vi /etc/sysctl.conf[root@localhost ~]# cat /etc/sysctl.conf# sysctl settings are defined through files in# /usr/lib/sysctl.d/, /run/sysctl.d/, and /etc/sysctl.d/.## Vendors settings live in /usr/lib/sysctl.d/.# To override a whole file, create a new file with the same in# /etc/sysctl.d/ and put new settings there. To override# only specific settings, add a file with a lexically later# name in /etc/sysctl.d/ and put new settings there.## For more information, see sysctl.conf(5) and sysctl.d(5).kernel.panic_on_oops=0[root@localhost ~]# cat /proc/sys/kernel/panic_on_oops1 [root@localhost ~]# sysctl -pkernel.panic_on_oops = 0[root@localhost ~]#[root@localhost ~]# cat /proc/sys/kernel/panic_on_oops0 假设内核某ko运行后发生如下错误： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051[root@localhost ~]# dmesg[ 1039.918606] my_oops_init[ 1039.918616] BUG: unable to handle kernel NULL pointer dereference at 0000000000000000[ 1039.926442] PGD 0 P4D 0[ 1039.928979] Oops: 0002 [#1] SMP NOPTI[ 1039.932637] CPU: 34 PID: 3843 Comm: insmod Kdump: loaded Tainted: G OE --------- - - 4.18.0-394.el8.x86_64 #1[ 1039.943756] Hardware name: New H3C Technologies Co., Ltd. H3C UniServer R4950 G5/RS45M2C9SB, BIOS 5.37 09/30/2021[ 1039.954000] RIP: 0010:do_oops+0x5/0x11 [oops][ 1039.958364] Code: Unable to access opcode bytes at RIP 0xffffffffc02e6fdb.[ 1039.965231] RSP: 0018:ffffb9d40a8c7cb0 EFLAGS: 00010246[ 1039.970449] RAX: 000000000000000c RBX: 0000000000000000 RCX: 0000000000000000[ 1039.977573] RDX: 0000000000000000 RSI: ffff98942ee96758 RDI: ffff98942ee96758[ 1039.984697] RBP: ffffffffc02e7011 R08: 0000000000000000 R09: c0000000ffff7fff[ 1039.991822] R10: 0000000000000001 R11: ffffb9d40a8c7ad8 R12: ffffffffc02e9000[ 1039.998944] R13: ffffffffc02e9018 R14: ffffffffc02e91d0 R15: 0000000000000000[ 1040.006069] FS: 00007f1b8d93b740(0000) GS:ffff98942ee80000(0000) knlGS:0000000000000000[ 1040.014145] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033[ 1040.019884] CR2: ffffffffc02e6fdb CR3: 0000000145c02000 CR4: 0000000000350ee0[ 1040.027008] Call Trace:[ 1040.029454] my_oops_init+0x16/0x19 [oops][ 1040.033550] do_one_initcall+0x46/0x1d0[ 1040.037390] ? do_init_module+0x22/0x220[ 1040.041318] ? kmem_cache_alloc_trace+0x142/0x280[ 1040.046023] do_init_module+0x5a/0x220[ 1040.049777] load_module+0x14ba/0x17f0[ 1040.053530] ? __do_sys_finit_module+0xb1/0x110[ 1040.058059] __do_sys_finit_module+0xb1/0x110[ 1040.062411] do_syscall_64+0x5b/0x1a0[ 1040.066077] entry_SYSCALL_64_after_hwframe+0x65/0xca[ 1040.071130] RIP: 0033:0x7f1b8c8509bd[ 1040.074701] Code: ff c3 66 2e 0f 1f 84 00 00 00 00 00 90 f3 0f 1e fa 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 &lt;48&gt; 3d 01 f0 ff ff 73 01 c3 48 8b 0d 9b 54 38 00 f7 d8 64 89 01 48[ 1040.093446] RSP: 002b:00007ffc4df0a968 EFLAGS: 00000246 ORIG_RAX: 0000000000000139[ 1040.101004] RAX: ffffffffffffffda RBX: 00005653fb1997d0 RCX: 00007f1b8c8509bd[ 1040.108126] RDX: 0000000000000000 RSI: 00005653f980c8b6 RDI: 0000000000000003[ 1040.115251] RBP: 00005653f980c8b6 R08: 0000000000000000 R09: 00007f1b8cbd9760[ 1040.122375] R10: 0000000000000003 R11: 0000000000000246 R12: 0000000000000000[ 1040.129498] R13: 00005653fb1997b0 R14: 0000000000000000 R15: 0000000000000000[ 1040.136623] Modules linked in: oops(OE+) binfmt_misc xt_CHECKSUM ipt_MASQUERADE xt_conntrack ipt_REJECT nf_reject_ipv4 nft_compat nft_counter nft_chain_nat nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 nf_tables nfnetlink rpcsec_gss_krb5 auth_rpcgss nfsv4 dns_resolver nfs lockd grace fscache bridge stp llc intel_rapl_msr intel_rapl_common amd64_edac_mod edac_mce_amd amd_energy kvm_amd kvm irqbypass ipmi_ssif pcspkr crct10dif_pclmul crc32_pclmul ghash_clmulni_intel rapl joydev ccp sp5100_tco i2c_piix4 k10temp ptdma acpi_ipmi ipmi_si sunrpc vfat fat xfs libcrc32c sd_mod t10_pi sg crc32c_intel ast drm_vram_helper drm_kms_helper syscopyarea sysfillrect sysimgblt fb_sys_fops drm_ttm_helper ttm ahci drm libahci nfp(OE) igb libata dca i2c_algo_bit dm_mirror dm_region_hash dm_log dm_mod ipmi_devintf ipmi_msghandler[ 1040.208357] CR2: 0000000000000000[ 1040.211668] ---[ end trace b69c1e8998070273 ]---[ 1040.230185] RIP: 0010:do_oops+0x5/0x11 [oops][ 1040.234540] Code: Unable to access opcode bytes at RIP 0xffffffffc02e6fdb.[ 1040.241409] RSP: 0018:ffffb9d40a8c7cb0 EFLAGS: 00010246[ 1040.246626] RAX: 000000000000000c RBX: 0000000000000000 RCX: 0000000000000000[ 1040.253750] RDX: 0000000000000000 RSI: ffff98942ee96758 RDI: ffff98942ee96758[ 1040.260876] RBP: ffffffffc02e7011 R08: 0000000000000000 R09: c0000000ffff7fff[ 1040.267998] R10: 0000000000000001 R11: ffffb9d40a8c7ad8 R12: ffffffffc02e9000[ 1040.275124] R13: ffffffffc02e9018 R14: ffffffffc02e91d0 R15: 0000000000000000[ 1040.282247] FS: 00007f1b8d93b740(0000) GS:ffff98942ee80000(0000) knlGS:0000000000000000[ 1040.290323] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033[ 1040.296061] CR2: ffffffffc02e6fdb CR3: 0000000145c02000 CR4: 0000000000350ee0 Oops: 0002 – 错误码Oops: [#1] – Oops发生的次数CPU: 34 – 表示Oops是发生在CPU34上关键信息如下，这里提示在操作函数do_oops的时候出现异常，地址偏移量0x5： 1[ 1039.954000] RIP: 0010:do_oops+0x5/0x11 [oops] 为什么这条信息关键? 因为其含有指令指针RIP；指令指针IP&#x2F;EIP&#x2F;RIP的基本功能是指向要执行的下一条地址。在8080 8位微处理器上的寄存器名称是PC（program counter，程序计数器），从8086起，被称为IP（instruction pointer，指令指针）。主要区别在与PC指向正在执行的指令，而IP指向下一条指令。在64位模式下，指令指针是RIP寄存器。这个寄存器保存着下一条要执行的指令的64位地址偏移量。64位模式支持一种新的寻址模式，被称为RIP相对寻址。使用这个模式，有效地址的计算方式变为RIP（指向下一条指令）加上位移量。 由此可以看出内核执行到do_oops+0x5&#x2F;0x11这个地址的时候出现异常，我们只需要找到这个地址对应的代码即可。 do_oops指示了是在do_oops函数中出现的异常， 0x5表示出错的地址偏移量， 0x11表示do_oops函数的大小。 123打印格式：do_oops+0x5/0x11 [oops] 即：symbol+offset/size [module] symbol: 符号 offset：地址偏移量 size：函数的长度 module: 所属内核模块 使用如下命令解析 1addr2line -e oops.ko 0x5 -f -p","tags":["Linux工具"],"categories":["Linux工具"]},{"title":"个人博客网站部署&文章提交","path":"/posts/网站部署-写作.html","content":"一、网站部署1、首先在github上创建自己的一个仓库，仓库名字为mengchao666.github.io 2、将https://github.com/mengchao666/blog-demo代码下载到本地，用VScode打开 3、安装node.js，pnpm，hexo 123node.js官网安装：https://nodejs.cn/download/pnpm安装：npm install pnpm -ghexo安装：npm install hexo-cli -g 4、在Vscode打开的项目终端下执行如下命令： 12pnpm ipnpm dev 5、使用hexo deploy命令部署，打开mengchao666.github.io即可 6、新增文章使用如下命令新增 例如：hexo new post “网站部署” 1hexo new post &lt;title&gt; 7、新增文章后，使用命令部署提交到github 12hexo cleanhexo deploy 更多操作可以参考：https://xaoxuu.com/wiki/stellar/topic.html","tags":["网站"],"categories":["网站"]},{"title":"工具库","path":"/explore/sites/工具库.html","content":"工具库 VIP电影在线观看https://vip1280.net/文件格式转换https://convertio.co/zh/"},{"title":"友链","path":"/about/index.html","content":"我的小伙伴们 github 如何交换友链？ 您的网站应满足以下全部条件： 安全合规：合法的、非营利性、无木马植入的 HTTPS 站点。 非空壳网站：网站内发布至少 五篇 原创文章，内容题材不限。 我们需要有一定的有效互动： 先友后链：与 我 有至少 半年 的有效互动"},{"title":"牛客零基础入门前端","path":"/wiki/niuke/牛客零基础入门前端.html","content":"01 HTMLFED1 表单类型描述请依次写出以下类型的输入框。 类型为密码，默认值为 “nowcoder” 类型为复选框，且状态为已勾选 我的解答1234&lt;form&gt; &lt;input type=&quot;password&quot; value=&quot;nowcoder&quot; /&gt; &lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot; /&gt;&lt;/form&gt; 注意点： 类型为复选框，input 属性的 checked &#x3D; “checked” FED2 表格结构描述请写出具有表格标题为 “nowcoder” 的 2 行 3 列表格结构。 我的解答1234567891011121314151617&lt;table&gt; &lt;caption&gt; nowcoder &lt;/caption&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; mdn 示例 Council budget (in £) 2018 Items Expenditure Donuts 3,000 Stationery 18,000 Totals 21,000 FED3 图像标签属性描述请写出具有标题属性和代替文本属性的图片标签。 我的解答1&lt;img src=&quot;&quot; alt=&quot;&quot; title=&quot;&quot; /&gt; FED4 新窗口打开文档描述请写出可以在新窗口打开文档的 a 标签。 我的解答1&lt;a href=&quot;&quot; target=&quot;_blank&quot;&gt;&lt;/a&gt; 注意点target 规定在何处打开目标 URL。仅在 href 属性存在时使用 _blank：新窗口打开。 _parent：在父窗口中打开链接。 _self：默认，当前页面跳转。 _top：在当前窗体打开链接，并替换当前的整个窗体(框架页)。 FED5 自定义列表描述请写出列表项为 “nowcoder” 且列表项内容也为 “nowcoder” 的自定义列表。 我的解答1234&lt;dl&gt; &lt;dt&gt;nowcoder&lt;/dt&gt; &lt;dd&gt;nowcoder&lt;/dd&gt;&lt;/dl&gt; 注意点 html5 前用得多，普通列表标签，既不是 ul，也不是 ol FED6 语义化标签描述请使用语义化标签创建头部标签且包含导航标签。注意：只需在 html 模块填写标签结构，有且仅有一个头部标签和一个导航标签。 我的解答123&lt;header&gt; &lt;nav&gt;&lt;/nav&gt;&lt;/header&gt; 注意点 就普通嵌套，看报错才知道标签名 FED7 音频媒体标签属性描述请写出具有控件功能的音频媒体标签。 我的解答1&lt;audio src=&quot;&quot; controls&gt;&lt;/audio&gt; 注意点 controls：如果声明了该属性，浏览器将提供一个包含声音，播放进度，播放暂停的控制面板，让用户可以控制音频的播放。 FED8 视频媒体标签属性描述请写出具有当视频的媒体数据加载期间发生错误时执行某个方法事件的视频媒体标签。 我的解答1&lt;video src=&quot;&quot; onerror=&quot;fn()&quot; controls&gt;&lt;/video&gt;&lt;audio src=&quot;&quot; controls&gt;&lt;/audio&gt; 注意点 controls：如果存在该属性，浏览器会在视频底部提供一个控制面板，允许用户控制视频的播放，包括音量、拖动进度、暂停或恢复播放。 02 CSSFED9 CSS 选择器——标签、类、ID 选择器描述请将 html 模块中字体内容是 “红色” 的字体颜色设置为 “rgb(255, 0, 0)”，”绿色” 设置为 “rgb(0, 128, 0)”，”黑色” 设置为 “rgb(0, 0, 0)”，且字体大小都为 20px。 我的解答1234567891011121314&lt;style&gt; .green &#123; color: rgb(0, 128, 0); font-size: 20px; &#125; #black &#123; color: rgb(0, 0, 0); font-size: 20px; &#125;&lt;/style&gt;&lt;div style=&quot;color:rgb(255, 0, 0);font-size:20px&quot;&gt;红色&lt;/div&gt;&lt;div class=&quot;green&quot;&gt;绿色&lt;/div&gt;&lt;div id=&quot;black&quot;&gt;黑色&lt;/div&gt; 注意点 类选择器：. id 选择器：# FED10 CSS 选择器——伪类选择器描述请将 html 模块中 ul 列表的第 2 个 li 标签和第 4 个 li 标签的背景颜色设置成 “rgb(255, 0, 0)”。 我的解答1234567891011&lt;style&gt; li:nth-child(2n) &#123; background-color: rgb(255, 0, 0); &#125;&lt;/style&gt;&lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt;&lt;/ul&gt; 注意点 伪类选择器 nth-child(2n)：偶数个 nth-child(2n-1)：奇数个 FED11 CSS 选择器——伪元素描述请给 html 模块的 div 元素加一个后伪元素，且后伪元素的宽度和高度都是 20px，背景颜色为 “rgb(255, 0, 0)”。 我的解答12345678910&lt;style&gt; div::after &#123; content: &quot;&quot;; height: 20px; width: 20px; background-color: rgb(255, 0, 0); display: inline-block; &#125;&lt;/style&gt;&lt;div&gt;&lt;/div&gt; 注意点 ::after 会创建一个 伪元素，作为所选元素的最后一个子元素 包含 content，可以表示文字，图片等 display: inline-block; 要设置为块级元素才能给其设置宽高 FED12 按要求写一个圆描述请将 html 模块的 div 元素设置为一个半径是 50px 的圆，且边框为 1px 的黑色实线。要求： 圆角属性仅设置一个值 圆角属性单位请使用 px 注意：由于圆角属性设置广泛且都可以实现题目效果，所以请按照要求规范书写。 我的解答123456789&lt;style&gt; div &#123; width: 100px; height: 100px; border-radius: 50px; border: 1px solid black; &#125;&lt;/style&gt;&lt;div&gt;&lt;/div&gt; 注意点 border-radius 设置为 50%就是一个圆 FED13 设置盒子宽高描述请将 html 模块类为 “box” 的 div 元素宽度和高度都设置为 100px，且内间距为 20px、外间距为 10px。 我的解答123456789&lt;style&gt; .box &#123; width: 100px; height: 100px; padding: 20px; margin: 10px; &#125;&lt;/style&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt; 注意点 padding 内边距，margin 外边距 FED14 浮动和清除浮动描述请将类为 “left” 的 div 元素和类为 “right” 的 div 元素在同一行上向左浮动，且清除类为 “wrap” 的父级 div 元素内部的浮动。 我的解答123456789101112131415161718192021222324&lt;style&gt; .wrap::after &#123; content: &quot;&quot;; display: block; clear: both; &#125; .left &#123; width: 100px; height: 100px; background-color: red; float: left; &#125; .right &#123; width: 100px; height: 100px; background-color: yellow; float: left; &#125;&lt;/style&gt;&lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;&lt;/div&gt; 注意点 float 属性左右占位，上下不占位，所以下面的元素会浮动上来，所以可以在父类盒子加一个:: after 伪类元素，设置 clear:both 闭合父盒子的边界以达到清除浮动的目的。 css - 清除浮动（clearfix）的常见方法 - front-end development - SegmentFault 思否 FED15 段落标识描述请将下面这句话以段落的形式展示在浏览器中——“牛客网是一个专注于程序员的学习和成长的专业平台。” 我的解答1&lt;p&gt;牛客网是一个专注于程序员的学习和成长的专业平台。&lt;/p&gt; 注意点 考察 p 标签的使用方法 FED16 圣诞树描述圣诞节来啦！请用 CSS 给你的朋友们制作一颗圣诞树吧~这颗圣诞树描述起来是这样的： “topbranch”是圣诞树的上枝叶，该上枝叶仅通过边框属性、左浮动、左外边距即可实现。边框的属性依次是：宽度为 100px、是直线、颜色为 green（未显示的边框颜色都为透明） “middleBranch”是圣诞树的中枝叶，该上枝叶仅通过边框属性即可实现。边框的属性依次是：宽度为 200px、是直线、颜色为 green（未显示的边框颜色都为透明） “base”是圣诞树的树干，该树干仅通过左外边距实现居中于中枝叶。树干的宽度、高度分别为 70px、200px，颜色为 gray。 注意： 上枝叶、树干的居中都是通过左外边距实现的 没有显示的边框，其属性都是透明（属性） 仅通过 border 属性完成边框的所有属性设置 我的解答12345678910111213141516171819202122232425262728293031323334&lt;style&gt; .topbranch &#123; width: 0px; height: 0px; border-width: 100px; border-color: green; border-left-color: transparent; border-right-color: transparent; border-top-color: transparent; border-style: solid; float: left; margin-left: 100px; &#125; .middleBranch &#123; width: 0px; height: 0px; border-width: 200px; border-color: green; border-left-color: transparent; border-right-color: transparent; border-top-color: transparent; border-style: solid; &#125; .base &#123; width: 70px; height: 200px; background-color: grey; margin-left: 165px; &#125;&lt;/style&gt;&lt;section class=&quot;topbranch&quot;&gt;&lt;/section&gt;&lt;section class=&quot;middleBranch&quot;&gt;&lt;/section&gt;&lt;section class=&quot;base&quot;&gt;&lt;/section&gt; 注意点 1234border-color: green;border-left-color: transparent;border-right-color: transparent;border-top-color: transparent; 这样做会显示出三角形，把其他边颜色设置为 transparent 透明 FED17 固定定位描述请将 html 模块类为”box”的 div 元素固定在视口的左上角。 我的解答12345678&lt;style&gt; .box &#123; position: fixed; top: 0; left: 0; &#125;&lt;/style&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt; 注意点 position: fixed;可以让元素在浏览器某一个位置固定，不随滚动条而移动 FED18 CSS 单位（一）描述请将 html 模块中类为”box”的 div 元素的宽度和高度设置为自身字体大小的 4 倍。 我的解答1234567&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;style&gt; .box &#123; width: 4em; height: 4em; &#125;&lt;/style&gt; 注意点 em 指的相对父级的字体大小 FED19 CSS 单位（二）描述请将 html 模块 div 元素的宽度和高度设置为 html 根元素字体大小的 4 倍。注意：只需在 css 模块补全样式内容，请勿修改 html 模块。 我的解答1234567&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;style&gt; .box &#123; width: 4rem; height: 4rem; &#125;&lt;/style&gt; 注意点 rem 指的相对根级的字体大小(:root&#x2F;html) 03 JAVASCRIPTFED20 基本数据类型检测描述请补全 JavaScript 函数，要求以字符串的形式返回参数的类型。注意：只需检测基本数据类型。 我的解答12345&lt;script&gt; function _typeof(value) &#123; return typeof value; &#125;&lt;/script&gt; 注意点 typeof 可以返回数据类型 FED21 检测复杂数据类型描述请补全 JavaScript 函数，要求以 Boolean 的形式返回第一个参数是否属于第二个参数对象的实例。 我的解答12345&lt;script&gt; function _instanceof(left, right) &#123; return left instanceof right; &#125;&lt;/script&gt; 注意点 instanceof 可以检验参数是否为某个对象的实例 FED22 数据类型转换描述请补全 JavaScript 函数，要求以字符串的形式返回两个数字参数的拼接结果。示例： _splice(223,233) -&gt; “223233” _splice(-223,-233) -&gt; “-223-233” 我的解答123456&lt;script type=&quot;text/javascript&quot;&gt; // 填写JavaScript function _splice(left, right) &#123; return left.toString() + right.toString(); &#125;&lt;/script&gt; 注意点 使用toString把数字类型转为字符串类型，再相加 FED23 阶乘描述请补全 JavaScript 函数，要求返回数字参数的阶乘。注意：参数为大于等于 0 的整数。 我的解答1234567&lt;script type=&quot;text/javascript&quot;&gt; function _factorial(number) &#123; if (number &lt; 0) return; if (number == 1 || number == 0) return 1; return number * _factorial(number - 1); &#125;&lt;/script&gt; 注意点 使用递归完成阶乘更加简洁"},{"title":"探索者笔记","path":"/explore/notes/探索者笔记.html","content":"memos 说说 本页面数据来源于：memos"},{"path":"/static/js/snow.js","content":"const message = { toast: (msg, duration) => { const d = Number(isNaN(duration) ? 2000 : duration); var el = document.createElement('div'); el.classList.add('toast'); el.classList.add('show'); el.innerHTML = msg; document.body.appendChild(el); setTimeout(function () { document.body.removeChild(el) }, d); }, } const Config = { snow: ['❄️', '☃️', '❄', '※', '❅', '❆', '❈', '❉', '❊', '❋'], color: '#d9e2e7', speed: 10, dom: document.getElementsByTagName('body')[0], interval: 800, active: false }; // 从 localStorage 获取雪花模式状态 const storedSnowActive = localStorage.getItem('snowActive'); Config.active = storedSnowActive === 'true'; // 确保 DOM 元素存在 if (!Config.dom) { throw Error('请获取存在的DOM'); } const $canvas = document.createElement('div'); function useStyle(dom, style) { for (let sKey in style) { dom.style[sKey] = style[sKey]; } } useStyle($canvas, { width: '100%', height: '100%', position: 'fixed', top: 0, left: 0, pointerEvents: 'none', zIndex: 100 }); const matchDarkMode = window.matchMedia('(prefers-color-scheme: dark)'); function handleColorSchemeChange(e) { Config.color = e.matches ? 'rgb(255, 255, 255)' : 'rgb(149, 141, 186)'; } matchDarkMode.addEventListener('change', handleColorSchemeChange); handleColorSchemeChange(matchDarkMode); let snowInterval; function startSnowInterval() { return setInterval(() => { const $snow = document.createElement('div'); $snow.innerText = Config.snow[Math.floor(Math.random() * Config.snow.length)]; useStyle($snow, { display: 'inline-block', color: Config.color, fontSize: Math.floor(Math.random() * (25 - 14 + 1) + 14) + 'px', position: 'absolute', top: 0, left: Math.floor(Math.random() * 100) + '%', transition: 'transform ' + Config.speed + 's linear,opacity ' + Config.speed + 's linear', transform: 'translateY(-100%)', opacity: Math.random() + 0.3 }); setTimeout(() => { useStyle($snow, { transform: 'translate(0, ' + window.innerHeight + 'px) rotate(480deg)', opacity: 0 }); $snow.addEventListener('transitionend', () => { $snow.remove(); }); }, 100); $canvas.appendChild($snow); }, Config.interval); } function toggleSnow() { if (Config.active) { clearInterval(snowInterval); $canvas.innerHTML = ''; Config.active = false; message.toast(\"切换到晴天模式\"); } else { snowInterval = startSnowInterval() Config.active = true; message.toast(\"切换到下雪模式\"); } localStorage.setItem('snowActive', Config.active); } // 在页面加载时应用之前的状态 if (Config.active) { snowInterval = startSnowInterval() } Config.dom.appendChild($canvas);"}]