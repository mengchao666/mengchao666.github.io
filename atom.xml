<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>mengchao666</title>
  
  <subtitle>个人记录</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-11-13T13:21:36.231Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>git提交流程</title>
    <link href="http://example.com/posts/1.html"/>
    <id>http://example.com/posts/1.html</id>
    <published>2024-11-11T14:12:51.000Z</published>
    <updated>2024-11-13T13:21:36.231Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Git下载及配置"><a href="#一、Git下载及配置" class="headerlink" title="一、Git下载及配置"></a>一、Git下载及配置</h2><p>我们第一次用git或者是新电脑上重新安装git工具的时候，都需要重新配置一下这个工具。</p><h3 id="Windows安装git"><a href="#Windows安装git" class="headerlink" title="Windows安装git"></a>Windows安装git</h3><p>官网网址<a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a>下载速度慢，且有可能安装不成功。 附快速下载地址（国内下载站）：<a href="https://github.com/waylau/git-for-win">https://github.com/waylau/git-for-win</a> 。 下载完之后，Windows中你在桌面上或者文件管理器中鼠标右键就可以看见Git Bash here，就是用来打开git bash的。</p><h3 id="Linux安装git"><a href="#Linux安装git" class="headerlink" title="Linux安装git"></a>Linux安装git</h3><p>linux在终端中，输入<code>sudo apt-get install git</code></p><p>下载完可以用命令<code>git --version</code>打印当前的git版本验证是否成功。下面正式开始Git的配置。</p><h3 id="配置git基本信息"><a href="#配置git基本信息" class="headerlink" title="配置git基本信息"></a>配置git基本信息</h3><p>接下来就是不管我们是第一次使用git工具，还是后来换电脑了，还是换成linux系统了，要想使用git都按照下面的方法配置一遍，才可以使用。 安装成功之后，在命令行中敲下如下命令 <code>git config --list</code>,显示当前的配置信息。 接下来设置提交仓库时的用户名信息 <code>git config --global user.name &quot;张三&quot;</code> 设置提交仓库是的邮箱信息 <code>git config --global user.email &quot;xxxxxxxx@qq.com&quot;</code> git设置关闭自动换行<code>git config --global core.autocrlf false</code> 为了保证文件的换行符是以安全的方法，避免windows与unix的换行符混用的情况，最好也加上这么一句 <code>git config --global core.safecrlf true</code></p><p>其实这些信息都在一个配置文件中，就在当前用户的主目录下边的**.gitconfig**文件中，也可以直接打开这个文件<code>cd ~,vim .gitconfig</code>进行编辑。</p><h3 id="git协议及秘钥配置"><a href="#git协议及秘钥配置" class="headerlink" title="git协议及秘钥配置"></a>git协议及秘钥配置</h3><p>git有四种协议：Git协议，http协议，本地协议，ssh协议。使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https。大部分都是用ssh协议。这个不仅速度快，而且不用每次提交输入密码，可谓是省心省力。 下面就说一下ssh配置过程。(这个协议配置的过程不可缺少，不然就用不了这种协议。)</p><p>首先生成 RSA 密钥对 :</p><p><code>ssh-keygen -t rsa -C &quot;xxxxxxxx@qq.com&quot;</code>注意格式，一定要正确。 ssh和-keygen无空格 此时在用户主目录下就会有一个.ssh隐藏文件，进入该目录有一个id_rsa.pub文件，cat命令查看这个文件，复制下来然后在 github网站添加公钥 ，方法如下 在 Github 网站添加公钥：在右上角头像处点settings进入设置，然后点SSH and GPG keys,进入之后点击New SSH key 粘贴进去，随便给这个秘钥命个名，方便管理就行了。钥匙显示黑色即可。 此时配置就完成了。接下来就可以使用git了。 执行此命令验证是否成功<code>ssh -T git@github.com</code> 成功显示为：Hi XXX! You’ve successfully authenticated, but GitHub does not provide shell access.</p><h2 id="二、先有本地库，后有远程库"><a href="#二、先有本地库，后有远程库" class="headerlink" title="二、先有本地库，后有远程库"></a>二、先有本地库，后有远程库</h2><h3 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h3><p>可以理解为版本库就是本地文件的一个目录，也叫仓库。可以用git来管理和回退等 创建版本库：找到一个想被管理的文件夹，进入到文件夹里，输入命令<code>git init</code>,此时git就可以管理这个目录了，并且在文件夹下多出来了一个.git的隐藏文件夹。这个.git就是版本库。 Git的版本库里存了很多东西，其中最重要的就是称为<strong>stage（或者叫index）的暂存区</strong>，还有Git为我们自动创建的<strong>第一个分支master</strong>，以及指向master的一个指针叫HEAD。 工作区：就是你在电脑里能看到的目录，比如刚才的文件夹就是一个工作区</p><h3 id="第一步：将文件添加到暂存区"><a href="#第一步：将文件添加到暂存区" class="headerlink" title="第一步：将文件添加到暂存区"></a>第一步：将文件添加到暂存区</h3><p>当我们想添加文件或者修改文件是需要添加到版本库中的，否则无法被git跟踪管理呀，所以当我们添加或者修改文件时，先要用<code>git add filename</code>添加到暂存区中，filename为<code>.</code>的时候代表当前目录下所有文件都添加到暂存区</p><h3 id="第二步：将文件提交到分支"><a href="#第二步：将文件提交到分支" class="headerlink" title="第二步：将文件提交到分支"></a>第二步：将文件提交到分支</h3><p><code>git commit -m &quot;message&quot;</code>，将文件提交到了分支。</p><h3 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h3><p>我们已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。 首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库，在Repository name填入项目名字，比如我们叫learngit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库 目前，在GitHub上的这个learngit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。</p><p>现在，我们根据GitHub的提示，在本地的learngit仓库下运行命令： <code>git remote add origin git@github.com:mengchao666/learngit.git</code> 请千万注意，把上面的mengchao666替换成你自己的GitHub账户名，否则，你在本地关联的就是我的远程库，你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。</p><p>添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。下一步，就可以把本地库的所有内容推送到远程库上： <code>git push -u origin master</code>把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样,从现在起，只要本地作了提交，就可以通过命令： <code>git push origin master</code></p><h2 id="三、先有远程库，后有本地库"><a href="#三、先有远程库，后有本地库" class="headerlink" title="三、先有远程库，后有本地库"></a>三、先有远程库，后有本地库</h2><p>现在，远程库已经准备好了，下一步是用命令git clone克隆一个本地库： <code>git clone git@github.com:mengchao666/learngit.git</code></p><p>可以使用<code>git clone -b branch</code>克隆指定的分支<br>后续修改可以使用如下命令提交</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git add .<br>git commit -m &quot;message&quot;<br>git push<br></code></pre></td></tr></table></figure><h2 id="四、企业开发流程"><a href="#四、企业开发流程" class="headerlink" title="四、企业开发流程"></a>四、企业开发流程</h2><p>在公司中做项目，一般项目代码都在公共仓库中，我们将其称为远程仓，一般按照如下步骤开发<br>1、将远程仓fork一份到个人仓<br>2、git clone个人仓代码到本地<br>3、使用<code>git remote -v</code>命令查看，此时本地关联的origin为个人仓<br>4、将本地代码关联到公司的远程仓，方便拉取最新代码，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git remote add upstream 公共仓地址<br></code></pre></td></tr></table></figure><p>此时再次使用<code>git remote -v</code>可以看到已经关联了upstream为远程仓<br>5、在开发需求和问题单修改之前，一般使用<code>git pull upstream</code>命令将远程仓代码更新至本地<br>6、修改代码后提交</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git add .<br>git commit -m &quot;message&quot;<br>git push origin branch<br></code></pre></td></tr></table></figure><p>7、在github&#x2F;gitlab页面创建MR申请，一般此时就可以了，找人加分就合入了<br>8、但是如果在创建MR申请时，提示冲突，此时需要解决冲突，解决如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git pull upstream<br></code></pre></td></tr></table></figure><p>此时会提示哪些文件有冲突，使用ctrl + F搜索<code>&gt;&gt;&gt;</code>,有此标志的即为冲突的地方，保留自己想要的代码，重新提交add commit push即可。</p><p>企业开发流程中，通常有远程仓新建了一个分支，个人远程仓没有此分支，需要更新，可按照如下步骤更新个人仓代码分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git checkout -b 新分支名称 upstream/新分支名称<br>git pull upstream 新分支名称<br>git push origin 新分支名称<br></code></pre></td></tr></table></figure><h2 id="五、代码回退等操作"><a href="#五、代码回退等操作" class="headerlink" title="五、代码回退等操作"></a>五、代码回退等操作</h2><h3 id="工作区的恢复-此时还没有add，代码回退"><a href="#工作区的恢复-此时还没有add，代码回退" class="headerlink" title="工作区的恢复(此时还没有add，代码回退)"></a>工作区的恢复(此时还没有add，代码回退)</h3><p>使用checkout恢复工作区 <code>git checkout .</code> （全部修改），<code>git checkout --file</code>改回一个文件,工作区—&gt;还没add</p><h3 id="add的撤销"><a href="#add的撤销" class="headerlink" title="add的撤销"></a>add的撤销</h3><p>git reset就是回退到指定的commitID,,使用git commit –amend时追加，不会生成新的commitID,是在原来的commitID基础上进行修改的。</p><p>HEAD指向当前最新的commitID，所以仅仅add,没有commit，此时的最新的commitID还是之前的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git reset --hard HEAD  // 不保留本地修改，回退<br>git reset --mixed HEAD //保留本地修改，可以重新git add<br></code></pre></td></tr></table></figure><p>简单理解git reset –xxx HEAD命令，就是将代码回退到了最新的一次commitID的代码状态，hard不保留本地代码工作空间的修改，而mixed保留</p><h3 id="commit后的撤销"><a href="#commit后的撤销" class="headerlink" title="commit后的撤销"></a>commit后的撤销</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">git reset --hard HEAD^ <span class="hljs-comment">// 不保留本地修改，回退到上一次的commitID状态</span><br>git reset --mixed HEAD^ <span class="hljs-comment">// 保留本地修改，撤销git commit,并且撤销git add</span><br>git reset --soft HEAD^ <span class="hljs-comment">//保留本地修改，撤销commit,不撤销add</span><br></code></pre></td></tr></table></figure><h2 id="六、git的一些其他操作"><a href="#六、git的一些其他操作" class="headerlink" title="六、git的一些其他操作"></a>六、git的一些其他操作</h2><p>查看分支：<code>git branch</code> <br>创建分支：<code>git branch &lt;name&gt;</code> <br>切换分支：<code>git checkout &lt;name&gt;</code>或者<code>git switch &lt;name&gt;</code> <br>创建+切换分支：<code>git checkout -b &lt;name&gt;</code>或者<code>git switch -c &lt;name&gt;</code> <br>合并某分支到当前分支：<code>git merge &lt;name&gt;</code> <br>删除分支：<code>git branch -d &lt;name&gt;</code></p><p>当代码仓有子仓情形下的一些命令：<br><code>git submodule update --init --remote</code><br><code>git submodule foreach git checkout branch</code><br><code>git submodule foreach --recursive</code></p><h2 id="七、同时提交两个MR"><a href="#七、同时提交两个MR" class="headerlink" title="七、同时提交两个MR"></a>七、同时提交两个MR</h2><p>当我们同时修改多个问题单，或者同时处理需求时，可能需要同时提交多分不同代码，此时处理方法如下：</p><p>1、本地创建一个新的分支来处理第一个MR</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git checkout -b mr1-branch<br></code></pre></td></tr></table></figure><p>2、提交第一个MR。<br>修改代码，git add、git commit，git push</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git push -u origin mr1-branch<br></code></pre></td></tr></table></figure><p>3、切换回原来的分支，以main分支为例<br>git checkout main<br>4、创建第二个分支处理第二个MR</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git checkout -b mr2-branch<br></code></pre></td></tr></table></figure><p>5、提交第二个MR。<br>修改代码，git add、git commit，git push</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git push -u origin mr2-branch<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、Git下载及配置&quot;&gt;&lt;a href=&quot;#一、Git下载及配置&quot; class=&quot;headerlink&quot; title=&quot;一、Git下载及配置&quot;&gt;&lt;/a&gt;一、Git下载及配置&lt;/h2&gt;&lt;p&gt;我们第一次用git或者是新电脑上重新安装git工具的时候，都需要重新配置一下</summary>
      
    
    
    
    <category term="git" scheme="http://example.com/categories/git/"/>
    
    
    <category term="git" scheme="http://example.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>addr2line</title>
    <link href="http://example.com/posts/addr2line.html"/>
    <id>http://example.com/posts/addr2line.html</id>
    <published>2024-11-10T14:39:55.000Z</published>
    <updated>2024-11-11T14:02:20.475Z</updated>
    
    <content type="html"><![CDATA[<p>addr2line是一个将地址转换为文件名和行号的工具。给定可执行文件(如exe&#x2F;a.out等)中的地址或可重定位对象(如so,ko等)部分中的偏移量，它会使用调试信息来确定与之相关的文件名和行数。</p><p>用户态coredump，一般使用gdb调试接口，gdb一般封装了addr2line，可以解析文件名和行号。如果环境配置了不生成coredump，可以使用addr2line调试。<code>所以addr2line一般解析内核Call trace使用较多。</code></p><h2 id="一、使用方法"><a href="#一、使用方法" class="headerlink" title="一、使用方法"></a>一、使用方法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">基本用法：<br>addr2line [选项] [地址]<br></code></pre></td></tr></table></figure><p>常用选项如下：</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-e</td><td>设置输入文件名称，默认为a.out</td></tr><tr><td>-i</td><td>解析内联函数</td></tr><tr><td>-f</td><td>显示函数名</td></tr><tr><td>-C</td><td>解析函数名</td></tr><tr><td>-p</td><td>以好读的方式显示</td></tr></tbody></table><p>需要注意的是使用addr2line的时候，可执行文件或重定位文件一定是要带调试信息的</p><h2 id="二、用户态普通程序崩溃"><a href="#二、用户态普通程序崩溃" class="headerlink" title="二、用户态普通程序崩溃"></a>二、用户态普通程序崩溃</h2><p>使用方法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">addr2line -e 进程名 IP指令地址 -f<br></code></pre></td></tr></table></figure><p>用户态程序崩溃，当没有coredump产生时，可以使用如下方法<br>假设我们的程序名称为segfault,当程序崩溃是，dmesg日志中会有报错信息:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">[root@localhost ~]# dmesg<br>[134563.793925] segfault[53791]: segfault at 0 ip 0000000000400546 sp 00007fff7956af70 error 6 <span class="hljs-keyword">in</span> segfault[400000+1000]<br>[134563.793946] Code: 01 5d c3 90 c3 66 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 f3 0f 1e fa eb 8a 55 48 89 e5 48 c7 45 f8 00 00 00 00 48 8b 45 f8 &lt;c7&gt; 00 00 00 00 00 b8 00 00 00 00 5d c3 66 2e 0f 1f 84 00 00 00 00<br></code></pre></td></tr></table></figure><p>此时我们注意到IP指令地址为0000000000400546<br>使用addr2line查看程序挂的位置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">addr2line -e segfault <span class="hljs-number">0x0000000000400546</span> -f<br></code></pre></td></tr></table></figure><h2 id="三、动态链接库程序崩溃"><a href="#三、动态链接库程序崩溃" class="headerlink" title="三、动态链接库程序崩溃"></a>三、动态链接库程序崩溃</h2><p>使用方法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">addr2line -e 动态链接库名称 IP指令地址-基地址 -f<br></code></pre></td></tr></table></figure><p>假设我们有一个程序名为test，链接了一个libfoo.so，程序运行时崩溃，dmesg查看日志如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">[root@localhost ~]<span class="hljs-meta"># dmesg</span><br>[<span class="hljs-number">70567.416655</span>] test[<span class="hljs-number">27722</span>]: segfault at <span class="hljs-number">0</span> ip <span class="hljs-number">00007f</span>fa1f588580 sp <span class="hljs-number">00007f</span>ffa964e698 error <span class="hljs-number">6</span> in libfoo.so[<span class="hljs-number">7f</span>fa1f588000+<span class="hljs-number">1000</span>]<br>[<span class="hljs-number">70567.427374</span>] Code: ff e8 <span class="hljs-number">64</span> ff ff ff c6 <span class="hljs-number">05</span> bd <span class="hljs-number">0</span>a <span class="hljs-number">20</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">5</span>d c3 <span class="hljs-number">0f</span> <span class="hljs-number">1f</span> <span class="hljs-number">00</span> c3 <span class="hljs-number">0f</span> <span class="hljs-number">1f</span> <span class="hljs-number">80</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> f3 <span class="hljs-number">0f</span> <span class="hljs-number">1</span>e fa e9 <span class="hljs-number">77</span> ff ff ff <span class="hljs-number">0f</span> <span class="hljs-number">1f</span> <span class="hljs-number">80</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> &lt;c7&gt; <span class="hljs-number">04</span> <span class="hljs-number">25</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">0f</span> <span class="hljs-number">0b</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> f3 <span class="hljs-number">0f</span> <span class="hljs-number">1</span>e fa <span class="hljs-number">48</span> <span class="hljs-number">83</span><br></code></pre></td></tr></table></figure><p>根据日志可知，段错误发生的位置是在test进程调用的<code>libfoo.so</code>库里，我们先使用ldd找到动态库的位置，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">[root@localhost <span class="hljs-number">69</span>]<span class="hljs-meta"># ldd test</span><br>        linux-vdso.so<span class="hljs-number">.1</span> (<span class="hljs-number">0x00007ffd15b24000</span>)<br>        libfoo.so =&gt; ./libfoo.so (<span class="hljs-number">0x00007f8c01879000</span>)<br>        libc.so<span class="hljs-number">.6</span> =&gt; /lib64/libc.so<span class="hljs-number">.6</span> (<span class="hljs-number">0x00007f8c014b4000</span>)<br>        /lib64/ld-linux-x86<span class="hljs-number">-64.</span>so<span class="hljs-number">.2</span> (<span class="hljs-number">0x00007f8c01a7b000</span>)<br></code></pre></td></tr></table></figure><p>00007ffa1f588580为程序崩溃点IP指令地址，使用dmesg消息中ip指令地址减去动态库基址值(00007ffa1f588580 -7ffa1f588000&#x3D;580), 差值0x580为错误点在动态库的地址，调用addr2line, 注意-e参数后文件名改为动态库名:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">addr2line -e libfoo.so <span class="hljs-number">580</span> -f -p<br></code></pre></td></tr></table></figure><h2 id="四、内核驱动程序运行崩溃"><a href="#四、内核驱动程序运行崩溃" class="headerlink" title="四、内核驱动程序运行崩溃"></a>四、内核驱动程序运行崩溃</h2><p>使用方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">addr2line -e xxx.ko 地址偏移量 -f<br></code></pre></td></tr></table></figure><p>本人所用主机即属于一旦发生Oops，就会触发panic，因此总是无法查看Oops时的dmesg日志，经查阅资料，发现是内核参数panic_on_oops的原因导致的，因为该参数被设置为1，所以Oops会触发panic，从而导致机器总是死机重启，无法查看Oops时的dmesg日志。下面提供两种方法修改Oops内核参数，使其不会在Oops的时候触发panic导致死机重启。</p><p>方法一：修改 &#x2F;proc下内核参数文件内容，临时生效，重启后失效。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">echo <span class="hljs-number">0</span> &gt; /proc/sys/kernel/panic_on_oops<br></code></pre></td></tr></table></figure><p>方法二：修改&#x2F;etc&#x2F;sysctl.conf 文件的内核参数来永久更改。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# vi /etc/sysctl.conf<br>[root@localhost ~]# cat /etc/sysctl.conf<br><span class="hljs-meta prompt_"># </span><span class="language-bash">sysctl settings are defined through files <span class="hljs-keyword">in</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">/usr/lib/sysctl.d/, /run/sysctl.d/, and /etc/sysctl.d/.</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"></span><br><span class="language-bash"><span class="hljs-comment"># Vendors settings live in /usr/lib/sysctl.d/.</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">To override a whole file, create a new file with the same <span class="hljs-keyword">in</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">/etc/sysctl.d/ and put new settings there. To override</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">only specific settings, add a file with a lexically later</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">name <span class="hljs-keyword">in</span> /etc/sysctl.d/ and put new settings there.</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"></span><br><span class="language-bash"><span class="hljs-comment"># For more information, see sysctl.conf(5) and sysctl.d(5).</span></span><br>kernel.panic_on_oops=0<br>[root@localhost ~]# cat /proc/sys/kernel/panic_on_oops<br>1 <br>[root@localhost ~]# sysctl -p<br>kernel.panic_on_oops = 0<br>[root@localhost ~]#<br>[root@localhost ~]# cat /proc/sys/kernel/panic_on_oops<br>0<br></code></pre></td></tr></table></figure><p>假设内核某ko运行后发生如下错误：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c">[root@localhost ~]<span class="hljs-meta"># dmesg</span><br>[ <span class="hljs-number">1039.918606</span>] my_oops_init<br>[ <span class="hljs-number">1039.918616</span>] BUG: unable to handle kernel <span class="hljs-literal">NULL</span> pointer dereference at <span class="hljs-number">0000000000000000</span><br>[ <span class="hljs-number">1039.926442</span>] PGD <span class="hljs-number">0</span> P4D <span class="hljs-number">0</span><br>[ <span class="hljs-number">1039.928979</span>] Oops: <span class="hljs-number">0002</span> [#<span class="hljs-number">1</span>] SMP NOPTI<br>[ <span class="hljs-number">1039.932637</span>] CPU: <span class="hljs-number">34</span> PID: <span class="hljs-number">3843</span> Comm: insmod Kdump: loaded Tainted: G           OE    --------- -  - <span class="hljs-number">4.18</span><span class="hljs-number">.0</span><span class="hljs-number">-394.</span>el8.x86_64 #<span class="hljs-number">1</span><br>[ <span class="hljs-number">1039.943756</span>] Hardware name: New H3C Technologies Co., Ltd. H3C UniServer R4950 G5/RS45M2C9SB, BIOS <span class="hljs-number">5.37</span> <span class="hljs-number">09</span>/<span class="hljs-number">30</span>/<span class="hljs-number">2021</span><br>[ <span class="hljs-number">1039.954000</span>] RIP: <span class="hljs-number">0010</span>:do_oops+<span class="hljs-number">0x5</span>/<span class="hljs-number">0x11</span> [oops]<br>[ <span class="hljs-number">1039.958364</span>] Code: Unable to access opcode bytes at RIP <span class="hljs-number">0xffffffffc02e6fdb</span>.<br>[ <span class="hljs-number">1039.965231</span>] RSP: <span class="hljs-number">0018</span>:ffffb9d40a8c7cb0 EFLAGS: <span class="hljs-number">00010246</span><br>[ <span class="hljs-number">1039.970449</span>] RAX: <span class="hljs-number">000000000000000</span>c RBX: <span class="hljs-number">0000000000000000</span> RCX: <span class="hljs-number">0000000000000000</span><br>[ <span class="hljs-number">1039.977573</span>] RDX: <span class="hljs-number">0000000000000000</span> RSI: ffff98942ee96758 RDI: ffff98942ee96758<br>[ <span class="hljs-number">1039.984697</span>] RBP: ffffffffc02e7011 R08: <span class="hljs-number">0000000000000000</span> R09: c0000000ffff7fff<br>[ <span class="hljs-number">1039.991822</span>] R10: <span class="hljs-number">0000000000000001</span> R11: ffffb9d40a8c7ad8 R12: ffffffffc02e9000<br>[ <span class="hljs-number">1039.998944</span>] R13: ffffffffc02e9018 R14: ffffffffc02e91d0 R15: <span class="hljs-number">0000000000000000</span><br>[ <span class="hljs-number">1040.006069</span>] FS:  <span class="hljs-number">00007f</span>1b8d93b740(<span class="hljs-number">0000</span>) GS:ffff98942ee80000(<span class="hljs-number">0000</span>) knlGS:<span class="hljs-number">0000000000000000</span><br>[ <span class="hljs-number">1040.014145</span>] CS:  <span class="hljs-number">0010</span> DS: <span class="hljs-number">0000</span> ES: <span class="hljs-number">0000</span> CR0: <span class="hljs-number">0000000080050033</span><br>[ <span class="hljs-number">1040.019884</span>] CR2: ffffffffc02e6fdb CR3: <span class="hljs-number">0000000145</span>c02000 CR4: <span class="hljs-number">0000000000350</span>ee0<br>[ <span class="hljs-number">1040.027008</span>] Call Trace:<br>[ <span class="hljs-number">1040.029454</span>]  my_oops_init+<span class="hljs-number">0x16</span>/<span class="hljs-number">0x19</span> [oops]<br>[ <span class="hljs-number">1040.033550</span>]  do_one_initcall+<span class="hljs-number">0x46</span>/<span class="hljs-number">0x1d0</span><br>[ <span class="hljs-number">1040.037390</span>]  ? do_init_module+<span class="hljs-number">0x22</span>/<span class="hljs-number">0x220</span><br>[ <span class="hljs-number">1040.041318</span>]  ? kmem_cache_alloc_trace+<span class="hljs-number">0x142</span>/<span class="hljs-number">0x280</span><br>[ <span class="hljs-number">1040.046023</span>]  do_init_module+<span class="hljs-number">0x5a</span>/<span class="hljs-number">0x220</span><br>[ <span class="hljs-number">1040.049777</span>]  load_module+<span class="hljs-number">0x14ba</span>/<span class="hljs-number">0x17f0</span><br>[ <span class="hljs-number">1040.053530</span>]  ? __do_sys_finit_module+<span class="hljs-number">0xb1</span>/<span class="hljs-number">0x110</span><br>[ <span class="hljs-number">1040.058059</span>]  __do_sys_finit_module+<span class="hljs-number">0xb1</span>/<span class="hljs-number">0x110</span><br>[ <span class="hljs-number">1040.062411</span>]  do_syscall_64+<span class="hljs-number">0x5b</span>/<span class="hljs-number">0x1a0</span><br>[ <span class="hljs-number">1040.066077</span>]  entry_SYSCALL_64_after_hwframe+<span class="hljs-number">0x65</span>/<span class="hljs-number">0xca</span><br>[ <span class="hljs-number">1040.071130</span>] RIP: <span class="hljs-number">0033</span>:<span class="hljs-number">0x7f1b8c8509bd</span><br>[ <span class="hljs-number">1040.074701</span>] Code: ff c3 <span class="hljs-number">66</span> <span class="hljs-number">2</span>e <span class="hljs-number">0f</span> <span class="hljs-number">1f</span> <span class="hljs-number">84</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">90</span> f3 <span class="hljs-number">0f</span> <span class="hljs-number">1</span>e fa <span class="hljs-number">48</span> <span class="hljs-number">89</span> f8 <span class="hljs-number">48</span> <span class="hljs-number">89</span> f7 <span class="hljs-number">48</span> <span class="hljs-number">89</span> d6 <span class="hljs-number">48</span> <span class="hljs-number">89</span> ca <span class="hljs-number">4</span>d <span class="hljs-number">89</span> c2 <span class="hljs-number">4</span>d <span class="hljs-number">89</span> c8 <span class="hljs-number">4</span>c <span class="hljs-number">8b</span> <span class="hljs-number">4</span>c <span class="hljs-number">24</span> <span class="hljs-number">08</span> <span class="hljs-number">0f</span> <span class="hljs-number">05</span> &lt;<span class="hljs-number">48</span>&gt; <span class="hljs-number">3</span>d <span class="hljs-number">01</span> f0 ff ff <span class="hljs-number">73</span> <span class="hljs-number">01</span> c3 <span class="hljs-number">48</span> <span class="hljs-number">8b</span> <span class="hljs-number">0</span>d <span class="hljs-number">9b</span> <span class="hljs-number">54</span> <span class="hljs-number">38</span> <span class="hljs-number">00</span> f7 d8 <span class="hljs-number">64</span> <span class="hljs-number">89</span> <span class="hljs-number">01</span> <span class="hljs-number">48</span><br>[ <span class="hljs-number">1040.093446</span>] RSP: <span class="hljs-number">002b</span>:<span class="hljs-number">00007f</span>fc4df0a968 EFLAGS: <span class="hljs-number">00000246</span> ORIG_RAX: <span class="hljs-number">0000000000000139</span><br>[ <span class="hljs-number">1040.101004</span>] RAX: ffffffffffffffda RBX: <span class="hljs-number">00005653f</span>b1997d0 RCX: <span class="hljs-number">00007f</span>1b8c8509bd<br>[ <span class="hljs-number">1040.108126</span>] RDX: <span class="hljs-number">0000000000000000</span> RSI: <span class="hljs-number">00005653f</span>980c8b6 RDI: <span class="hljs-number">0000000000000003</span><br>[ <span class="hljs-number">1040.115251</span>] RBP: <span class="hljs-number">00005653f</span>980c8b6 R08: <span class="hljs-number">0000000000000000</span> R09: <span class="hljs-number">00007f</span>1b8cbd9760<br>[ <span class="hljs-number">1040.122375</span>] R10: <span class="hljs-number">0000000000000003</span> R11: <span class="hljs-number">0000000000000246</span> R12: <span class="hljs-number">0000000000000000</span><br>[ <span class="hljs-number">1040.129498</span>] R13: <span class="hljs-number">00005653f</span>b1997b0 R14: <span class="hljs-number">0000000000000000</span> R15: <span class="hljs-number">0000000000000000</span><br>[ <span class="hljs-number">1040.136623</span>] Modules linked in: oops(OE+) binfmt_misc xt_CHECKSUM ipt_MASQUERADE xt_conntrack ipt_REJECT nf_reject_ipv4 nft_compat nft_counter nft_chain_nat nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 nf_tables nfnetlink rpcsec_gss_krb5 auth_rpcgss nfsv4 dns_resolver nfs lockd grace fscache bridge stp llc intel_rapl_msr intel_rapl_common amd64_edac_mod edac_mce_amd amd_energy kvm_amd kvm irqbypass ipmi_ssif pcspkr crct10dif_pclmul crc32_pclmul ghash_clmulni_intel rapl joydev ccp sp5100_tco i2c_piix4 k10temp ptdma acpi_ipmi ipmi_si sunrpc vfat fat xfs libcrc32c sd_mod t10_pi sg crc32c_intel ast drm_vram_helper drm_kms_helper syscopyarea sysfillrect sysimgblt fb_sys_fops drm_ttm_helper ttm ahci drm libahci <span class="hljs-title function_">nfp</span><span class="hljs-params">(OE)</span> igb libata dca i2c_algo_bit dm_mirror dm_region_hash dm_log dm_mod ipmi_devintf ipmi_msghandler<br>[ 1040.208357] CR2: 0000000000000000<br>[ 1040.211668] ---[ end trace b69c1e8998070273 ]---<br>[ 1040.230185] RIP: 0010:do_oops+0x5/0x11 [oops]<br>[ 1040.234540] Code: Unable to access opcode bytes at RIP 0xffffffffc02e6fdb.<br>[ 1040.241409] RSP: 0018:ffffb9d40a8c7cb0 EFLAGS: 00010246<br>[ 1040.246626] RAX: 000000000000000c RBX: 0000000000000000 RCX: 0000000000000000<br>[ 1040.253750] RDX: 0000000000000000 RSI: ffff98942ee96758 RDI: ffff98942ee96758<br>[ 1040.260876] RBP: ffffffffc02e7011 R08: 0000000000000000 R09: c0000000ffff7fff<br>[ 1040.267998] R10: 0000000000000001 R11: ffffb9d40a8c7ad8 R12: ffffffffc02e9000<br>[ 1040.275124] R13: ffffffffc02e9018 R14: ffffffffc02e91d0 R15: 0000000000000000<br>[ 1040.282247] FS:  00007<span class="hljs-title function_">f1b8d93b740</span><span class="hljs-params">(<span class="hljs-number">0000</span>)</span> GS:<span class="hljs-title function_">ffff98942ee80000</span><span class="hljs-params">(<span class="hljs-number">0000</span>)</span> knlGS:0000000000000000<br>[ 1040.290323] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033<br>[ 1040.296061] CR2: ffffffffc02e6fdb CR3: 0000000145c02000 CR4: 0000000000350ee0<br></code></pre></td></tr></table></figure><p>Oops: 0002 – 错误码<br>Oops: [#1] – Oops发生的次数<br>CPU: 34 – 表示Oops是发生在CPU34上<br>关键信息如下，这里提示在操作函数do_oops的时候出现异常，地址偏移量0x5：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">[ 1039.954000] RIP: 0010:do_oops+0x5/0x11 [oops]<br></code></pre></td></tr></table></figure><p>为什么这条信息关键? 因为其含有指令指针RIP；指令指针IP&#x2F;EIP&#x2F;RIP的基本功能是指向要执行的下一条地址。在8080 8位微处理器上的寄存器名称是PC（program counter，程序计数器），从8086起，被称为IP（instruction pointer，指令指针）。主要区别在与PC指向正在执行的指令，而IP指向下一条指令。在64位模式下，指令指针是RIP寄存器。这个寄存器保存着下一条要执行的指令的64位地址偏移量。64位模式支持一种新的寻址模式，被称为RIP相对寻址。使用这个模式，有效地址的计算方式变为RIP（指向下一条指令）加上位移量。</p><p>由此可以看出内核执行到do_oops+0x5&#x2F;0x11这个地址的时候出现异常，我们只需要找到这个地址对应的代码即可。</p><p>do_oops指示了是在do_oops函数中出现的异常， 0x5表示出错的地址偏移量， 0x11表示do_oops函数的大小。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">打印格式：do_oops+<span class="hljs-number">0x5</span>/<span class="hljs-number">0x11</span> [oops] <br>即：symbol+offset/size [module] <br>symbol: 符号 offset：地址偏移量 size：函数的长度 module: 所属内核模块<br></code></pre></td></tr></table></figure><p>使用如下命令解析</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">addr2line -e oops.ko <span class="hljs-number">0x5</span> -f -p<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;addr2line是一个将地址转换为文件名和行号的工具。给定可执行文件(如exe&amp;#x2F;a.out等)中的地址或可重定位对象(如so,ko等)部分中的偏移量，它会使用调试信息来确定与之相关的文件名和行数。&lt;/p&gt;
&lt;p&gt;用户态coredump，一般使用gdb调试接口，g</summary>
      
    
    
    
    <category term="Linux工具" scheme="http://example.com/categories/Linux%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="Linux工具" scheme="http://example.com/tags/Linux%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>个人博客网站部署&amp;文章提交</title>
    <link href="http://example.com/posts/%E7%BD%91%E7%AB%99%E9%83%A8%E7%BD%B2-%E5%86%99%E4%BD%9C.html"/>
    <id>http://example.com/posts/%E7%BD%91%E7%AB%99%E9%83%A8%E7%BD%B2-%E5%86%99%E4%BD%9C.html</id>
    <published>2024-11-10T07:38:23.000Z</published>
    <updated>2024-11-10T14:44:31.349Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、网站部署"><a href="#一、网站部署" class="headerlink" title="一、网站部署"></a>一、网站部署</h2><p>1、首先在github上创建自己的一个仓库，仓库名字为mengchao666.github.io</p><p>2、将<a href="https://github.com/mengchao666/blog-demo">https://github.com/mengchao666/blog-demo</a>代码下载到本地，用VScode打开</p><p>3、安装node.js，pnpm，hexo</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">node.js官网安装：https://nodejs.cn/download/<br>pnpm安装：npm install pnpm -g<br>hexo安装：npm install hexo-cli -g<br></code></pre></td></tr></table></figure><p>4、在Vscode打开的项目终端下执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">pnpm i<br>pnpm dev<br></code></pre></td></tr></table></figure><p>5、使用hexo deploy命令部署，打开mengchao666.github.io即可</p><p>6、新增文章使用如下命令新增</p><p>例如：hexo new post “网站部署”</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo new post &lt;title&gt;<br></code></pre></td></tr></table></figure><p>7、新增文章后，使用命令部署提交到github</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo clean<br>hexo deploy<br></code></pre></td></tr></table></figure><p>更多操作可以参考：<a href="https://xaoxuu.com/wiki/stellar/topic.html">https://xaoxuu.com/wiki/stellar/topic.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、网站部署&quot;&gt;&lt;a href=&quot;#一、网站部署&quot; class=&quot;headerlink&quot; title=&quot;一、网站部署&quot;&gt;&lt;/a&gt;一、网站部署&lt;/h2&gt;&lt;p&gt;1、首先在github上创建自己的一个仓库，仓库名字为mengchao666.github.io&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="网站" scheme="http://example.com/categories/%E7%BD%91%E7%AB%99/"/>
    
    
    <category term="网站" scheme="http://example.com/tags/%E7%BD%91%E7%AB%99/"/>
    
  </entry>
  
</feed>
