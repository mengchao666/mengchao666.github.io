<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>mengchao666</title>
  
  <subtitle>个人记录</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-11-24T14:32:49.559Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>dm-verity</title>
    <link href="http://example.com/posts/dm-verity.html"/>
    <id>http://example.com/posts/dm-verity.html</id>
    <published>2024-11-24T14:09:23.000Z</published>
    <updated>2024-11-24T14:32:49.559Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一、技术模块简介</strong></p><p>Dm-verity 是 device-mapper 架构下的一个目标设备类型， 通过它来保障设备或者设备分区的完整性。</p><p>dm-verity通常用于验证镜像的完整性。比如常规的系统启动的对根文件系统的验签，耗时很长。可以使用dm-verity替代，由于dm-verity是使用时才进行hash计算校验，所以对启动性能的提高有很大帮助。</p><p>Dm-verity类型的目标设备有两个底层设备，一个是数据设备(data device), 是用来存储实际数据的，另一个是hash设备(hash device), 用来存储hash数据的，这个是用来校验data device数据的完整性的。</p><p>简单的架构图如下：</p><p><img src="https://raw.githubusercontent.com/mengchao666/picture/main/blog2bca569a67ffab1bb48b246e4d57cb2a.png"></p><p>图中映射设备(Mapper Device)和目标设备(Target Device)是一对一关系，对映射设备的读操作被映射成对目标设备的读操作，在目标设备中，dm-verity又将读操作映射为数据设备（Data Device）的读操作。但是在读操作的结束处，dm-verity加了一个额外的校验操作，对读到的数据计算一个hash值，用这个哈希值和存储在哈希设备(Hash Device)</p><p><strong>二、设计原理</strong></p><p>对于本文要介绍的dm-verity功能模块，笔者选择在当前移动终端应用的角度来展开讲解，也就是Android平台在dm-verity的应用。</p><p>Android 端主要是在镜像启动时验证这个功能场景上使用到了 dm-verity 技术，该技术可以对块存储设备进行完整性检查，有助于阻止某些恶意程序对镜像的修改，有助于Android用户在启动设备时确认设备状态与上次使用时是否相同。在系统镜像(比如 system、vendor等)启动时以及运行时可以实时性监测当前镜像是否被篡改。</p><p>通过dm-verity技术，可以确认块设备内容是否跟预期一致，具体的实现原理是利用哈希树(hashtree)做到的。用以下图来形象说明</p><p><img src="https://raw.githubusercontent.com/mengchao666/picture/main/blog519d5a05bc1dbd5572a92395a526d2d1.png"></p><p>(图来自：<a href="https://source.android.com/security/verifiedboot/dm-verity">https://source.android.com/security/verifiedboot/dm-verity</a>)</p><p>简单说明一下这个插图背后的原理：</p><p>在编译(一般应该是运行open)阶段，首先会对系统镜像(比如system.img、vendor.img)按照每4k大小计算对应hash，将这些hash信息存起来，形成上面图中的layer 0层，紧接着会对 layer 0 层同样按照每4k大小计算hash，并将这层的hash信息存起来，形成layer 1层，以此类推，直至最后的hash信息存放在一个4k大小的块中(未填满使用0填充)，这里边存储的hash信息称为 root hash。</p><p>在运行阶段，对于镜像里的文件进行访问时，操作对应所在块设备的存储区域时，会计算当前存储块(按4k大小)的hash值，然后会跟存储在哈希树上对应块的hash值进行比较，如果匹配不上，则认为当前该文件在底层存储被篡改或是损坏了。</p><p>为了更形象的描述下镜像运行时如何利用哈希树做校验的，下面以一个1G大小的镜像为例，来说明一下这个过程：</p><p><img src="https://raw.githubusercontent.com/mengchao666/picture/main/blog3d6e32d1e4c62a2528f3f83da22eea6a.png"></p><p>根据 hashtree 的生成方式，以 1G 的镜像为例：</p><p>1）按照 4K 大小划分，将1G 大小的镜像依顺序划分可得到 262144 个 4k 大小的块</p><p>2）对这 262144 块数据块进行第一层(Level 0) hash 计算，由于 SHA256(具体的hash算法可配置，此例以SHA256为参考) 计算出来的hash值占 256 个字节，一个 4K 的块可以存储 128 个hash值，所以存储这 262144 块数据块的hash值需要花费 2048 块</p><p>3）对第一层存储 hash 值的数据块进行第二层(Level 1) 的 hash 计算，同理，计算这 2048 块hash数据块需要花费 16 块</p><p>4）对第二层存储 hash 值的数据块进行第三层(Level 2) 的 hash 计算，由于第二层的hash数据块小于128块，所以第三层是最后一层，直接计算得到 root hash 数据块(不够4K大小补齐0)。</p><p>细心的读者可能已经发现了，Level 0 层其实已经包含了所有raw data数据块的hash信息了，也就说明Level 0 层已经具备可以验证 raw data 的能力了，为何还需要在 Level 0 的基础上继续算hash组装下一个 Level 层级呢？</p><p>这里要引入一个安全策略设计问题，镜像raw data数据块是由对应的hash信息来校验保证的，为了保证镜像raw data是我们“想要的”，我们还需要对 hash 信息进行合法性验证，简单理解就是要确认这个hash信息是我们“想要的”， 方法就是对这个hash信息再次计算一次hash值，这里称为 root hash，然后添加一些类似于签名保护并保存起来<strong>（通常在实际工作中，在镜像编译阶段将root hash计算出来，保存在镜像的某个地方，通过cms等签名方式保存，启动阶段会进行cms验签以保证root_hash的正确性）</strong>，主要是为了防止 root hash 被非法篡改。在一次 raw data 数据块的校验过程中，需要对 hash 信息计算一次 hash，然后跟保存的 root hash 进行比较，验证了 hash 信息的合法性之后，再来校验对应的 raw data 数据块。</p><p>有了以上背景，再回到刚刚这个“为何还需要在 Level 0 的基础上继续算hash组装下一个 Level 层级”的问题，按照上面的安全策略，如果 hash 信息只有 Level 0 一层的话，接下来对 raw data 数据块的校验将会是这样：每操作一个raw data数据块，都需要计算一次 Level 0 的 hash 值，跟 root hash 进行比较，验证合法之后再对 raw data 数据块进行校验。本文中举例是 1G 的镜像，Level 0用来保存 hash 信息的数据块已经达到 2048 块，如果对面对更大的镜像，Level 0 所占的数据块也会更大，如果是按照上面的计算方法，对 raw data 数据块的校验效率将会非常非常低。</p><p>作为对比，哈希树机制是如何体现出效率呢，下面以具体某一块 raw data 数据块的读取过程来说明其设计原理：</p><p><img src="https://raw.githubusercontent.com/mengchao666/picture/main/blogafbc138ead05da1b26f41abf1b5c35f9.png"></p><p>1）假设目前正需要读取第 200000 块的数据块，通过前面哈希树的构造，可以比较快速的计算出在 Level 0 层，也就是直接对应这个数据块的hash值存储位置，通过对 128 相除以及求余的方式就可以分别计算出该 hash 值存储在具体某一块(块A)以及这一块上的偏移(偏移A)。</p><p>2）确定了 Level 0 层的具体块A后，利用相同的方式可以得到 Level 0 块A在 Level 1 层存储其 hash 值的块B位置以及块B上的偏移(偏移B)</p><p>3）同上述原理，可以最终定位到 Level 1 层块 B 在 Level 2 上的数据块(只有一块)上偏移(偏移C)</p><p>4）在获取到该数据块对应hashtree关联的各个层级的块以及偏移后，接下来就是做一层一层的验证：</p><p>步骤1. 优先验证的是Level 2 中的数据块(只有一个4k的数据块)， 计算这个数据块的hash，跟保存的 root hash进行比对，验证Level 2的数据块块是否正确。</p><p>步骤2. 在Level 2中的数据块得到验证后，由上面计算到的Level 2中数据块上的偏移 C 去校验 Level 1 层的 B 块。</p><p>步骤3. 在 Level 1 层的 B 数据块得到验证后，由上面计算到的 Level 1 中 B 数据块上的偏移B去验证 Level 0 层的 A块。</p><p>步骤4. Level 0层中的 A 数据块得到验证后，最终会由 Level 0 层的偏移A来校验最终的 raw data数据块(第 200000 块).</p><p>可以看到，在使用哈希树的设计之后，对数据块验证整个过程中，涉及到的数据块hash计算只有3块(有N层就计算N块)，相比于一层校验模式，效率要高很多。</p><p><strong>三、应用层面</strong></p><p>读者到目前为止应该大致了解到了移动终端在镜像完整性校验上相关的设计原理，接下来会从应用端层面来说明如何使用 dm-verity 底层提供的接口来初始化 dm 设备，并为后续实时校验做好准备，内核绝大多数功能模块存在的意义都要靠跟应用端的交互来体现，作为对内核某个模块的研究，初步从应用层出发不乏是一个好办法。</p><p>通常系统启动阶段，使用veritysetup工具指定data device和hash device，以及指定的root hash值，hash device的具体位置，hash device通常位于data device的后面一部分。通过veritysetup工具执行后，会生成dm设备，如我们原来使用的文件系统为&#x2F;dev&#x2F;sda3，则此时可以生成一个dm设备为sda3-dm，后续通过mount挂载sda3-dm到&#x2F;sysroot即可实现挂载根文件系统，后续读取根文件系统数据，均会通过sda3-dm设备中转，通过IO定向映射访问&#x2F;dev&#x2F;sda3，并进行hash校验</p><p>如下为veritysetup应用层的3个常规步骤：</p><p>步骤一. Create dm device</p><p>创建 dm 设备主要有如下小步骤：</p><ol><li>open &#x2F;dev&#x2F;device-mapper 设备节点</li><li>传入逻辑分区name、随机生成的uuid参数，调用 DM_DEV_CREATE ioctl 命令</li></ol><p>步骤二. Load verity table</p><p>这里需要引入一个 verity table 的概念，先简单介绍以下 verity table 所包含的内容：</p><p>1）Verity target version(verity target 版本号)</p><p>2）Data block device(存储实际待校验数据的块设备)</p><p>3）Hash block device(存储校验使用到hash的块设备，一般情况跟data block device是同一个)</p><p>4）Data block size(数据块设备的每块存储size)</p><p>5）Hash block size（hash块设备的每块存储size）</p><p>6）Num data block(数据块设备占用的块数量)</p><p>7）Hash start block(hash设备在存储设备的起始位置)</p><p>8）Hash algo(hash算法)</p><p>9）root digest(对应上面说的 root hash)</p><p>10）Salt(用于计算hash的盐值)</p><p>这些信息主要是跟最终数据块在校验计算过程中会被使用到的，比如说 hash 设备的起始位置、hash算法、root hash、salt，这些都在实际运行时校验数据块时会用到，这些信息是存储是镜像的固定位置上，这些信息在编译阶段构建镜像的时候就已经计算好的，并存储在镜像的固定位置。</p><p>Verity table 初始化代码具体如下：</p><p><img src="https://raw.githubusercontent.com/mengchao666/picture/main/blog2fe4aca179fac7a107e2e3d05b9a6732.png"></p><p>上层通过从镜像固定位置获取到信息并初始化好 verity table， 通过调用DM_TABLE_LOAD</p><p>Ioctl 命令将 verity table 传递至kernel。</p><p>步骤三. Active dm device</p><p>调用DM_DEV_SUSPEND ioctl 指令激活 dm device，对应底层，该 cmd 对应 suspend &amp; resume的实现，如果不设置 DM_SUSPEND_FLAG 标志位，默认走 resume 流程。</p><p>应用端在实现上比较简单，主要通过 create -&gt; load verity table -&gt; active dm device 的流程完成了对dm设备的创建、verity table的读取以及传递以及dm设备的激活，为后续实时进行的数据块校验做好了初始化工作。</p><p><strong>四、内核层面</strong></p><p>有了以上应用层面的流程讲解，那对应内核，自然而然就是对每一步应用端的系统调用做对应的内核实现做讲解。</p><p>相应的，内核层面也有以下3个步骤：</p><p>步骤一. dev_create</p><p>对应应用端的DM_DEV_CREATE ioctl cmd，kernel端的大致实现如下：</p><p><img src="https://raw.githubusercontent.com/mengchao666/picture/main/blogccfa2ebd83ceb9f60a306d6bc6ce6b76.png"></p><p>这部分比较简单：</p><p>1). 检测传入参数的partition name是否合法</p><p>2). 开始尝试分配内存初始化 mapped device 结构体以及分配设备minor号（最终用于 dm 设备的设备号，比如 dm-1），使用内核提供的blk_queue_make_request函数注册该mapped device对应的请求队列dm_make_request, 该请求队列最终会在IO重定向中被使用到。并将该mapped device作为磁盘块设备注册到内核中。</p><p>3). 将创建好的mapped device插入到一个全局hash表中，该表中保存了内核中当前创建的所有mapped device。</p><p>步骤二. dm_ctl_ioctl(DM_TABLE_LOAD_CMD(table_load))</p><p>对应应用端的DM_TABLE_LOAD ioctl cmd，kernel端的大致实现可看下面的思维导图：</p><p><img src="https://raw.githubusercontent.com/mengchao666/picture/main/blog4afc7c79fab30f870aed1bd266ea78e8.png"></p><p>总的来说，这个步骤主要是根据入参初始化相应的dm_table、dm_target结构，并且根据参数所指定的target类型，调用相应的target类型的构建函数ctr在内存中构建target device， 在结构上形成 dm_table –&gt; dm_target –&gt; target type –&gt; target device 的链路结构。</p><p>步骤三. dm_ctl_ioctl(DM_DEV_SUSPEND_CMD(dev_suspend))</p><p><img src="https://raw.githubusercontent.com/mengchao666/picture/main/bloge0642548438f6e608b96e333d12f12cd.png"></p><p>很显然，这一个步骤主要是建立 mapped device 与 dm_table 的关联。</p><p>通过以上几个步骤，在内核中就建立一个可以提供给用户使用的mapped device逻辑块设备</p><p>综上涉及到了几个关键的数据结构： mapped device、dm_table、dm_target、target_type、target device(以dm-verity为例)</p><p>其实这几个步骤主要是对上述数据结构进行初始化，并且更重要是互相建立了关联关系。他们之间的关联关系如下：</p><p><img src="https://raw.githubusercontent.com/mengchao666/picture/main/blog08c1b4ed417142d1c73e3a90a6e99bb8.png"></p><p>内核经过了这3个步骤，一方面是创建了一个可以提供给应用端使用的 mapped device 逻辑块设备，另一方面是内部建立了 mapped device - target device 的联系， 应用层可以通过对 mapped device 进行策略逻辑操作，最终会通过 mapped device - target device 的联系作用到 对应的target device 上。</p><p><strong>五、核心数据流</strong></p><p>在上面介绍了dm-verity的设计原理、应用层面以及内核层面的实现之后，读者可能比较关心整个链路的数据流，或者说镜像在校验链路具体流程是如何的，接下来以下主要是围绕着访问镜像文件时的IO流是如何的。</p><p>上面说到，应用层在经过 create -&gt; load verity table -&gt; active dm device 的流程完成了dm块设备的初始化工作，之后应用层会对该逻辑块设备进行文件系统挂载，在挂载的过程中，需要访问到实际存储设备(读取文件系统的super block等)，这个过程中就需要透过这个逻辑块设备，最终操作到与其关联的target device。</p><p>在这个过程中， 对块设备的IO请求会从逻辑设备mapped device转发相应的target device上，并且会根据对应target_type描述的IO处理规则对IO请求进行处理。以本文讨论的 dm-verity 类型的 target device 来说，对于 mapped device 转发过来的IO，会在 hashtree 里找到该 IO data 对应的 hash 数据，并进行比较，完成校验，返回此次的校验结果并结束本次IO请求。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;一、技术模块简介&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Dm-verity 是 device-mapper 架构下的一个目标设备类型， 通过它来保障设备或者设备分区的完整性。&lt;/p&gt;
&lt;p&gt;dm-verity通常用于验证镜像的完整性。比如常规的系统启动的对根文件系</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>98、验证二叉搜索树</title>
    <link href="http://example.com/posts/98%E3%80%81%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html"/>
    <id>http://example.com/posts/98%E3%80%81%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html</id>
    <published>2024-11-17T13:42:49.000Z</published>
    <updated>2024-11-17T14:10:17.359Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</p><p>有效 二叉搜索树定义如下：</p><p>节点的左子树只包含 小于 当前节点的数。<br>节点的右子树只包含 大于 当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。</p><p>示例 1：<br><img src="https://raw.githubusercontent.com/mengchao666/picture/main/blog20241117214340.png"></p><p>输入：root &#x3D; [2,1,3]<br>输出：true</p><p>示例 2：<br><img src="https://raw.githubusercontent.com/mengchao666/picture/main/blog20241117214354.png"></p><p>输入：root &#x3D; [5,1,4,null,null,3,6]<br>输出：false<br>解释：根节点的值是 5 ，但是右子节点的值是 4 。</p><p>提示：</p><p>树中节点数目范围在[1, 10^4] 内<br>-2^31 &lt;&#x3D; Node.val &lt;&#x3D; 2^31 - 1</p><h2 id="二、C语言代码"><a href="#二、C语言代码" class="headerlink" title="二、C语言代码"></a>二、C语言代码</h2><p>根据二叉搜索树的性质，二叉搜索树的中序遍历后，结果为有序且从小到大，所以我们遍历二叉树，将结果保存到数组中，然后判断数组是否有序即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     struct TreeNode *left;</span><br><span class="hljs-comment"> *     struct TreeNode *right;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> TreeNode* root)</span> &#123;<br>    <span class="hljs-type">int</span> returnSize = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> *res = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">10000</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-keyword">if</span> (res == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    traverse(root, res, &amp;returnSize);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; returnSize - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (res[i] &gt;= res[i + <span class="hljs-number">1</span>]) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">traverse</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> TreeNode* root, <span class="hljs-type">int</span> *res, <span class="hljs-type">int</span> *returnSize)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    traverse(root-&gt;left, res, returnSize);<br>    res[*returnSize] = root-&gt;val;<br>    (*returnSize)++;<br>    traverse(root-&gt;right, res, returnSize);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、题目描述&quot;&gt;&lt;a href=&quot;#一、题目描述&quot; class=&quot;headerlink&quot; title=&quot;一、题目描述&quot;&gt;&lt;/a&gt;一、题目描述&lt;/h2&gt;&lt;p&gt;给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。&lt;/p&gt;
&lt;p&gt;有效 二叉搜索树定义如</summary>
      
    
    
    
    <category term="二叉树" scheme="http://example.com/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
    <category term="二叉树" scheme="http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>96、不同的二叉搜索树</title>
    <link href="http://example.com/posts/96%E3%80%81%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html"/>
    <id>http://example.com/posts/96%E3%80%81%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html</id>
    <published>2024-11-17T12:57:49.000Z</published>
    <updated>2024-11-17T14:10:11.572Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。</p><p>示例 1：<br><img src="https://raw.githubusercontent.com/mengchao666/picture/main/blog20241117205823.png"><br>输入：n &#x3D; 3<br>输出：5<br>示例 2：</p><p>输入：n &#x3D; 1<br>输出：1</p><p>提示：<br>1 &lt;&#x3D; n &lt;&#x3D; 19</p><h2 id="二、C-代码"><a href="#二、C-代码" class="headerlink" title="二、C++代码"></a>二、C++代码</h2><p>解法一：</p><p>这种题目，我一般是计算出前面多个例子，根据计算出来的多个例子，进行归纳总结，利用数学归纳法，找规律，推算出第n个的结果，然后利用类似如下方法，根据第0个，第1个，第2个……，以此计算出第n个。</p><p>n&#x3D;1,搜索二叉树种数：1 ,只有一个节点，所以为1</p><p>n&#x3D;2,搜索二叉树种数：2 ,只有二个节点，要么1为根节点，要么2为根节点，所以结果为2</p><p>n&#x3D;3,搜索二叉树种数：5 ,有三个节点<br>(1)、1为根节点，另外两个节点，均大于1，根据二叉搜索树的性质，大于根节点的数字，即另外两个节点2和3只能作为右子树，再作为一个整体，构成二叉搜索树，此时另外两个节点构成结果等同于n&#x3D;2时的结果，为2<br>(2)、2为根节点，根据二叉搜索树性质，1只能作为左子树，3只能作为右子树，只有一种情况，所以结果为1<br>(3)、3为根节点，根据二叉搜索树性质，1和2只能作为左子树,1和2作为一个整体再构成二叉搜索树，此时与(1)一样，结果等于n&#x3D;2时的结果为2<br>所以n&#x3D;3时，搜索二叉树种数为2+1+2&#x3D;5</p><p>n&#x3D;4,搜索二叉树种数：14<br>(1)、1为根节点，另外三个节点，均大于1，另外节点只能作为右子树，其他节点再作为一个整体，构成二叉搜索树，此时另外三个节点构成结果等同于n&#x3D;3时的结果，为5<br>(2)、2为根节点，根据二叉搜索树性质，1只能作为左子树，3,4只能作为右子树，此时进行排列组合，即为n&#x3D;1和n&#x3D;2的结果相乘，为2<br>(3)、3为根节点，结果等于(2)时的结果为2<br>(3)、4为根节点，结果等于(1)时的结果为5</p><p>n&#x3D;5,搜索二叉树种数：42<br>……<br>所以我总结规律为当输入数字为100,结果应该为<code>n=0 * n=99 + n=1 * n=98 + …… + n=99 * n=0</code>, n&#x3D;0时为1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">3</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            res += (<span class="hljs-built_in">numTrees</span>(i) * <span class="hljs-built_in">numTrees</span>(n- <span class="hljs-number">1</span> - i));<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>解法二：<br>解法一比较耗时，所以在解法一基础上进行优化，可以把中间的结果都保存到数组nums中，后续就不需要每次都遍历才拿到结果了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nums</span><span class="hljs-params">(<span class="hljs-number">20</span>, <span class="hljs-number">0</span>)</span></span>;<br>        nums[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">traverse</span>(n, nums);<br>        <span class="hljs-keyword">return</span> nums[n];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">traverse</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (nums[n] != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> nums[n];<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            nums[n] += (<span class="hljs-built_in">traverse</span>(i, nums) * <span class="hljs-built_in">traverse</span>(n- <span class="hljs-number">1</span> - i, nums));<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>解法3：<br>动态规划，后续再写具体思路吧：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">// 二叉搜索数的特征，左子树小于根，右子树大于根</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n<span class="hljs-number">+1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;  <span class="hljs-comment">// dp[0]初始化为1</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)  <span class="hljs-comment">// 从1...n的二叉搜索数数目</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=i; j++)  <span class="hljs-comment">// 逐步选用1...n作为根节点</span><br>                dp[i]+=dp[j<span class="hljs-number">-1</span>]*dp[i-j];  <span class="hljs-comment">// 左侧j-1个数，右侧i-j个数</span><br>        <span class="hljs-keyword">return</span> dp[n]; <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、题目描述&quot;&gt;&lt;a href=&quot;#一、题目描述&quot; class=&quot;headerlink&quot; title=&quot;一、题目描述&quot;&gt;&lt;/a&gt;一、题目描述&lt;/h2&gt;&lt;p&gt;给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足</summary>
      
    
    
    
    <category term="二叉树" scheme="http://example.com/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
    <category term="二叉树" scheme="http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>94、二叉树的中序遍历</title>
    <link href="http://example.com/posts/94%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.html"/>
    <id>http://example.com/posts/94%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.html</id>
    <published>2024-11-17T12:41:04.000Z</published>
    <updated>2024-11-17T14:10:02.309Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个二叉树的根节点root，返回它的中序遍历 。</p><p>示例 1：<br><img src="https://raw.githubusercontent.com/mengchao666/picture/main/blog20241117204222.png"></p><p>输入：root &#x3D; [1,null,2,3]<br>输出：[1,3,2]<br>示例 2：</p><p>输入：root &#x3D; []<br>输出：[]<br>示例 3：</p><p>输入：root &#x3D; [1]<br>输出：[1]</p><p>提示：</p><p>树中节点数目在范围 [0, 100] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100</p><p>进阶: 递归算法很简单，你可以通过迭代算法完成吗？</p><h2 id="二、C语言题解"><a href="#二、C语言题解" class="headerlink" title="二、C语言题解"></a>二、C语言题解</h2><p>递归算法很简单，只需要按照左右根的顺序递归即可，代码如下：<br><strong>不过需要注意的是，leetcode中尽量最好不要使用全局变量吧，因为leetcode网站的题目，所有的用例是共享全局变量的，也就是第一个用例执行完后，第二个用例会继承第一个用例执行后的全局变量的值，导致后续的用例执行失败</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     struct TreeNode *left;</span><br><span class="hljs-comment"> *     struct TreeNode *right;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Note: The returned array must be malloced, assume caller calls free().</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span>* <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> TreeNode* root, <span class="hljs-type">int</span>* returnSize)</span> &#123;<br>    <span class="hljs-type">int</span>* res = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">100</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-keyword">if</span> (res == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    *returnSize = <span class="hljs-number">0</span>;<br><br>    traverse(root, res, returnSize);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">traverse</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> TreeNode* root, <span class="hljs-type">int</span>* res, <span class="hljs-type">int</span>* returnSize)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    traverse(root-&gt;left, res, returnSize);<br>    res[*returnSize] = root-&gt;val;<br>    (*returnSize)++;<br>    traverse(root-&gt;right, res, returnSize);<br>&#125;<br></code></pre></td></tr></table></figure><p>迭代方法：</p><h2 id="三、C-题解"><a href="#三、C-题解" class="headerlink" title="三、C++题解"></a>三、C++题解</h2><p>递归方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-built_in">traverse</span>(root, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(TreeNode* root, vector&lt;<span class="hljs-type">int</span>&gt; &amp;res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-built_in">traverse</span>(root-&gt;left, res);<br>        res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-built_in">traverse</span>(root-&gt;right, res);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、题目描述&quot;&gt;&lt;a href=&quot;#一、题目描述&quot; class=&quot;headerlink&quot; title=&quot;一、题目描述&quot;&gt;&lt;/a&gt;一、题目描述&lt;/h2&gt;&lt;p&gt;给定一个二叉树的根节点root，返回它的中序遍历 。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;br&gt;&lt;img src=&quot;h</summary>
      
    
    
    
    <category term="二叉树" scheme="http://example.com/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
    <category term="二叉树" scheme="http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>二叉树算法核心纲领</title>
    <link href="http://example.com/posts/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%97%E6%B3%95%E6%A0%B8%E5%BF%83%E7%BA%B2%E9%A2%86.html"/>
    <id>http://example.com/posts/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%97%E6%B3%95%E6%A0%B8%E5%BF%83%E7%BA%B2%E9%A2%86.html</id>
    <published>2024-11-17T12:39:53.000Z</published>
    <updated>2024-11-20T15:23:33.350Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、二叉树基本概念"><a href="#一、二叉树基本概念" class="headerlink" title="一、二叉树基本概念"></a>一、二叉树基本概念</h2><p>二叉树<br>二叉搜索树<br>完全二叉树</p><h2 id="二、二叉树的前中后序遍历"><a href="#二、二叉树的前中后序遍历" class="headerlink" title="二、二叉树的前中后序遍历"></a>二、二叉树的前中后序遍历</h2><p>二叉树的前中后序对应的不只是三种顺序不同的列表。前中后序是遍历二叉树过程中处理每一个节点的三个特殊时间点，绝不仅仅是三个顺序不同的 List：<br>前序位置的代码在刚刚进入一个二叉树节点的时候执行；<br>后序位置的代码在将要离开一个二叉树节点的时候执行；<br>中序位置的代码在一个二叉树节点左子树都遍历完，即将开始遍历右子树的时候执行。</p><h2 id="三、二叉树解题的思维方式"><a href="#三、二叉树解题的思维方式" class="headerlink" title="三、二叉树解题的思维方式"></a>三、二叉树解题的思维方式</h2><p>1、是否可以通过遍历一遍二叉树得到答案？如果可以，用一个 traverse 函数配合外部变量来实现，这叫「遍历」的思维模式。</p><p>2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「分解问题」的思维模式。</p><p>无论使用哪种思维模式，你都需要思考：</p><p>如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前&#x2F;中&#x2F;后序位置）做？其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作。</p><h2 id="四、后序位置的特殊之处"><a href="#四、后序位置的特殊之处" class="headerlink" title="四、后序位置的特殊之处"></a>四、后序位置的特殊之处</h2><h2 id="五、二叉树的层序遍历"><a href="#五、二叉树的层序遍历" class="headerlink" title="五、二叉树的层序遍历"></a>五、二叉树的层序遍历</h2><h2 id="六、N叉树"><a href="#六、N叉树" class="headerlink" title="六、N叉树"></a>六、N叉树</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、二叉树基本概念&quot;&gt;&lt;a href=&quot;#一、二叉树基本概念&quot; class=&quot;headerlink&quot; title=&quot;一、二叉树基本概念&quot;&gt;&lt;/a&gt;一、二叉树基本概念&lt;/h2&gt;&lt;p&gt;二叉树&lt;br&gt;二叉搜索树&lt;br&gt;完全二叉树&lt;/p&gt;
&lt;h2 id=&quot;二、二叉树的前中</summary>
      
    
    
    
    <category term="二叉树" scheme="http://example.com/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
    <category term="二叉树" scheme="http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>dd命令</title>
    <link href="http://example.com/posts/dd%E5%91%BD%E4%BB%A4.html"/>
    <id>http://example.com/posts/dd%E5%91%BD%E4%BB%A4.html</id>
    <published>2024-11-17T06:15:34.000Z</published>
    <updated>2024-11-17T06:16:08.278Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>dd命令可以从一个文件或设备向另一个文件或设备进行复制</p></blockquote><h2 id="一、dd命令常用语法"><a href="#一、dd命令常用语法" class="headerlink" title="一、dd命令常用语法"></a>一、dd命令常用语法</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">dd <span class="hljs-attribute">if</span>=input_file <span class="hljs-attribute">of</span>=output_file [options]<br></code></pre></td></tr></table></figure><p>options是一些可选参数，if和of是必须有的</p><ul><li>if 表示输入文件</li><li>of 表示输出文件</li><li>bs：设置每次读取和写入的块大小（单位为字节或者是可以添加的后缀，如b、k、m等），默认为512字节。</li><li>count：设置要复制的块数。</li><li>iflag：设置输入选项，常用的选项有direct（绕过缓存直接读取）和sync（同步数据到磁盘）。</li><li>oflag：设置输出选项，常用的选项有direct（绕过缓存直接写入）和sync（同步数据到磁盘）。</li><li>skip&#x3D;xxx 是在备份时对if 后面的部分也就是原文件跳过多少块再开始备份；</li><li>seek&#x3D;xxx则是在备份时对of 后面的部分也就是目标文件跳过多少块再开始写</li></ul><h2 id="二、dd常用命令-读磁盘"><a href="#二、dd常用命令-读磁盘" class="headerlink" title="二、dd常用命令-读磁盘"></a>二、dd常用命令-读磁盘</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">dd <span class="hljs-keyword">if</span>=/dev/sde1 of=tee-test.img bs=<span class="hljs-number">1</span>M skip=<span class="hljs-number">4</span> count=<span class="hljs-number">16</span><br></code></pre></td></tr></table></figure><p>含义为从&#x2F;dev&#x2F;sde1设备起始位置，跳过4M，读取16M内容到tee-test.img中<br>想要查看tee-test.img，可以使用hexdump命令</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">hexdump -C tee-test.img<br></code></pre></td></tr></table></figure><p>只查看部分内容，例如前100个字节：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">hexdump -C -n <span class="hljs-number">100</span> tee-test.img<br></code></pre></td></tr></table></figure><h2 id="三、dd常用命令-写磁盘"><a href="#三、dd常用命令-写磁盘" class="headerlink" title="三、dd常用命令-写磁盘"></a>三、dd常用命令-写磁盘</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">dd <span class="hljs-attribute">if</span>=/dev/zero <span class="hljs-attribute">of</span>=/dev/sda <span class="hljs-attribute">bs</span>=1k <span class="hljs-attribute">seek</span>=8224 <span class="hljs-attribute">count</span>=32<br></code></pre></td></tr></table></figure><p>含义为从&#x2F;dev&#x2F;zero中也就是将后面的of目标文件写0，将&#x2F;dev&#x2F;sda设备的起始地址，跳过8224KB后，连续写入32KB 0数据</p><h2 id="四、通过fdisk-l确认分区的实际起始地址"><a href="#四、通过fdisk-l确认分区的实际起始地址" class="headerlink" title="四、通过fdisk -l确认分区的实际起始地址"></a>四、通过fdisk -l确认分区的实际起始地址</h2><p>使用<code>fdisk -l</code>显示磁盘分区情况</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap"><span class="hljs-comment"># fdisk -l</span><br><br>Disk /dev/sde: 19.16 GB,<span class="hljs-number"> 20577255424 </span>bytes,<span class="hljs-number"> 5023744 </span>sectors<br>Sector size (logical/physical):<span class="hljs-number"> 4096 </span>bytes /<span class="hljs-number"> 4096 </span>bytes<br><br>  Device  Start     End<br>/dev/sde1  <span class="hljs-number"> 256 </span>    131327<br><br></code></pre></td></tr></table></figure><p>这里显示sde1的起始地址为256，那么实际地址为：<br>256 ✖️ 4096 &#x3D; 1048576 &#x3D; 1024 ✖️ 1024 &#x3D; 1MB，所以sde1的位置为&#x2F;dev&#x2F;sde的起始地址偏移1M，其实起始1M，存放的应该是磁盘分区信息</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;dd命令可以从一个文件或设备向另一个文件或设备进行复制&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一、dd命令常用语法&quot;&gt;&lt;a href=&quot;#一、dd命令常用语法&quot; class=&quot;headerlink&quot; title=&quot;一、dd命令常用语法</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Makefile基础语法</title>
    <link href="http://example.com/posts/Makefile%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.html"/>
    <id>http://example.com/posts/Makefile%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.html</id>
    <published>2024-11-13T13:26:43.000Z</published>
    <updated>2024-11-13T15:54:38.496Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Makefile规则"><a href="#一、Makefile规则" class="headerlink" title="一、Makefile规则"></a>一、Makefile规则</h2><p>一个简单的 Makefile 文件包含一系列的“规则”，其样式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">目标(target)…: 依赖(prerequiries)…<br>&lt;tab&gt;命令(command)<br></code></pre></td></tr></table></figure><p>目标(target)通常是要生成的文件的名称，可以是可执行文件或OBJ文件， 也可以是一个执行的动作名称，诸如‘ <strong>clean</strong> ’。<br>依赖是用来产生目标的材料(比如源文件)，一个目标经常有几个依赖。<br>命令是生成目标时执行的动作，一个规则可以含有几个命令，每个命令占一行。<br><strong>注意</strong>：<br>每个命令行前面必须是一个 Tab 字符，即命令行第一个字符是 Tab。这是容易出错的地方。<br>通常，如果一个依赖发生了变化，就需要规则调用命令以更新或创建目标。 但是并非所有的目标都有依赖，例如，目标“ <strong>clean</strong> ”的作用是清除文件，它有依赖。</p><p>一个 Makefile 文件可以包含规则以外的其他文本，但一个简单的 Makefile 文件仅仅需要包含规则。虽然真正的规则比这里展示的例子复杂，但格式是完全一样的</p><h2 id="二、make命令介绍"><a href="#二、make命令介绍" class="headerlink" title="二、make命令介绍"></a>二、make命令介绍</h2><p>make 命令的使用：</p><p>执行 make 命令时，它会去当前目录下查找名为“Makefile”的文件，并根 据它的指示去执行操作，生成第一个目标。<br>我们可以使用“  <strong>-f</strong> ”选项指定文件，不再使用名为“Makefile”的文件，比 如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make -f Makefile.build<br></code></pre></td></tr></table></figure><p>我们可以使用“  <strong>-C</strong> ”选项指定目录，切换到其他目录里去，比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make -C a/ -f Makefile.build<br></code></pre></td></tr></table></figure><p>我们可以指定目标，不再默认生成第一个目标：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make -C a/ -f Makefile.build other_target<br></code></pre></td></tr></table></figure><h2 id="三、Makefile变量介绍"><a href="#三、Makefile变量介绍" class="headerlink" title="三、Makefile变量介绍"></a>三、Makefile变量介绍</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">A = xxx // 延时变量<br>B ?= xxx // 延时变量，只有第一次定义时赋值才成功；如果曾定义过，此赋值无效<br>C := xxx // 立即变量<br>D += yyy // 如果 D 在前面是延时变量，那么现在它还是延时变量；// 如果 D 在前面是立即变量，那么现在它还是立即变量<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/mengchao666/picture/main/blog20241113232347.png" alt="示例"></p><h2 id="四、Makefile通配符-一些符号"><a href="#四、Makefile通配符-一些符号" class="headerlink" title="四、Makefile通配符&amp;一些符号"></a>四、Makefile通配符&amp;一些符号</h2><p><strong>%通配符</strong></p><ul><li>%.o：表示所用的.o文件%.</li><li>%.c：表示所有的.c文件</li></ul><p><strong>$@：表示目标</strong><br><strong>$&lt;：表示第一个依赖文件</strong><br><strong>$^：表示所有依赖文件</strong></p><p><img src="https://raw.githubusercontent.com/mengchao666/picture/main/blog20241113232528.png" alt="示例代码"><br><img src="https://raw.githubusercontent.com/mengchao666/picture/main/blog20241113232545.png" alt="结果"></p><h2 id="五、Makefile假想目标"><a href="#五、Makefile假想目标" class="headerlink" title="五、Makefile假想目标"></a>五、Makefile假想目标</h2><p>我们的 Makefile 中有这样的目标：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Makefile"><span class="hljs-section">clean:</span><br>  rm -f <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> find -name &quot;\*.o&quot;)</span><br>  rm -f <span class="hljs-variable">$(TARGET)</span><br></code></pre></td></tr></table></figure><p>如果当前目录下恰好有名为“clean”的文件，那么执行“ <strong>make clean</strong> ”时它 就不会执行那些删除命令。<br>这时我们需要把“ <strong>clean</strong> ”这个目标，设置为“假想目标”，这样可以确保执行“ <strong>make clean</strong> ”时那些删除命令肯定可以得到执行。</p><p>使用下面的语句把“clean”设置为假想目标：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Makefile">.PHONY : clean<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/mengchao666/picture/main/blog20241113232733.png"><br><img src="https://raw.githubusercontent.com/mengchao666/picture/main/blog20241113232751.png"></p><h2 id="六、Makefile常用函数"><a href="#六、Makefile常用函数" class="headerlink" title="六、Makefile常用函数"></a>六、Makefile常用函数</h2><h3 id="1-foreach-var-list-text"><a href="#1-foreach-var-list-text" class="headerlink" title="1.$(foreach var,list,text)"></a>1.$(foreach var,list,text)</h3><p>简单地说，就是 for each var in list, change it to text。对 list 中的每一个 元素，取出来赋给 var，然后把 var 改为 text 所描述的形式。</p><h3 id="2-wildcard-pattern"><a href="#2-wildcard-pattern" class="headerlink" title="2.$(wildcard pattern)"></a>2.$(wildcard pattern)</h3><p>pattern 所列出的文件是否存在，把存在的文件都列出来。</p><h3 id="3-filter-pattern…-text"><a href="#3-filter-pattern…-text" class="headerlink" title="3.$(filter pattern…,text)"></a>3.$(filter pattern…,text)</h3><p>把 text 中符合 pattern 格式的内容，filter(过滤)出来、留下来。</p><h3 id="4-filter-out-pattern…-text"><a href="#4-filter-out-pattern…-text" class="headerlink" title="4.$(filter-out pattern…,text)"></a>4.$(filter-out pattern…,text)</h3><p>把 text 中符合 pattern 格式的内容，filter-out(过滤)出来、扔掉。</p><h3 id="5-patsubst-pattern-replacement-text"><a href="#5-patsubst-pattern-replacement-text" class="headerlink" title="5.$(patsubst pattern,replacement,text)"></a>5.$(patsubst pattern,replacement,text)</h3><p>寻找’ <strong>text</strong> ‘中符合格式’ pattern ‘的字，用’ r<strong>eplacement</strong> ‘替换它们。</p><p>‘ <strong>pattern</strong> ‘和’ <strong>replacement</strong> ‘中可以使用通配符。<br><img src="https://raw.githubusercontent.com/mengchao666/picture/main/blog20241113234721.png" alt="代码示例"></p><h2 id="七、Makefile的例子，包含子目录"><a href="#七、Makefile的例子，包含子目录" class="headerlink" title="七、Makefile的例子，包含子目录"></a>七、Makefile的例子，包含子目录</h2><h2 id="八、Makefile中的EXTRA-CFLAGS"><a href="#八、Makefile中的EXTRA-CFLAGS" class="headerlink" title="八、Makefile中的EXTRA_CFLAGS"></a>八、Makefile中的EXTRA_CFLAGS</h2><p>EXTRA_CFLAGS是Makefile中预定义的一个变量，作为CFLGAS，在make时可以传递给gcc一些编译选项等，如—O2</p><h3 id="EXTRA-CFLAGS-D等价于gcc-D，相当于在源代码中定义一个宏"><a href="#EXTRA-CFLAGS-D等价于gcc-D，相当于在源代码中定义一个宏" class="headerlink" title="EXTRA_CFLAGS +&#x3D; -D等价于gcc -D，相当于在源代码中定义一个宏"></a>EXTRA_CFLAGS +&#x3D; -D等价于gcc -D，相当于在源代码中定义一个宏</h3><p>假如定义一个宏CONFIG_DEBUG<br>在.c里面定义为：#define CONFIG_DEBUG<br>在makefile里定义为: CONFIG_DEBUG&#x3D;y</p><p>假如说我们想在makefile里为.c文件进入一个宏定义，就用EXTRA_CFLAGS +&#x3D; DCONFIG_DEBUG( 等价于在.c文件里定义#define CONFIG_DEBUG)</p><p>这时CONFIG_DEBUG&#x3D;y与EXTRA_CFLAGS +&#x3D; DCONFIG_DEBUG的区别应该你已经看出来的，前者是对makefile编译时用的，比如说obj-(CONFIG_DEBUG) +&#x3D; test.o,而后者则是对.c源文件里的用的</p><h2 id="九、Makefile编译内核驱动ko"><a href="#九、Makefile编译内核驱动ko" class="headerlink" title="九、Makefile编译内核驱动ko"></a>九、Makefile编译内核驱动ko</h2><p>内核源代码中obj-m表示以模块ko的方式编译<br>obj-y表示将源代码编译到内核源码中<br>在工作的过程中，经常需要编译一些Ko模块，如果是单个的c文件编译直接在内核源码里面 obj-y&#x3D;xxx.o就好<br>如果这个ko文件需要多个c文件共同编译生成的话，最好以如下的模板来完成编译较好</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">首先指定好编译链工具</span><br>CROSS_COMPILE=/opt/gcc-linaro-7.3.1-2018.05-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-<br><span class="hljs-meta prompt_">#</span><span class="language-bash">指定用哪个内核去编译</span><br>KDIR=/mnt/nfsroot/zhengshuai.zhu/IPCSDK/ipc-sdk-full-release/kernel-4.19<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">目标是编译成一个test.ko文件</span><br>obj-m += test.o<br><span class="hljs-meta prompt_">#</span><span class="language-bash">test.o文件由当前目录下n个c文件编译成</span><br>test-objs += ./*.o<br><span class="hljs-meta prompt_">#</span><span class="language-bash">包含当前目录下的头文件</span><br>INCLUDE_DIRS := $(addprefix -I,$(shell find ../ -type d ))<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">包含当前目录下，内核目录下的头文件</span><br>ccflags-y:= -I$(_KDIR)/include/linux/ -I$(PWD)/platform/<br><span class="hljs-meta prompt_">#</span><span class="language-bash">忽略一些编译警告，类如什么变量未使用</span><br>ccflags-y += -Wno-declaration-after-statement<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">添加c文件中的环境变量，比如在代码中会有</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">ifdef CONFIG_ANDROID</span> <br><span class="hljs-meta prompt_">#</span><span class="language-bash">xxxx</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">endif</span><br>ifeq ($(SYSTEM_VERSION),)<br>    ccflags-y += -DCONFIG_LINUX_OS<br>else<br>    ccflags-y += -DCONFIG_ANDROID<br>endif<br><br>all:<br>  make ARCH=$&#123;ARCH&#125; -C $(KDIR) M=$(PWD) modules<br><br>clean:<br>  make ARCH=$&#123;ARCH&#125; -C $(KDIR) M=$(PWD) clean<br></code></pre></td></tr></table></figure><p><code>make ARCH=$&#123;ARCH&#125; -C ( K D I R ) M = (KDIR) M=(KDIR)M=(PWD) modules</code><br>如何理解这句话?<br>-C的选项可以理解为:<br>进入所指定的位置，$(KDIR)，也就是内核目录中，目的是什么？ 去读取内核目录顶层的Makefile文件，相当于编译的时候 选择一个内核，我要用这个内核去编译。<br>因为你这个目录没有被配置到kernel config里面去，也就是说没有指定用哪个内核版本，有了 -C $(KDIR),就相当于选了内核，如果你选择了kernel-4.19目录下，或者 kernel-5.0目录下，</p><p>M&#x3D;的选项可以理解为:<br>当我选好内核版本后，我用这个 版本的内核 要去编译哪个目录，然后进入$(PWD)目录去编译当前指定的文件，将其编译成ko文件</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、Makefile规则&quot;&gt;&lt;a href=&quot;#一、Makefile规则&quot; class=&quot;headerlink&quot; title=&quot;一、Makefile规则&quot;&gt;&lt;/a&gt;一、Makefile规则&lt;/h2&gt;&lt;p&gt;一个简单的 Makefile 文件包含一系列的“规则”，其样</summary>
      
    
    
    
    <category term="Makefile" scheme="http://example.com/categories/Makefile/"/>
    
    
    <category term="Makefile" scheme="http://example.com/tags/Makefile/"/>
    
  </entry>
  
  <entry>
    <title>git提交流程</title>
    <link href="http://example.com/posts/1.html"/>
    <id>http://example.com/posts/1.html</id>
    <published>2024-11-11T14:12:51.000Z</published>
    <updated>2024-11-13T13:23:15.383Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Git下载及配置"><a href="#一、Git下载及配置" class="headerlink" title="一、Git下载及配置"></a>一、Git下载及配置</h2><p>我们第一次用git或者是新电脑上重新安装git工具的时候，都需要重新配置一下这个工具。</p><h3 id="Windows安装git"><a href="#Windows安装git" class="headerlink" title="Windows安装git"></a>Windows安装git</h3><p>官网网址<a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a>下载速度慢，且有可能安装不成功。 附快速下载地址（国内下载站）：<a href="https://github.com/waylau/git-for-win">https://github.com/waylau/git-for-win</a> 。 下载完之后，Windows中你在桌面上或者文件管理器中鼠标右键就可以看见Git Bash here，就是用来打开git bash的。</p><h3 id="Linux安装git"><a href="#Linux安装git" class="headerlink" title="Linux安装git"></a>Linux安装git</h3><p>linux在终端中，输入<code>sudo apt-get install git</code></p><p>下载完可以用命令<code>git --version</code>打印当前的git版本验证是否成功。下面正式开始Git的配置。</p><h3 id="配置git基本信息"><a href="#配置git基本信息" class="headerlink" title="配置git基本信息"></a>配置git基本信息</h3><p>接下来就是不管我们是第一次使用git工具，还是后来换电脑了，还是换成linux系统了，要想使用git都按照下面的方法配置一遍，才可以使用。 安装成功之后，在命令行中敲下如下命令 <code>git config --list</code>,显示当前的配置信息。 接下来设置提交仓库时的用户名信息 <code>git config --global user.name &quot;张三&quot;</code> 设置提交仓库是的邮箱信息 <code>git config --global user.email &quot;xxxxxxxx@qq.com&quot;</code> git设置关闭自动换行<code>git config --global core.autocrlf false</code> 为了保证文件的换行符是以安全的方法，避免windows与unix的换行符混用的情况，最好也加上这么一句 <code>git config --global core.safecrlf true</code></p><p>其实这些信息都在一个配置文件中，就在当前用户的主目录下边的**.gitconfig**文件中，也可以直接打开这个文件<code>cd ~,vim .gitconfig</code>进行编辑。</p><h3 id="git协议及秘钥配置"><a href="#git协议及秘钥配置" class="headerlink" title="git协议及秘钥配置"></a>git协议及秘钥配置</h3><p>git有四种协议：Git协议，http协议，本地协议，ssh协议。使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https。大部分都是用ssh协议。这个不仅速度快，而且不用每次提交输入密码，可谓是省心省力。 下面就说一下ssh配置过程。(这个协议配置的过程不可缺少，不然就用不了这种协议。)</p><p>首先生成 RSA 密钥对 :</p><p><code>ssh-keygen -t rsa -C &quot;xxxxxxxx@qq.com&quot;</code>注意格式，一定要正确。 ssh和-keygen无空格 此时在用户主目录下就会有一个.ssh隐藏文件，进入该目录有一个id_rsa.pub文件，cat命令查看这个文件，复制下来然后在 github网站添加公钥 ，方法如下 在 Github 网站添加公钥：在右上角头像处点settings进入设置，然后点SSH and GPG keys,进入之后点击New SSH key 粘贴进去，随便给这个秘钥命个名，方便管理就行了。钥匙显示黑色即可。 此时配置就完成了。接下来就可以使用git了。 执行此命令验证是否成功<code>ssh -T git@github.com</code> 成功显示为：Hi XXX! You’ve successfully authenticated, but GitHub does not provide shell access.</p><h2 id="二、先有本地库，后有远程库"><a href="#二、先有本地库，后有远程库" class="headerlink" title="二、先有本地库，后有远程库"></a>二、先有本地库，后有远程库</h2><h3 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h3><p>可以理解为版本库就是本地文件的一个目录，也叫仓库。可以用git来管理和回退等 创建版本库：找到一个想被管理的文件夹，进入到文件夹里，输入命令<code>git init</code>,此时git就可以管理这个目录了，并且在文件夹下多出来了一个.git的隐藏文件夹。这个.git就是版本库。 Git的版本库里存了很多东西，其中最重要的就是称为<strong>stage（或者叫index）的暂存区</strong>，还有Git为我们自动创建的<strong>第一个分支master</strong>，以及指向master的一个指针叫HEAD。 工作区：就是你在电脑里能看到的目录，比如刚才的文件夹就是一个工作区</p><h3 id="第一步：将文件添加到暂存区"><a href="#第一步：将文件添加到暂存区" class="headerlink" title="第一步：将文件添加到暂存区"></a>第一步：将文件添加到暂存区</h3><p>当我们想添加文件或者修改文件是需要添加到版本库中的，否则无法被git跟踪管理呀，所以当我们添加或者修改文件时，先要用<code>git add filename</code>添加到暂存区中，filename为<code>.</code>的时候代表当前目录下所有文件都添加到暂存区</p><h3 id="第二步：将文件提交到分支"><a href="#第二步：将文件提交到分支" class="headerlink" title="第二步：将文件提交到分支"></a>第二步：将文件提交到分支</h3><p><code>git commit -m &quot;message&quot;</code>，将文件提交到了分支。</p><h3 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h3><p>我们已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。 首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库，在Repository name填入项目名字，比如我们叫learngit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库 目前，在GitHub上的这个learngit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。</p><p>现在，我们根据GitHub的提示，在本地的learngit仓库下运行命令： <code>git remote add origin git@github.com:mengchao666/learngit.git</code> 请千万注意，把上面的mengchao666替换成你自己的GitHub账户名，否则，你在本地关联的就是我的远程库，你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。</p><p>添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。下一步，就可以把本地库的所有内容推送到远程库上： <code>git push -u origin master</code>把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样,从现在起，只要本地作了提交，就可以通过命令： <code>git push origin master</code></p><h2 id="三、先有远程库，后有本地库"><a href="#三、先有远程库，后有本地库" class="headerlink" title="三、先有远程库，后有本地库"></a>三、先有远程库，后有本地库</h2><p>现在，远程库已经准备好了，下一步是用命令git clone克隆一个本地库： <code>git clone git@github.com:mengchao666/learngit.git</code></p><p>可以使用<code>git clone -b branch</code>克隆指定的分支<br>后续修改可以使用如下命令提交</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git add .<br>git commit -m &quot;message&quot;<br>git push<br></code></pre></td></tr></table></figure><h2 id="四、企业开发流程"><a href="#四、企业开发流程" class="headerlink" title="四、企业开发流程"></a>四、企业开发流程</h2><p>在公司中做项目，一般项目代码都在公共仓库中，我们将其称为远程仓，一般按照如下步骤开发<br>1、将远程仓fork一份到个人仓<br>2、git clone个人仓代码到本地<br>3、使用<code>git remote -v</code>命令查看，此时本地关联的origin为个人仓<br>4、将本地代码关联到公司的远程仓，方便拉取最新代码，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git remote add upstream 公共仓地址<br></code></pre></td></tr></table></figure><p>此时再次使用<code>git remote -v</code>可以看到已经关联了upstream为远程仓<br>5、在开发需求和问题单修改之前，一般使用<code>git pull upstream</code>命令将远程仓代码更新至本地<br>6、修改代码后提交</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git add .<br>git commit -m &quot;message&quot;<br>git push origin branch<br></code></pre></td></tr></table></figure><p>7、在github&#x2F;gitlab页面创建MR申请，一般此时就可以了，找人加分就合入了<br>8、但是如果在创建MR申请时，提示冲突，此时需要解决冲突，解决如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git pull upstream<br></code></pre></td></tr></table></figure><p>此时会提示哪些文件有冲突，使用ctrl + F搜索<code>&gt;&gt;&gt;</code>,有此标志的即为冲突的地方，保留自己想要的代码，重新提交add commit push即可。</p><p>企业开发流程中，通常有远程仓新建了一个分支，个人远程仓没有此分支，需要更新，可按照如下步骤更新个人仓代码分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git checkout -b 新分支名称 upstream/新分支名称<br>git pull upstream 新分支名称<br>git push origin 新分支名称<br></code></pre></td></tr></table></figure><h2 id="五、代码回退等操作"><a href="#五、代码回退等操作" class="headerlink" title="五、代码回退等操作"></a>五、代码回退等操作</h2><h3 id="工作区的恢复-此时还没有add，代码回退"><a href="#工作区的恢复-此时还没有add，代码回退" class="headerlink" title="工作区的恢复(此时还没有add，代码回退)"></a>工作区的恢复(此时还没有add，代码回退)</h3><p>使用checkout恢复工作区 <code>git checkout .</code> （全部修改），<code>git checkout --file</code>改回一个文件,工作区—&gt;还没add</p><h3 id="add的撤销"><a href="#add的撤销" class="headerlink" title="add的撤销"></a>add的撤销</h3><p>git reset就是回退到指定的commitID,,使用git commit –amend时追加，不会生成新的commitID,是在原来的commitID基础上进行修改的。</p><p>HEAD指向当前最新的commitID，所以仅仅add,没有commit，此时的最新的commitID还是之前的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git reset --hard HEAD  // 不保留本地修改，回退<br>git reset --mixed HEAD //保留本地修改，可以重新git add<br></code></pre></td></tr></table></figure><p>简单理解git reset –xxx HEAD命令，就是将代码回退到了最新的一次commitID的代码状态，hard不保留本地代码工作空间的修改，而mixed保留</p><h3 id="commit后的撤销"><a href="#commit后的撤销" class="headerlink" title="commit后的撤销"></a>commit后的撤销</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">git reset --hard HEAD^ <span class="hljs-comment">// 不保留本地修改，回退到上一次的commitID状态</span><br>git reset --mixed HEAD^ <span class="hljs-comment">// 保留本地修改，撤销git commit,并且撤销git add</span><br>git reset --soft HEAD^ <span class="hljs-comment">//保留本地修改，撤销commit,不撤销add</span><br></code></pre></td></tr></table></figure><h2 id="六、git的一些其他操作"><a href="#六、git的一些其他操作" class="headerlink" title="六、git的一些其他操作"></a>六、git的一些其他操作</h2><p>查看分支：<code>git branch</code> <br>创建分支：<code>git branch &lt;name&gt;</code> <br>切换分支：<code>git checkout &lt;name&gt;</code>或者<code>git switch &lt;name&gt;</code> <br>创建+切换分支：<code>git checkout -b &lt;name&gt;</code>或者<code>git switch -c &lt;name&gt;</code> <br>合并某分支到当前分支：<code>git merge &lt;name&gt;</code> <br>删除分支：<code>git branch -d &lt;name&gt;</code></p><p>当代码仓有子仓情形下的一些命令：<br><code>git submodule update --init --remote</code><br><code>git submodule foreach git checkout branch</code><br><code>git submodule foreach --recursive</code></p><h2 id="七、同时提交两个MR"><a href="#七、同时提交两个MR" class="headerlink" title="七、同时提交两个MR"></a>七、同时提交两个MR</h2><p>当我们同时修改多个问题单，或者同时处理需求时，可能需要同时提交多分不同代码，此时处理方法如下：</p><p>1、本地创建一个新的分支来处理第一个MR</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git checkout -b mr1-branch<br></code></pre></td></tr></table></figure><p>2、提交第一个MR。<br>修改代码，git add、git commit，git push</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git push -u origin mr1-branch<br></code></pre></td></tr></table></figure><p>3、切换回原来的分支，以main分支为例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git checkout main<br></code></pre></td></tr></table></figure><p>4、创建第二个分支处理第二个MR</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git checkout -b mr2-branch<br></code></pre></td></tr></table></figure><p>5、提交第二个MR。<br>修改代码，git add、git commit，git push</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git push -u origin mr2-branch<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、Git下载及配置&quot;&gt;&lt;a href=&quot;#一、Git下载及配置&quot; class=&quot;headerlink&quot; title=&quot;一、Git下载及配置&quot;&gt;&lt;/a&gt;一、Git下载及配置&lt;/h2&gt;&lt;p&gt;我们第一次用git或者是新电脑上重新安装git工具的时候，都需要重新配置一下</summary>
      
    
    
    
    <category term="git" scheme="http://example.com/categories/git/"/>
    
    
    <category term="git" scheme="http://example.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>addr2line</title>
    <link href="http://example.com/posts/addr2line.html"/>
    <id>http://example.com/posts/addr2line.html</id>
    <published>2024-11-10T14:39:55.000Z</published>
    <updated>2024-11-11T14:02:20.475Z</updated>
    
    <content type="html"><![CDATA[<p>addr2line是一个将地址转换为文件名和行号的工具。给定可执行文件(如exe&#x2F;a.out等)中的地址或可重定位对象(如so,ko等)部分中的偏移量，它会使用调试信息来确定与之相关的文件名和行数。</p><p>用户态coredump，一般使用gdb调试接口，gdb一般封装了addr2line，可以解析文件名和行号。如果环境配置了不生成coredump，可以使用addr2line调试。<code>所以addr2line一般解析内核Call trace使用较多。</code></p><h2 id="一、使用方法"><a href="#一、使用方法" class="headerlink" title="一、使用方法"></a>一、使用方法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">基本用法：<br>addr2line [选项] [地址]<br></code></pre></td></tr></table></figure><p>常用选项如下：</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-e</td><td>设置输入文件名称，默认为a.out</td></tr><tr><td>-i</td><td>解析内联函数</td></tr><tr><td>-f</td><td>显示函数名</td></tr><tr><td>-C</td><td>解析函数名</td></tr><tr><td>-p</td><td>以好读的方式显示</td></tr></tbody></table><p>需要注意的是使用addr2line的时候，可执行文件或重定位文件一定是要带调试信息的</p><h2 id="二、用户态普通程序崩溃"><a href="#二、用户态普通程序崩溃" class="headerlink" title="二、用户态普通程序崩溃"></a>二、用户态普通程序崩溃</h2><p>使用方法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">addr2line -e 进程名 IP指令地址 -f<br></code></pre></td></tr></table></figure><p>用户态程序崩溃，当没有coredump产生时，可以使用如下方法<br>假设我们的程序名称为segfault,当程序崩溃是，dmesg日志中会有报错信息:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">[root@localhost ~]# dmesg<br>[134563.793925] segfault[53791]: segfault at 0 ip 0000000000400546 sp 00007fff7956af70 error 6 <span class="hljs-keyword">in</span> segfault[400000+1000]<br>[134563.793946] Code: 01 5d c3 90 c3 66 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 f3 0f 1e fa eb 8a 55 48 89 e5 48 c7 45 f8 00 00 00 00 48 8b 45 f8 &lt;c7&gt; 00 00 00 00 00 b8 00 00 00 00 5d c3 66 2e 0f 1f 84 00 00 00 00<br></code></pre></td></tr></table></figure><p>此时我们注意到IP指令地址为0000000000400546<br>使用addr2line查看程序挂的位置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">addr2line -e segfault <span class="hljs-number">0x0000000000400546</span> -f<br></code></pre></td></tr></table></figure><h2 id="三、动态链接库程序崩溃"><a href="#三、动态链接库程序崩溃" class="headerlink" title="三、动态链接库程序崩溃"></a>三、动态链接库程序崩溃</h2><p>使用方法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">addr2line -e 动态链接库名称 IP指令地址-基地址 -f<br></code></pre></td></tr></table></figure><p>假设我们有一个程序名为test，链接了一个libfoo.so，程序运行时崩溃，dmesg查看日志如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">[root@localhost ~]<span class="hljs-meta"># dmesg</span><br>[<span class="hljs-number">70567.416655</span>] test[<span class="hljs-number">27722</span>]: segfault at <span class="hljs-number">0</span> ip <span class="hljs-number">00007f</span>fa1f588580 sp <span class="hljs-number">00007f</span>ffa964e698 error <span class="hljs-number">6</span> in libfoo.so[<span class="hljs-number">7f</span>fa1f588000+<span class="hljs-number">1000</span>]<br>[<span class="hljs-number">70567.427374</span>] Code: ff e8 <span class="hljs-number">64</span> ff ff ff c6 <span class="hljs-number">05</span> bd <span class="hljs-number">0</span>a <span class="hljs-number">20</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">5</span>d c3 <span class="hljs-number">0f</span> <span class="hljs-number">1f</span> <span class="hljs-number">00</span> c3 <span class="hljs-number">0f</span> <span class="hljs-number">1f</span> <span class="hljs-number">80</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> f3 <span class="hljs-number">0f</span> <span class="hljs-number">1</span>e fa e9 <span class="hljs-number">77</span> ff ff ff <span class="hljs-number">0f</span> <span class="hljs-number">1f</span> <span class="hljs-number">80</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> &lt;c7&gt; <span class="hljs-number">04</span> <span class="hljs-number">25</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">0f</span> <span class="hljs-number">0b</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> f3 <span class="hljs-number">0f</span> <span class="hljs-number">1</span>e fa <span class="hljs-number">48</span> <span class="hljs-number">83</span><br></code></pre></td></tr></table></figure><p>根据日志可知，段错误发生的位置是在test进程调用的<code>libfoo.so</code>库里，我们先使用ldd找到动态库的位置，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">[root@localhost <span class="hljs-number">69</span>]<span class="hljs-meta"># ldd test</span><br>        linux-vdso.so<span class="hljs-number">.1</span> (<span class="hljs-number">0x00007ffd15b24000</span>)<br>        libfoo.so =&gt; ./libfoo.so (<span class="hljs-number">0x00007f8c01879000</span>)<br>        libc.so<span class="hljs-number">.6</span> =&gt; /lib64/libc.so<span class="hljs-number">.6</span> (<span class="hljs-number">0x00007f8c014b4000</span>)<br>        /lib64/ld-linux-x86<span class="hljs-number">-64.</span>so<span class="hljs-number">.2</span> (<span class="hljs-number">0x00007f8c01a7b000</span>)<br></code></pre></td></tr></table></figure><p>00007ffa1f588580为程序崩溃点IP指令地址，使用dmesg消息中ip指令地址减去动态库基址值(00007ffa1f588580 -7ffa1f588000&#x3D;580), 差值0x580为错误点在动态库的地址，调用addr2line, 注意-e参数后文件名改为动态库名:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">addr2line -e libfoo.so <span class="hljs-number">580</span> -f -p<br></code></pre></td></tr></table></figure><h2 id="四、内核驱动程序运行崩溃"><a href="#四、内核驱动程序运行崩溃" class="headerlink" title="四、内核驱动程序运行崩溃"></a>四、内核驱动程序运行崩溃</h2><p>使用方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">addr2line -e xxx.ko 地址偏移量 -f<br></code></pre></td></tr></table></figure><p>本人所用主机即属于一旦发生Oops，就会触发panic，因此总是无法查看Oops时的dmesg日志，经查阅资料，发现是内核参数panic_on_oops的原因导致的，因为该参数被设置为1，所以Oops会触发panic，从而导致机器总是死机重启，无法查看Oops时的dmesg日志。下面提供两种方法修改Oops内核参数，使其不会在Oops的时候触发panic导致死机重启。</p><p>方法一：修改 &#x2F;proc下内核参数文件内容，临时生效，重启后失效。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">echo <span class="hljs-number">0</span> &gt; /proc/sys/kernel/panic_on_oops<br></code></pre></td></tr></table></figure><p>方法二：修改&#x2F;etc&#x2F;sysctl.conf 文件的内核参数来永久更改。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# vi /etc/sysctl.conf<br>[root@localhost ~]# cat /etc/sysctl.conf<br><span class="hljs-meta prompt_"># </span><span class="language-bash">sysctl settings are defined through files <span class="hljs-keyword">in</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">/usr/lib/sysctl.d/, /run/sysctl.d/, and /etc/sysctl.d/.</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"></span><br><span class="language-bash"><span class="hljs-comment"># Vendors settings live in /usr/lib/sysctl.d/.</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">To override a whole file, create a new file with the same <span class="hljs-keyword">in</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">/etc/sysctl.d/ and put new settings there. To override</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">only specific settings, add a file with a lexically later</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">name <span class="hljs-keyword">in</span> /etc/sysctl.d/ and put new settings there.</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"></span><br><span class="language-bash"><span class="hljs-comment"># For more information, see sysctl.conf(5) and sysctl.d(5).</span></span><br>kernel.panic_on_oops=0<br>[root@localhost ~]# cat /proc/sys/kernel/panic_on_oops<br>1 <br>[root@localhost ~]# sysctl -p<br>kernel.panic_on_oops = 0<br>[root@localhost ~]#<br>[root@localhost ~]# cat /proc/sys/kernel/panic_on_oops<br>0<br></code></pre></td></tr></table></figure><p>假设内核某ko运行后发生如下错误：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c">[root@localhost ~]<span class="hljs-meta"># dmesg</span><br>[ <span class="hljs-number">1039.918606</span>] my_oops_init<br>[ <span class="hljs-number">1039.918616</span>] BUG: unable to handle kernel <span class="hljs-literal">NULL</span> pointer dereference at <span class="hljs-number">0000000000000000</span><br>[ <span class="hljs-number">1039.926442</span>] PGD <span class="hljs-number">0</span> P4D <span class="hljs-number">0</span><br>[ <span class="hljs-number">1039.928979</span>] Oops: <span class="hljs-number">0002</span> [#<span class="hljs-number">1</span>] SMP NOPTI<br>[ <span class="hljs-number">1039.932637</span>] CPU: <span class="hljs-number">34</span> PID: <span class="hljs-number">3843</span> Comm: insmod Kdump: loaded Tainted: G           OE    --------- -  - <span class="hljs-number">4.18</span><span class="hljs-number">.0</span><span class="hljs-number">-394.</span>el8.x86_64 #<span class="hljs-number">1</span><br>[ <span class="hljs-number">1039.943756</span>] Hardware name: New H3C Technologies Co., Ltd. H3C UniServer R4950 G5/RS45M2C9SB, BIOS <span class="hljs-number">5.37</span> <span class="hljs-number">09</span>/<span class="hljs-number">30</span>/<span class="hljs-number">2021</span><br>[ <span class="hljs-number">1039.954000</span>] RIP: <span class="hljs-number">0010</span>:do_oops+<span class="hljs-number">0x5</span>/<span class="hljs-number">0x11</span> [oops]<br>[ <span class="hljs-number">1039.958364</span>] Code: Unable to access opcode bytes at RIP <span class="hljs-number">0xffffffffc02e6fdb</span>.<br>[ <span class="hljs-number">1039.965231</span>] RSP: <span class="hljs-number">0018</span>:ffffb9d40a8c7cb0 EFLAGS: <span class="hljs-number">00010246</span><br>[ <span class="hljs-number">1039.970449</span>] RAX: <span class="hljs-number">000000000000000</span>c RBX: <span class="hljs-number">0000000000000000</span> RCX: <span class="hljs-number">0000000000000000</span><br>[ <span class="hljs-number">1039.977573</span>] RDX: <span class="hljs-number">0000000000000000</span> RSI: ffff98942ee96758 RDI: ffff98942ee96758<br>[ <span class="hljs-number">1039.984697</span>] RBP: ffffffffc02e7011 R08: <span class="hljs-number">0000000000000000</span> R09: c0000000ffff7fff<br>[ <span class="hljs-number">1039.991822</span>] R10: <span class="hljs-number">0000000000000001</span> R11: ffffb9d40a8c7ad8 R12: ffffffffc02e9000<br>[ <span class="hljs-number">1039.998944</span>] R13: ffffffffc02e9018 R14: ffffffffc02e91d0 R15: <span class="hljs-number">0000000000000000</span><br>[ <span class="hljs-number">1040.006069</span>] FS:  <span class="hljs-number">00007f</span>1b8d93b740(<span class="hljs-number">0000</span>) GS:ffff98942ee80000(<span class="hljs-number">0000</span>) knlGS:<span class="hljs-number">0000000000000000</span><br>[ <span class="hljs-number">1040.014145</span>] CS:  <span class="hljs-number">0010</span> DS: <span class="hljs-number">0000</span> ES: <span class="hljs-number">0000</span> CR0: <span class="hljs-number">0000000080050033</span><br>[ <span class="hljs-number">1040.019884</span>] CR2: ffffffffc02e6fdb CR3: <span class="hljs-number">0000000145</span>c02000 CR4: <span class="hljs-number">0000000000350</span>ee0<br>[ <span class="hljs-number">1040.027008</span>] Call Trace:<br>[ <span class="hljs-number">1040.029454</span>]  my_oops_init+<span class="hljs-number">0x16</span>/<span class="hljs-number">0x19</span> [oops]<br>[ <span class="hljs-number">1040.033550</span>]  do_one_initcall+<span class="hljs-number">0x46</span>/<span class="hljs-number">0x1d0</span><br>[ <span class="hljs-number">1040.037390</span>]  ? do_init_module+<span class="hljs-number">0x22</span>/<span class="hljs-number">0x220</span><br>[ <span class="hljs-number">1040.041318</span>]  ? kmem_cache_alloc_trace+<span class="hljs-number">0x142</span>/<span class="hljs-number">0x280</span><br>[ <span class="hljs-number">1040.046023</span>]  do_init_module+<span class="hljs-number">0x5a</span>/<span class="hljs-number">0x220</span><br>[ <span class="hljs-number">1040.049777</span>]  load_module+<span class="hljs-number">0x14ba</span>/<span class="hljs-number">0x17f0</span><br>[ <span class="hljs-number">1040.053530</span>]  ? __do_sys_finit_module+<span class="hljs-number">0xb1</span>/<span class="hljs-number">0x110</span><br>[ <span class="hljs-number">1040.058059</span>]  __do_sys_finit_module+<span class="hljs-number">0xb1</span>/<span class="hljs-number">0x110</span><br>[ <span class="hljs-number">1040.062411</span>]  do_syscall_64+<span class="hljs-number">0x5b</span>/<span class="hljs-number">0x1a0</span><br>[ <span class="hljs-number">1040.066077</span>]  entry_SYSCALL_64_after_hwframe+<span class="hljs-number">0x65</span>/<span class="hljs-number">0xca</span><br>[ <span class="hljs-number">1040.071130</span>] RIP: <span class="hljs-number">0033</span>:<span class="hljs-number">0x7f1b8c8509bd</span><br>[ <span class="hljs-number">1040.074701</span>] Code: ff c3 <span class="hljs-number">66</span> <span class="hljs-number">2</span>e <span class="hljs-number">0f</span> <span class="hljs-number">1f</span> <span class="hljs-number">84</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">90</span> f3 <span class="hljs-number">0f</span> <span class="hljs-number">1</span>e fa <span class="hljs-number">48</span> <span class="hljs-number">89</span> f8 <span class="hljs-number">48</span> <span class="hljs-number">89</span> f7 <span class="hljs-number">48</span> <span class="hljs-number">89</span> d6 <span class="hljs-number">48</span> <span class="hljs-number">89</span> ca <span class="hljs-number">4</span>d <span class="hljs-number">89</span> c2 <span class="hljs-number">4</span>d <span class="hljs-number">89</span> c8 <span class="hljs-number">4</span>c <span class="hljs-number">8b</span> <span class="hljs-number">4</span>c <span class="hljs-number">24</span> <span class="hljs-number">08</span> <span class="hljs-number">0f</span> <span class="hljs-number">05</span> &lt;<span class="hljs-number">48</span>&gt; <span class="hljs-number">3</span>d <span class="hljs-number">01</span> f0 ff ff <span class="hljs-number">73</span> <span class="hljs-number">01</span> c3 <span class="hljs-number">48</span> <span class="hljs-number">8b</span> <span class="hljs-number">0</span>d <span class="hljs-number">9b</span> <span class="hljs-number">54</span> <span class="hljs-number">38</span> <span class="hljs-number">00</span> f7 d8 <span class="hljs-number">64</span> <span class="hljs-number">89</span> <span class="hljs-number">01</span> <span class="hljs-number">48</span><br>[ <span class="hljs-number">1040.093446</span>] RSP: <span class="hljs-number">002b</span>:<span class="hljs-number">00007f</span>fc4df0a968 EFLAGS: <span class="hljs-number">00000246</span> ORIG_RAX: <span class="hljs-number">0000000000000139</span><br>[ <span class="hljs-number">1040.101004</span>] RAX: ffffffffffffffda RBX: <span class="hljs-number">00005653f</span>b1997d0 RCX: <span class="hljs-number">00007f</span>1b8c8509bd<br>[ <span class="hljs-number">1040.108126</span>] RDX: <span class="hljs-number">0000000000000000</span> RSI: <span class="hljs-number">00005653f</span>980c8b6 RDI: <span class="hljs-number">0000000000000003</span><br>[ <span class="hljs-number">1040.115251</span>] RBP: <span class="hljs-number">00005653f</span>980c8b6 R08: <span class="hljs-number">0000000000000000</span> R09: <span class="hljs-number">00007f</span>1b8cbd9760<br>[ <span class="hljs-number">1040.122375</span>] R10: <span class="hljs-number">0000000000000003</span> R11: <span class="hljs-number">0000000000000246</span> R12: <span class="hljs-number">0000000000000000</span><br>[ <span class="hljs-number">1040.129498</span>] R13: <span class="hljs-number">00005653f</span>b1997b0 R14: <span class="hljs-number">0000000000000000</span> R15: <span class="hljs-number">0000000000000000</span><br>[ <span class="hljs-number">1040.136623</span>] Modules linked in: oops(OE+) binfmt_misc xt_CHECKSUM ipt_MASQUERADE xt_conntrack ipt_REJECT nf_reject_ipv4 nft_compat nft_counter nft_chain_nat nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 nf_tables nfnetlink rpcsec_gss_krb5 auth_rpcgss nfsv4 dns_resolver nfs lockd grace fscache bridge stp llc intel_rapl_msr intel_rapl_common amd64_edac_mod edac_mce_amd amd_energy kvm_amd kvm irqbypass ipmi_ssif pcspkr crct10dif_pclmul crc32_pclmul ghash_clmulni_intel rapl joydev ccp sp5100_tco i2c_piix4 k10temp ptdma acpi_ipmi ipmi_si sunrpc vfat fat xfs libcrc32c sd_mod t10_pi sg crc32c_intel ast drm_vram_helper drm_kms_helper syscopyarea sysfillrect sysimgblt fb_sys_fops drm_ttm_helper ttm ahci drm libahci <span class="hljs-title function_">nfp</span><span class="hljs-params">(OE)</span> igb libata dca i2c_algo_bit dm_mirror dm_region_hash dm_log dm_mod ipmi_devintf ipmi_msghandler<br>[ 1040.208357] CR2: 0000000000000000<br>[ 1040.211668] ---[ end trace b69c1e8998070273 ]---<br>[ 1040.230185] RIP: 0010:do_oops+0x5/0x11 [oops]<br>[ 1040.234540] Code: Unable to access opcode bytes at RIP 0xffffffffc02e6fdb.<br>[ 1040.241409] RSP: 0018:ffffb9d40a8c7cb0 EFLAGS: 00010246<br>[ 1040.246626] RAX: 000000000000000c RBX: 0000000000000000 RCX: 0000000000000000<br>[ 1040.253750] RDX: 0000000000000000 RSI: ffff98942ee96758 RDI: ffff98942ee96758<br>[ 1040.260876] RBP: ffffffffc02e7011 R08: 0000000000000000 R09: c0000000ffff7fff<br>[ 1040.267998] R10: 0000000000000001 R11: ffffb9d40a8c7ad8 R12: ffffffffc02e9000<br>[ 1040.275124] R13: ffffffffc02e9018 R14: ffffffffc02e91d0 R15: 0000000000000000<br>[ 1040.282247] FS:  00007<span class="hljs-title function_">f1b8d93b740</span><span class="hljs-params">(<span class="hljs-number">0000</span>)</span> GS:<span class="hljs-title function_">ffff98942ee80000</span><span class="hljs-params">(<span class="hljs-number">0000</span>)</span> knlGS:0000000000000000<br>[ 1040.290323] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033<br>[ 1040.296061] CR2: ffffffffc02e6fdb CR3: 0000000145c02000 CR4: 0000000000350ee0<br></code></pre></td></tr></table></figure><p>Oops: 0002 – 错误码<br>Oops: [#1] – Oops发生的次数<br>CPU: 34 – 表示Oops是发生在CPU34上<br>关键信息如下，这里提示在操作函数do_oops的时候出现异常，地址偏移量0x5：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">[ 1039.954000] RIP: 0010:do_oops+0x5/0x11 [oops]<br></code></pre></td></tr></table></figure><p>为什么这条信息关键? 因为其含有指令指针RIP；指令指针IP&#x2F;EIP&#x2F;RIP的基本功能是指向要执行的下一条地址。在8080 8位微处理器上的寄存器名称是PC（program counter，程序计数器），从8086起，被称为IP（instruction pointer，指令指针）。主要区别在与PC指向正在执行的指令，而IP指向下一条指令。在64位模式下，指令指针是RIP寄存器。这个寄存器保存着下一条要执行的指令的64位地址偏移量。64位模式支持一种新的寻址模式，被称为RIP相对寻址。使用这个模式，有效地址的计算方式变为RIP（指向下一条指令）加上位移量。</p><p>由此可以看出内核执行到do_oops+0x5&#x2F;0x11这个地址的时候出现异常，我们只需要找到这个地址对应的代码即可。</p><p>do_oops指示了是在do_oops函数中出现的异常， 0x5表示出错的地址偏移量， 0x11表示do_oops函数的大小。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">打印格式：do_oops+<span class="hljs-number">0x5</span>/<span class="hljs-number">0x11</span> [oops] <br>即：symbol+offset/size [module] <br>symbol: 符号 offset：地址偏移量 size：函数的长度 module: 所属内核模块<br></code></pre></td></tr></table></figure><p>使用如下命令解析</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">addr2line -e oops.ko <span class="hljs-number">0x5</span> -f -p<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;addr2line是一个将地址转换为文件名和行号的工具。给定可执行文件(如exe&amp;#x2F;a.out等)中的地址或可重定位对象(如so,ko等)部分中的偏移量，它会使用调试信息来确定与之相关的文件名和行数。&lt;/p&gt;
&lt;p&gt;用户态coredump，一般使用gdb调试接口，g</summary>
      
    
    
    
    <category term="Linux工具" scheme="http://example.com/categories/Linux%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="Linux工具" scheme="http://example.com/tags/Linux%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>个人博客网站部署&amp;文章提交</title>
    <link href="http://example.com/posts/%E7%BD%91%E7%AB%99%E9%83%A8%E7%BD%B2-%E5%86%99%E4%BD%9C.html"/>
    <id>http://example.com/posts/%E7%BD%91%E7%AB%99%E9%83%A8%E7%BD%B2-%E5%86%99%E4%BD%9C.html</id>
    <published>2024-11-10T07:38:23.000Z</published>
    <updated>2024-11-10T14:44:31.349Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、网站部署"><a href="#一、网站部署" class="headerlink" title="一、网站部署"></a>一、网站部署</h2><p>1、首先在github上创建自己的一个仓库，仓库名字为mengchao666.github.io</p><p>2、将<a href="https://github.com/mengchao666/blog-demo">https://github.com/mengchao666/blog-demo</a>代码下载到本地，用VScode打开</p><p>3、安装node.js，pnpm，hexo</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">node.js官网安装：https://nodejs.cn/download/<br>pnpm安装：npm install pnpm -g<br>hexo安装：npm install hexo-cli -g<br></code></pre></td></tr></table></figure><p>4、在Vscode打开的项目终端下执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">pnpm i<br>pnpm dev<br></code></pre></td></tr></table></figure><p>5、使用hexo deploy命令部署，打开mengchao666.github.io即可</p><p>6、新增文章使用如下命令新增</p><p>例如：hexo new post “网站部署”</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo new post &lt;title&gt;<br></code></pre></td></tr></table></figure><p>7、新增文章后，使用命令部署提交到github</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo clean<br>hexo deploy<br></code></pre></td></tr></table></figure><p>更多操作可以参考：<a href="https://xaoxuu.com/wiki/stellar/topic.html">https://xaoxuu.com/wiki/stellar/topic.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、网站部署&quot;&gt;&lt;a href=&quot;#一、网站部署&quot; class=&quot;headerlink&quot; title=&quot;一、网站部署&quot;&gt;&lt;/a&gt;一、网站部署&lt;/h2&gt;&lt;p&gt;1、首先在github上创建自己的一个仓库，仓库名字为mengchao666.github.io&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="网站" scheme="http://example.com/categories/%E7%BD%91%E7%AB%99/"/>
    
    
    <category term="网站" scheme="http://example.com/tags/%E7%BD%91%E7%AB%99/"/>
    
  </entry>
  
</feed>
