<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>mengchao666</title>
  
  <subtitle>个人记录</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-11-17T13:42:00.990Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>96、不同的二叉搜索树</title>
    <link href="http://example.com/posts/96%E3%80%81%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html"/>
    <id>http://example.com/posts/96%E3%80%81%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html</id>
    <published>2024-11-17T12:57:49.000Z</published>
    <updated>2024-11-17T13:42:00.990Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。</p><p>示例 1：<br><img src="https://raw.githubusercontent.com/mengchao666/picture/main/blog20241117205823.png"><br>输入：n &#x3D; 3<br>输出：5<br>示例 2：</p><p>输入：n &#x3D; 1<br>输出：1</p><p>提示：<br>1 &lt;&#x3D; n &lt;&#x3D; 19</p><h2 id="二、代码"><a href="#二、代码" class="headerlink" title="二、代码"></a>二、代码</h2><p>解法一：</p><p>这种题目，我一般是计算出前面多个例子，根据计算出来的多个例子，进行归纳总结，利用数学归纳法，找规律，推算出第n个的结果，然后利用类似如下方法，根据第0个，第1个，第2个……，以此计算出第n个。<br>n&#x3D;1,搜索二叉树种数：1 ,只有一个节点，所以为1<br>n&#x3D;2,搜索二叉树种数：2 ,只有二个节点，要么1为根节点，要么2为根节点，所以结果为2<br>n&#x3D;3,搜索二叉树种数：5 ,有三个节点<br>(1)、1为根节点，另外两个节点，均大于1，根据二叉搜索树的性质，大于根节点的数字，即另外两个节点2和3只能作为右子树，再作为一个整体，构成二叉搜索树，此时另外两个节点构成结果等同于n&#x3D;2时的结果，为2<br>(2)、2为根节点，根据二叉搜索树性质，1只能作为左子树，3只能作为右子树，只有一种情况，所以结果为1<br>(3)、3为根节点，根据二叉搜索树性质，1和2只能作为左子树,1和2作为一个整体再构成二叉搜索树，此时与(1)一样，结果等于n&#x3D;2时的结果为2<br>所以n&#x3D;3时，搜索二叉树种数为2+1+2&#x3D;5<br>n&#x3D;4,搜索二叉树种数：14<br>(1)、1为根节点，另外三个节点，均大于1，另外节点只能作为右子树，其他节点再作为一个整体，构成二叉搜索树，此时另外三个节点构成结果等同于n&#x3D;3时的结果，为5<br>(2)、2为根节点，根据二叉搜索树性质，1只能作为左子树，3,4只能作为右子树，此时进行排列组合，即为n&#x3D;1和n&#x3D;2的结果相乘，为2<br>(3)、3为根节点，结果等于(2)时的结果为2<br>(3)、4为根节点，结果等于(1)时的结果为5<br>n&#x3D;5,搜索二叉树种数：42<br>……<br>所以我总结规律为当输入数字为100,结果应该为<code>n=0 * n=99 + n=1 * n=98 + …… + n=99 * n=0</code>, n&#x3D;0时为1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">3</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            res += (<span class="hljs-built_in">numTrees</span>(i) * <span class="hljs-built_in">numTrees</span>(n- <span class="hljs-number">1</span> - i));<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>解法二：<br>解法一比较耗时，所以在解法一基础上进行优化，可以把中间的结果都保存到数组nums中，后续就不需要每次都遍历才拿到结果了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nums</span><span class="hljs-params">(<span class="hljs-number">20</span>, <span class="hljs-number">0</span>)</span></span>;<br>        nums[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">traverse</span>(n, nums);<br>        <span class="hljs-keyword">return</span> nums[n];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">traverse</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (nums[n] != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> nums[n];<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            nums[n] += (<span class="hljs-built_in">traverse</span>(i, nums) * <span class="hljs-built_in">traverse</span>(n- <span class="hljs-number">1</span> - i, nums));<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>解法3：<br>动态规划，后续再写具体思路吧：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">// 二叉搜索数的特征，左子树小于根，右子树大于根</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n<span class="hljs-number">+1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;  <span class="hljs-comment">// dp[0]初始化为1</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)  <span class="hljs-comment">// 从1...n的二叉搜索数数目</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=i; j++)  <span class="hljs-comment">// 逐步选用1...n作为根节点</span><br>                dp[i]+=dp[j<span class="hljs-number">-1</span>]*dp[i-j];  <span class="hljs-comment">// 左侧j-1个数，右侧i-j个数</span><br>        <span class="hljs-keyword">return</span> dp[n]; <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、题目描述&quot;&gt;&lt;a href=&quot;#一、题目描述&quot; class=&quot;headerlink&quot; title=&quot;一、题目描述&quot;&gt;&lt;/a&gt;一、题目描述&lt;/h2&gt;&lt;p&gt;给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>94、二叉树的中序遍历</title>
    <link href="http://example.com/posts/94%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.html"/>
    <id>http://example.com/posts/94%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.html</id>
    <published>2024-11-17T12:41:04.000Z</published>
    <updated>2024-11-17T12:49:40.256Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个二叉树的根节点root，返回它的中序遍历 。</p><p>示例 1：<br><img src="https://raw.githubusercontent.com/mengchao666/picture/main/blog20241117204222.png"></p><p>输入：root &#x3D; [1,null,2,3]<br>输出：[1,3,2]<br>示例 2：</p><p>输入：root &#x3D; []<br>输出：[]<br>示例 3：</p><p>输入：root &#x3D; [1]<br>输出：[1]</p><p>提示：</p><p>树中节点数目在范围 [0, 100] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100</p><p>进阶: 递归算法很简单，你可以通过迭代算法完成吗？</p><h2 id="二、C语言题解"><a href="#二、C语言题解" class="headerlink" title="二、C语言题解"></a>二、C语言题解</h2><p>递归算法很简单，只需要按照左右根的顺序递归即可，代码如下：<br><strong>不过需要注意的是，leetcode中尽量最好不要使用全局变量吧，因为leetcode网站的题目，所有的用例是共享全局变量的，也就是第一个用例执行完后，第二个用例会继承第一个用例执行后的全局变量的值，导致后续的用例执行失败</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     struct TreeNode *left;</span><br><span class="hljs-comment"> *     struct TreeNode *right;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Note: The returned array must be malloced, assume caller calls free().</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span>* <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> TreeNode* root, <span class="hljs-type">int</span>* returnSize)</span> &#123;<br>    <span class="hljs-type">int</span>* res = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">100</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-keyword">if</span> (res == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    *returnSize = <span class="hljs-number">0</span>;<br><br>    traverse(root, res, returnSize);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">traverse</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> TreeNode* root, <span class="hljs-type">int</span>* res, <span class="hljs-type">int</span>* returnSize)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    traverse(root-&gt;left, res, returnSize);<br>    res[*returnSize] = root-&gt;val;<br>    (*returnSize)++;<br>    traverse(root-&gt;right, res, returnSize);<br>&#125;<br></code></pre></td></tr></table></figure><p>迭代方法：</p><h2 id="三、C-题解"><a href="#三、C-题解" class="headerlink" title="三、C++题解"></a>三、C++题解</h2><p>递归方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-built_in">traverse</span>(root, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(TreeNode* root, vector&lt;<span class="hljs-type">int</span>&gt; &amp;res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-built_in">traverse</span>(root-&gt;left, res);<br>        res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-built_in">traverse</span>(root-&gt;right, res);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、题目描述&quot;&gt;&lt;a href=&quot;#一、题目描述&quot; class=&quot;headerlink&quot; title=&quot;一、题目描述&quot;&gt;&lt;/a&gt;一、题目描述&lt;/h2&gt;&lt;p&gt;给定一个二叉树的根节点root，返回它的中序遍历 。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;br&gt;&lt;img src=&quot;h</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>二叉树算法</title>
    <link href="http://example.com/posts/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%97%E6%B3%95.html"/>
    <id>http://example.com/posts/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%97%E6%B3%95.html</id>
    <published>2024-11-17T12:39:53.000Z</published>
    <updated>2024-11-17T12:40:25.890Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>dd命令</title>
    <link href="http://example.com/posts/dd%E5%91%BD%E4%BB%A4.html"/>
    <id>http://example.com/posts/dd%E5%91%BD%E4%BB%A4.html</id>
    <published>2024-11-17T06:15:34.000Z</published>
    <updated>2024-11-17T06:16:08.278Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>dd命令可以从一个文件或设备向另一个文件或设备进行复制</p></blockquote><h2 id="一、dd命令常用语法"><a href="#一、dd命令常用语法" class="headerlink" title="一、dd命令常用语法"></a>一、dd命令常用语法</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">dd <span class="hljs-attribute">if</span>=input_file <span class="hljs-attribute">of</span>=output_file [options]<br></code></pre></td></tr></table></figure><p>options是一些可选参数，if和of是必须有的</p><ul><li>if 表示输入文件</li><li>of 表示输出文件</li><li>bs：设置每次读取和写入的块大小（单位为字节或者是可以添加的后缀，如b、k、m等），默认为512字节。</li><li>count：设置要复制的块数。</li><li>iflag：设置输入选项，常用的选项有direct（绕过缓存直接读取）和sync（同步数据到磁盘）。</li><li>oflag：设置输出选项，常用的选项有direct（绕过缓存直接写入）和sync（同步数据到磁盘）。</li><li>skip&#x3D;xxx 是在备份时对if 后面的部分也就是原文件跳过多少块再开始备份；</li><li>seek&#x3D;xxx则是在备份时对of 后面的部分也就是目标文件跳过多少块再开始写</li></ul><h2 id="二、dd常用命令-读磁盘"><a href="#二、dd常用命令-读磁盘" class="headerlink" title="二、dd常用命令-读磁盘"></a>二、dd常用命令-读磁盘</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">dd <span class="hljs-keyword">if</span>=/dev/sde1 of=tee-test.img bs=<span class="hljs-number">1</span>M skip=<span class="hljs-number">4</span> count=<span class="hljs-number">16</span><br></code></pre></td></tr></table></figure><p>含义为从&#x2F;dev&#x2F;sde1设备起始位置，跳过4M，读取16M内容到tee-test.img中<br>想要查看tee-test.img，可以使用hexdump命令</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">hexdump -C tee-test.img<br></code></pre></td></tr></table></figure><p>只查看部分内容，例如前100个字节：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">hexdump -C -n <span class="hljs-number">100</span> tee-test.img<br></code></pre></td></tr></table></figure><h2 id="三、dd常用命令-写磁盘"><a href="#三、dd常用命令-写磁盘" class="headerlink" title="三、dd常用命令-写磁盘"></a>三、dd常用命令-写磁盘</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">dd <span class="hljs-attribute">if</span>=/dev/zero <span class="hljs-attribute">of</span>=/dev/sda <span class="hljs-attribute">bs</span>=1k <span class="hljs-attribute">seek</span>=8224 <span class="hljs-attribute">count</span>=32<br></code></pre></td></tr></table></figure><p>含义为从&#x2F;dev&#x2F;zero中也就是将后面的of目标文件写0，将&#x2F;dev&#x2F;sda设备的起始地址，跳过8224KB后，连续写入32KB 0数据</p><h2 id="四、通过fdisk-l确认分区的实际起始地址"><a href="#四、通过fdisk-l确认分区的实际起始地址" class="headerlink" title="四、通过fdisk -l确认分区的实际起始地址"></a>四、通过fdisk -l确认分区的实际起始地址</h2><p>使用<code>fdisk -l</code>显示磁盘分区情况</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap"><span class="hljs-comment"># fdisk -l</span><br><br>Disk /dev/sde: 19.16 GB,<span class="hljs-number"> 20577255424 </span>bytes,<span class="hljs-number"> 5023744 </span>sectors<br>Sector size (logical/physical):<span class="hljs-number"> 4096 </span>bytes /<span class="hljs-number"> 4096 </span>bytes<br><br>  Device  Start     End<br>/dev/sde1  <span class="hljs-number"> 256 </span>    131327<br><br></code></pre></td></tr></table></figure><p>这里显示sde1的起始地址为256，那么实际地址为：<br>256 ✖️ 4096 &#x3D; 1048576 &#x3D; 1024 ✖️ 1024 &#x3D; 1MB，所以sde1的位置为&#x2F;dev&#x2F;sde的起始地址偏移1M，其实起始1M，存放的应该是磁盘分区信息</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;dd命令可以从一个文件或设备向另一个文件或设备进行复制&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一、dd命令常用语法&quot;&gt;&lt;a href=&quot;#一、dd命令常用语法&quot; class=&quot;headerlink&quot; title=&quot;一、dd命令常用语法</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Makefile基础语法</title>
    <link href="http://example.com/posts/Makefile%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.html"/>
    <id>http://example.com/posts/Makefile%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.html</id>
    <published>2024-11-13T13:26:43.000Z</published>
    <updated>2024-11-13T15:54:38.496Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Makefile规则"><a href="#一、Makefile规则" class="headerlink" title="一、Makefile规则"></a>一、Makefile规则</h2><p>一个简单的 Makefile 文件包含一系列的“规则”，其样式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">目标(target)…: 依赖(prerequiries)…<br>&lt;tab&gt;命令(command)<br></code></pre></td></tr></table></figure><p>目标(target)通常是要生成的文件的名称，可以是可执行文件或OBJ文件， 也可以是一个执行的动作名称，诸如‘ <strong>clean</strong> ’。<br>依赖是用来产生目标的材料(比如源文件)，一个目标经常有几个依赖。<br>命令是生成目标时执行的动作，一个规则可以含有几个命令，每个命令占一行。<br><strong>注意</strong>：<br>每个命令行前面必须是一个 Tab 字符，即命令行第一个字符是 Tab。这是容易出错的地方。<br>通常，如果一个依赖发生了变化，就需要规则调用命令以更新或创建目标。 但是并非所有的目标都有依赖，例如，目标“ <strong>clean</strong> ”的作用是清除文件，它有依赖。</p><p>一个 Makefile 文件可以包含规则以外的其他文本，但一个简单的 Makefile 文件仅仅需要包含规则。虽然真正的规则比这里展示的例子复杂，但格式是完全一样的</p><h2 id="二、make命令介绍"><a href="#二、make命令介绍" class="headerlink" title="二、make命令介绍"></a>二、make命令介绍</h2><p>make 命令的使用：</p><p>执行 make 命令时，它会去当前目录下查找名为“Makefile”的文件，并根 据它的指示去执行操作，生成第一个目标。<br>我们可以使用“  <strong>-f</strong> ”选项指定文件，不再使用名为“Makefile”的文件，比 如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make -f Makefile.build<br></code></pre></td></tr></table></figure><p>我们可以使用“  <strong>-C</strong> ”选项指定目录，切换到其他目录里去，比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make -C a/ -f Makefile.build<br></code></pre></td></tr></table></figure><p>我们可以指定目标，不再默认生成第一个目标：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make -C a/ -f Makefile.build other_target<br></code></pre></td></tr></table></figure><h2 id="三、Makefile变量介绍"><a href="#三、Makefile变量介绍" class="headerlink" title="三、Makefile变量介绍"></a>三、Makefile变量介绍</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">A = xxx // 延时变量<br>B ?= xxx // 延时变量，只有第一次定义时赋值才成功；如果曾定义过，此赋值无效<br>C := xxx // 立即变量<br>D += yyy // 如果 D 在前面是延时变量，那么现在它还是延时变量；// 如果 D 在前面是立即变量，那么现在它还是立即变量<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/mengchao666/picture/main/blog20241113232347.png" alt="示例"></p><h2 id="四、Makefile通配符-一些符号"><a href="#四、Makefile通配符-一些符号" class="headerlink" title="四、Makefile通配符&amp;一些符号"></a>四、Makefile通配符&amp;一些符号</h2><p><strong>%通配符</strong></p><ul><li>%.o：表示所用的.o文件%.</li><li>%.c：表示所有的.c文件</li></ul><p><strong>$@：表示目标</strong><br><strong>$&lt;：表示第一个依赖文件</strong><br><strong>$^：表示所有依赖文件</strong></p><p><img src="https://raw.githubusercontent.com/mengchao666/picture/main/blog20241113232528.png" alt="示例代码"><br><img src="https://raw.githubusercontent.com/mengchao666/picture/main/blog20241113232545.png" alt="结果"></p><h2 id="五、Makefile假想目标"><a href="#五、Makefile假想目标" class="headerlink" title="五、Makefile假想目标"></a>五、Makefile假想目标</h2><p>我们的 Makefile 中有这样的目标：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Makefile"><span class="hljs-section">clean:</span><br>  rm -f <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> find -name &quot;\*.o&quot;)</span><br>  rm -f <span class="hljs-variable">$(TARGET)</span><br></code></pre></td></tr></table></figure><p>如果当前目录下恰好有名为“clean”的文件，那么执行“ <strong>make clean</strong> ”时它 就不会执行那些删除命令。<br>这时我们需要把“ <strong>clean</strong> ”这个目标，设置为“假想目标”，这样可以确保执行“ <strong>make clean</strong> ”时那些删除命令肯定可以得到执行。</p><p>使用下面的语句把“clean”设置为假想目标：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Makefile">.PHONY : clean<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/mengchao666/picture/main/blog20241113232733.png"><br><img src="https://raw.githubusercontent.com/mengchao666/picture/main/blog20241113232751.png"></p><h2 id="六、Makefile常用函数"><a href="#六、Makefile常用函数" class="headerlink" title="六、Makefile常用函数"></a>六、Makefile常用函数</h2><h3 id="1-foreach-var-list-text"><a href="#1-foreach-var-list-text" class="headerlink" title="1.$(foreach var,list,text)"></a>1.$(foreach var,list,text)</h3><p>简单地说，就是 for each var in list, change it to text。对 list 中的每一个 元素，取出来赋给 var，然后把 var 改为 text 所描述的形式。</p><h3 id="2-wildcard-pattern"><a href="#2-wildcard-pattern" class="headerlink" title="2.$(wildcard pattern)"></a>2.$(wildcard pattern)</h3><p>pattern 所列出的文件是否存在，把存在的文件都列出来。</p><h3 id="3-filter-pattern…-text"><a href="#3-filter-pattern…-text" class="headerlink" title="3.$(filter pattern…,text)"></a>3.$(filter pattern…,text)</h3><p>把 text 中符合 pattern 格式的内容，filter(过滤)出来、留下来。</p><h3 id="4-filter-out-pattern…-text"><a href="#4-filter-out-pattern…-text" class="headerlink" title="4.$(filter-out pattern…,text)"></a>4.$(filter-out pattern…,text)</h3><p>把 text 中符合 pattern 格式的内容，filter-out(过滤)出来、扔掉。</p><h3 id="5-patsubst-pattern-replacement-text"><a href="#5-patsubst-pattern-replacement-text" class="headerlink" title="5.$(patsubst pattern,replacement,text)"></a>5.$(patsubst pattern,replacement,text)</h3><p>寻找’ <strong>text</strong> ‘中符合格式’ pattern ‘的字，用’ r<strong>eplacement</strong> ‘替换它们。</p><p>‘ <strong>pattern</strong> ‘和’ <strong>replacement</strong> ‘中可以使用通配符。<br><img src="https://raw.githubusercontent.com/mengchao666/picture/main/blog20241113234721.png" alt="代码示例"></p><h2 id="七、Makefile的例子，包含子目录"><a href="#七、Makefile的例子，包含子目录" class="headerlink" title="七、Makefile的例子，包含子目录"></a>七、Makefile的例子，包含子目录</h2><h2 id="八、Makefile中的EXTRA-CFLAGS"><a href="#八、Makefile中的EXTRA-CFLAGS" class="headerlink" title="八、Makefile中的EXTRA_CFLAGS"></a>八、Makefile中的EXTRA_CFLAGS</h2><p>EXTRA_CFLAGS是Makefile中预定义的一个变量，作为CFLGAS，在make时可以传递给gcc一些编译选项等，如—O2</p><h3 id="EXTRA-CFLAGS-D等价于gcc-D，相当于在源代码中定义一个宏"><a href="#EXTRA-CFLAGS-D等价于gcc-D，相当于在源代码中定义一个宏" class="headerlink" title="EXTRA_CFLAGS +&#x3D; -D等价于gcc -D，相当于在源代码中定义一个宏"></a>EXTRA_CFLAGS +&#x3D; -D等价于gcc -D，相当于在源代码中定义一个宏</h3><p>假如定义一个宏CONFIG_DEBUG<br>在.c里面定义为：#define CONFIG_DEBUG<br>在makefile里定义为: CONFIG_DEBUG&#x3D;y</p><p>假如说我们想在makefile里为.c文件进入一个宏定义，就用EXTRA_CFLAGS +&#x3D; DCONFIG_DEBUG( 等价于在.c文件里定义#define CONFIG_DEBUG)</p><p>这时CONFIG_DEBUG&#x3D;y与EXTRA_CFLAGS +&#x3D; DCONFIG_DEBUG的区别应该你已经看出来的，前者是对makefile编译时用的，比如说obj-(CONFIG_DEBUG) +&#x3D; test.o,而后者则是对.c源文件里的用的</p><h2 id="九、Makefile编译内核驱动ko"><a href="#九、Makefile编译内核驱动ko" class="headerlink" title="九、Makefile编译内核驱动ko"></a>九、Makefile编译内核驱动ko</h2><p>内核源代码中obj-m表示以模块ko的方式编译<br>obj-y表示将源代码编译到内核源码中<br>在工作的过程中，经常需要编译一些Ko模块，如果是单个的c文件编译直接在内核源码里面 obj-y&#x3D;xxx.o就好<br>如果这个ko文件需要多个c文件共同编译生成的话，最好以如下的模板来完成编译较好</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">首先指定好编译链工具</span><br>CROSS_COMPILE=/opt/gcc-linaro-7.3.1-2018.05-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-<br><span class="hljs-meta prompt_">#</span><span class="language-bash">指定用哪个内核去编译</span><br>KDIR=/mnt/nfsroot/zhengshuai.zhu/IPCSDK/ipc-sdk-full-release/kernel-4.19<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">目标是编译成一个test.ko文件</span><br>obj-m += test.o<br><span class="hljs-meta prompt_">#</span><span class="language-bash">test.o文件由当前目录下n个c文件编译成</span><br>test-objs += ./*.o<br><span class="hljs-meta prompt_">#</span><span class="language-bash">包含当前目录下的头文件</span><br>INCLUDE_DIRS := $(addprefix -I,$(shell find ../ -type d ))<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">包含当前目录下，内核目录下的头文件</span><br>ccflags-y:= -I$(_KDIR)/include/linux/ -I$(PWD)/platform/<br><span class="hljs-meta prompt_">#</span><span class="language-bash">忽略一些编译警告，类如什么变量未使用</span><br>ccflags-y += -Wno-declaration-after-statement<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">添加c文件中的环境变量，比如在代码中会有</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">ifdef CONFIG_ANDROID</span> <br><span class="hljs-meta prompt_">#</span><span class="language-bash">xxxx</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">endif</span><br>ifeq ($(SYSTEM_VERSION),)<br>    ccflags-y += -DCONFIG_LINUX_OS<br>else<br>    ccflags-y += -DCONFIG_ANDROID<br>endif<br><br>all:<br>  make ARCH=$&#123;ARCH&#125; -C $(KDIR) M=$(PWD) modules<br><br>clean:<br>  make ARCH=$&#123;ARCH&#125; -C $(KDIR) M=$(PWD) clean<br></code></pre></td></tr></table></figure><p><code>make ARCH=$&#123;ARCH&#125; -C ( K D I R ) M = (KDIR) M=(KDIR)M=(PWD) modules</code><br>如何理解这句话?<br>-C的选项可以理解为:<br>进入所指定的位置，$(KDIR)，也就是内核目录中，目的是什么？ 去读取内核目录顶层的Makefile文件，相当于编译的时候 选择一个内核，我要用这个内核去编译。<br>因为你这个目录没有被配置到kernel config里面去，也就是说没有指定用哪个内核版本，有了 -C $(KDIR),就相当于选了内核，如果你选择了kernel-4.19目录下，或者 kernel-5.0目录下，</p><p>M&#x3D;的选项可以理解为:<br>当我选好内核版本后，我用这个 版本的内核 要去编译哪个目录，然后进入$(PWD)目录去编译当前指定的文件，将其编译成ko文件</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、Makefile规则&quot;&gt;&lt;a href=&quot;#一、Makefile规则&quot; class=&quot;headerlink&quot; title=&quot;一、Makefile规则&quot;&gt;&lt;/a&gt;一、Makefile规则&lt;/h2&gt;&lt;p&gt;一个简单的 Makefile 文件包含一系列的“规则”，其样</summary>
      
    
    
    
    <category term="Makefile" scheme="http://example.com/categories/Makefile/"/>
    
    
    <category term="Makefile" scheme="http://example.com/tags/Makefile/"/>
    
  </entry>
  
  <entry>
    <title>git提交流程</title>
    <link href="http://example.com/posts/1.html"/>
    <id>http://example.com/posts/1.html</id>
    <published>2024-11-11T14:12:51.000Z</published>
    <updated>2024-11-13T13:23:15.383Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Git下载及配置"><a href="#一、Git下载及配置" class="headerlink" title="一、Git下载及配置"></a>一、Git下载及配置</h2><p>我们第一次用git或者是新电脑上重新安装git工具的时候，都需要重新配置一下这个工具。</p><h3 id="Windows安装git"><a href="#Windows安装git" class="headerlink" title="Windows安装git"></a>Windows安装git</h3><p>官网网址<a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a>下载速度慢，且有可能安装不成功。 附快速下载地址（国内下载站）：<a href="https://github.com/waylau/git-for-win">https://github.com/waylau/git-for-win</a> 。 下载完之后，Windows中你在桌面上或者文件管理器中鼠标右键就可以看见Git Bash here，就是用来打开git bash的。</p><h3 id="Linux安装git"><a href="#Linux安装git" class="headerlink" title="Linux安装git"></a>Linux安装git</h3><p>linux在终端中，输入<code>sudo apt-get install git</code></p><p>下载完可以用命令<code>git --version</code>打印当前的git版本验证是否成功。下面正式开始Git的配置。</p><h3 id="配置git基本信息"><a href="#配置git基本信息" class="headerlink" title="配置git基本信息"></a>配置git基本信息</h3><p>接下来就是不管我们是第一次使用git工具，还是后来换电脑了，还是换成linux系统了，要想使用git都按照下面的方法配置一遍，才可以使用。 安装成功之后，在命令行中敲下如下命令 <code>git config --list</code>,显示当前的配置信息。 接下来设置提交仓库时的用户名信息 <code>git config --global user.name &quot;张三&quot;</code> 设置提交仓库是的邮箱信息 <code>git config --global user.email &quot;xxxxxxxx@qq.com&quot;</code> git设置关闭自动换行<code>git config --global core.autocrlf false</code> 为了保证文件的换行符是以安全的方法，避免windows与unix的换行符混用的情况，最好也加上这么一句 <code>git config --global core.safecrlf true</code></p><p>其实这些信息都在一个配置文件中，就在当前用户的主目录下边的**.gitconfig**文件中，也可以直接打开这个文件<code>cd ~,vim .gitconfig</code>进行编辑。</p><h3 id="git协议及秘钥配置"><a href="#git协议及秘钥配置" class="headerlink" title="git协议及秘钥配置"></a>git协议及秘钥配置</h3><p>git有四种协议：Git协议，http协议，本地协议，ssh协议。使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https。大部分都是用ssh协议。这个不仅速度快，而且不用每次提交输入密码，可谓是省心省力。 下面就说一下ssh配置过程。(这个协议配置的过程不可缺少，不然就用不了这种协议。)</p><p>首先生成 RSA 密钥对 :</p><p><code>ssh-keygen -t rsa -C &quot;xxxxxxxx@qq.com&quot;</code>注意格式，一定要正确。 ssh和-keygen无空格 此时在用户主目录下就会有一个.ssh隐藏文件，进入该目录有一个id_rsa.pub文件，cat命令查看这个文件，复制下来然后在 github网站添加公钥 ，方法如下 在 Github 网站添加公钥：在右上角头像处点settings进入设置，然后点SSH and GPG keys,进入之后点击New SSH key 粘贴进去，随便给这个秘钥命个名，方便管理就行了。钥匙显示黑色即可。 此时配置就完成了。接下来就可以使用git了。 执行此命令验证是否成功<code>ssh -T git@github.com</code> 成功显示为：Hi XXX! You’ve successfully authenticated, but GitHub does not provide shell access.</p><h2 id="二、先有本地库，后有远程库"><a href="#二、先有本地库，后有远程库" class="headerlink" title="二、先有本地库，后有远程库"></a>二、先有本地库，后有远程库</h2><h3 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h3><p>可以理解为版本库就是本地文件的一个目录，也叫仓库。可以用git来管理和回退等 创建版本库：找到一个想被管理的文件夹，进入到文件夹里，输入命令<code>git init</code>,此时git就可以管理这个目录了，并且在文件夹下多出来了一个.git的隐藏文件夹。这个.git就是版本库。 Git的版本库里存了很多东西，其中最重要的就是称为<strong>stage（或者叫index）的暂存区</strong>，还有Git为我们自动创建的<strong>第一个分支master</strong>，以及指向master的一个指针叫HEAD。 工作区：就是你在电脑里能看到的目录，比如刚才的文件夹就是一个工作区</p><h3 id="第一步：将文件添加到暂存区"><a href="#第一步：将文件添加到暂存区" class="headerlink" title="第一步：将文件添加到暂存区"></a>第一步：将文件添加到暂存区</h3><p>当我们想添加文件或者修改文件是需要添加到版本库中的，否则无法被git跟踪管理呀，所以当我们添加或者修改文件时，先要用<code>git add filename</code>添加到暂存区中，filename为<code>.</code>的时候代表当前目录下所有文件都添加到暂存区</p><h3 id="第二步：将文件提交到分支"><a href="#第二步：将文件提交到分支" class="headerlink" title="第二步：将文件提交到分支"></a>第二步：将文件提交到分支</h3><p><code>git commit -m &quot;message&quot;</code>，将文件提交到了分支。</p><h3 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h3><p>我们已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。 首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库，在Repository name填入项目名字，比如我们叫learngit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库 目前，在GitHub上的这个learngit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。</p><p>现在，我们根据GitHub的提示，在本地的learngit仓库下运行命令： <code>git remote add origin git@github.com:mengchao666/learngit.git</code> 请千万注意，把上面的mengchao666替换成你自己的GitHub账户名，否则，你在本地关联的就是我的远程库，你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。</p><p>添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。下一步，就可以把本地库的所有内容推送到远程库上： <code>git push -u origin master</code>把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样,从现在起，只要本地作了提交，就可以通过命令： <code>git push origin master</code></p><h2 id="三、先有远程库，后有本地库"><a href="#三、先有远程库，后有本地库" class="headerlink" title="三、先有远程库，后有本地库"></a>三、先有远程库，后有本地库</h2><p>现在，远程库已经准备好了，下一步是用命令git clone克隆一个本地库： <code>git clone git@github.com:mengchao666/learngit.git</code></p><p>可以使用<code>git clone -b branch</code>克隆指定的分支<br>后续修改可以使用如下命令提交</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git add .<br>git commit -m &quot;message&quot;<br>git push<br></code></pre></td></tr></table></figure><h2 id="四、企业开发流程"><a href="#四、企业开发流程" class="headerlink" title="四、企业开发流程"></a>四、企业开发流程</h2><p>在公司中做项目，一般项目代码都在公共仓库中，我们将其称为远程仓，一般按照如下步骤开发<br>1、将远程仓fork一份到个人仓<br>2、git clone个人仓代码到本地<br>3、使用<code>git remote -v</code>命令查看，此时本地关联的origin为个人仓<br>4、将本地代码关联到公司的远程仓，方便拉取最新代码，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git remote add upstream 公共仓地址<br></code></pre></td></tr></table></figure><p>此时再次使用<code>git remote -v</code>可以看到已经关联了upstream为远程仓<br>5、在开发需求和问题单修改之前，一般使用<code>git pull upstream</code>命令将远程仓代码更新至本地<br>6、修改代码后提交</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git add .<br>git commit -m &quot;message&quot;<br>git push origin branch<br></code></pre></td></tr></table></figure><p>7、在github&#x2F;gitlab页面创建MR申请，一般此时就可以了，找人加分就合入了<br>8、但是如果在创建MR申请时，提示冲突，此时需要解决冲突，解决如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git pull upstream<br></code></pre></td></tr></table></figure><p>此时会提示哪些文件有冲突，使用ctrl + F搜索<code>&gt;&gt;&gt;</code>,有此标志的即为冲突的地方，保留自己想要的代码，重新提交add commit push即可。</p><p>企业开发流程中，通常有远程仓新建了一个分支，个人远程仓没有此分支，需要更新，可按照如下步骤更新个人仓代码分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git checkout -b 新分支名称 upstream/新分支名称<br>git pull upstream 新分支名称<br>git push origin 新分支名称<br></code></pre></td></tr></table></figure><h2 id="五、代码回退等操作"><a href="#五、代码回退等操作" class="headerlink" title="五、代码回退等操作"></a>五、代码回退等操作</h2><h3 id="工作区的恢复-此时还没有add，代码回退"><a href="#工作区的恢复-此时还没有add，代码回退" class="headerlink" title="工作区的恢复(此时还没有add，代码回退)"></a>工作区的恢复(此时还没有add，代码回退)</h3><p>使用checkout恢复工作区 <code>git checkout .</code> （全部修改），<code>git checkout --file</code>改回一个文件,工作区—&gt;还没add</p><h3 id="add的撤销"><a href="#add的撤销" class="headerlink" title="add的撤销"></a>add的撤销</h3><p>git reset就是回退到指定的commitID,,使用git commit –amend时追加，不会生成新的commitID,是在原来的commitID基础上进行修改的。</p><p>HEAD指向当前最新的commitID，所以仅仅add,没有commit，此时的最新的commitID还是之前的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git reset --hard HEAD  // 不保留本地修改，回退<br>git reset --mixed HEAD //保留本地修改，可以重新git add<br></code></pre></td></tr></table></figure><p>简单理解git reset –xxx HEAD命令，就是将代码回退到了最新的一次commitID的代码状态，hard不保留本地代码工作空间的修改，而mixed保留</p><h3 id="commit后的撤销"><a href="#commit后的撤销" class="headerlink" title="commit后的撤销"></a>commit后的撤销</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">git reset --hard HEAD^ <span class="hljs-comment">// 不保留本地修改，回退到上一次的commitID状态</span><br>git reset --mixed HEAD^ <span class="hljs-comment">// 保留本地修改，撤销git commit,并且撤销git add</span><br>git reset --soft HEAD^ <span class="hljs-comment">//保留本地修改，撤销commit,不撤销add</span><br></code></pre></td></tr></table></figure><h2 id="六、git的一些其他操作"><a href="#六、git的一些其他操作" class="headerlink" title="六、git的一些其他操作"></a>六、git的一些其他操作</h2><p>查看分支：<code>git branch</code> <br>创建分支：<code>git branch &lt;name&gt;</code> <br>切换分支：<code>git checkout &lt;name&gt;</code>或者<code>git switch &lt;name&gt;</code> <br>创建+切换分支：<code>git checkout -b &lt;name&gt;</code>或者<code>git switch -c &lt;name&gt;</code> <br>合并某分支到当前分支：<code>git merge &lt;name&gt;</code> <br>删除分支：<code>git branch -d &lt;name&gt;</code></p><p>当代码仓有子仓情形下的一些命令：<br><code>git submodule update --init --remote</code><br><code>git submodule foreach git checkout branch</code><br><code>git submodule foreach --recursive</code></p><h2 id="七、同时提交两个MR"><a href="#七、同时提交两个MR" class="headerlink" title="七、同时提交两个MR"></a>七、同时提交两个MR</h2><p>当我们同时修改多个问题单，或者同时处理需求时，可能需要同时提交多分不同代码，此时处理方法如下：</p><p>1、本地创建一个新的分支来处理第一个MR</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git checkout -b mr1-branch<br></code></pre></td></tr></table></figure><p>2、提交第一个MR。<br>修改代码，git add、git commit，git push</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git push -u origin mr1-branch<br></code></pre></td></tr></table></figure><p>3、切换回原来的分支，以main分支为例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git checkout main<br></code></pre></td></tr></table></figure><p>4、创建第二个分支处理第二个MR</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git checkout -b mr2-branch<br></code></pre></td></tr></table></figure><p>5、提交第二个MR。<br>修改代码，git add、git commit，git push</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git push -u origin mr2-branch<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、Git下载及配置&quot;&gt;&lt;a href=&quot;#一、Git下载及配置&quot; class=&quot;headerlink&quot; title=&quot;一、Git下载及配置&quot;&gt;&lt;/a&gt;一、Git下载及配置&lt;/h2&gt;&lt;p&gt;我们第一次用git或者是新电脑上重新安装git工具的时候，都需要重新配置一下</summary>
      
    
    
    
    <category term="git" scheme="http://example.com/categories/git/"/>
    
    
    <category term="git" scheme="http://example.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>addr2line</title>
    <link href="http://example.com/posts/addr2line.html"/>
    <id>http://example.com/posts/addr2line.html</id>
    <published>2024-11-10T14:39:55.000Z</published>
    <updated>2024-11-11T14:02:20.475Z</updated>
    
    <content type="html"><![CDATA[<p>addr2line是一个将地址转换为文件名和行号的工具。给定可执行文件(如exe&#x2F;a.out等)中的地址或可重定位对象(如so,ko等)部分中的偏移量，它会使用调试信息来确定与之相关的文件名和行数。</p><p>用户态coredump，一般使用gdb调试接口，gdb一般封装了addr2line，可以解析文件名和行号。如果环境配置了不生成coredump，可以使用addr2line调试。<code>所以addr2line一般解析内核Call trace使用较多。</code></p><h2 id="一、使用方法"><a href="#一、使用方法" class="headerlink" title="一、使用方法"></a>一、使用方法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">基本用法：<br>addr2line [选项] [地址]<br></code></pre></td></tr></table></figure><p>常用选项如下：</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-e</td><td>设置输入文件名称，默认为a.out</td></tr><tr><td>-i</td><td>解析内联函数</td></tr><tr><td>-f</td><td>显示函数名</td></tr><tr><td>-C</td><td>解析函数名</td></tr><tr><td>-p</td><td>以好读的方式显示</td></tr></tbody></table><p>需要注意的是使用addr2line的时候，可执行文件或重定位文件一定是要带调试信息的</p><h2 id="二、用户态普通程序崩溃"><a href="#二、用户态普通程序崩溃" class="headerlink" title="二、用户态普通程序崩溃"></a>二、用户态普通程序崩溃</h2><p>使用方法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">addr2line -e 进程名 IP指令地址 -f<br></code></pre></td></tr></table></figure><p>用户态程序崩溃，当没有coredump产生时，可以使用如下方法<br>假设我们的程序名称为segfault,当程序崩溃是，dmesg日志中会有报错信息:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">[root@localhost ~]# dmesg<br>[134563.793925] segfault[53791]: segfault at 0 ip 0000000000400546 sp 00007fff7956af70 error 6 <span class="hljs-keyword">in</span> segfault[400000+1000]<br>[134563.793946] Code: 01 5d c3 90 c3 66 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 f3 0f 1e fa eb 8a 55 48 89 e5 48 c7 45 f8 00 00 00 00 48 8b 45 f8 &lt;c7&gt; 00 00 00 00 00 b8 00 00 00 00 5d c3 66 2e 0f 1f 84 00 00 00 00<br></code></pre></td></tr></table></figure><p>此时我们注意到IP指令地址为0000000000400546<br>使用addr2line查看程序挂的位置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">addr2line -e segfault <span class="hljs-number">0x0000000000400546</span> -f<br></code></pre></td></tr></table></figure><h2 id="三、动态链接库程序崩溃"><a href="#三、动态链接库程序崩溃" class="headerlink" title="三、动态链接库程序崩溃"></a>三、动态链接库程序崩溃</h2><p>使用方法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">addr2line -e 动态链接库名称 IP指令地址-基地址 -f<br></code></pre></td></tr></table></figure><p>假设我们有一个程序名为test，链接了一个libfoo.so，程序运行时崩溃，dmesg查看日志如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">[root@localhost ~]<span class="hljs-meta"># dmesg</span><br>[<span class="hljs-number">70567.416655</span>] test[<span class="hljs-number">27722</span>]: segfault at <span class="hljs-number">0</span> ip <span class="hljs-number">00007f</span>fa1f588580 sp <span class="hljs-number">00007f</span>ffa964e698 error <span class="hljs-number">6</span> in libfoo.so[<span class="hljs-number">7f</span>fa1f588000+<span class="hljs-number">1000</span>]<br>[<span class="hljs-number">70567.427374</span>] Code: ff e8 <span class="hljs-number">64</span> ff ff ff c6 <span class="hljs-number">05</span> bd <span class="hljs-number">0</span>a <span class="hljs-number">20</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">5</span>d c3 <span class="hljs-number">0f</span> <span class="hljs-number">1f</span> <span class="hljs-number">00</span> c3 <span class="hljs-number">0f</span> <span class="hljs-number">1f</span> <span class="hljs-number">80</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> f3 <span class="hljs-number">0f</span> <span class="hljs-number">1</span>e fa e9 <span class="hljs-number">77</span> ff ff ff <span class="hljs-number">0f</span> <span class="hljs-number">1f</span> <span class="hljs-number">80</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> &lt;c7&gt; <span class="hljs-number">04</span> <span class="hljs-number">25</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">0f</span> <span class="hljs-number">0b</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> f3 <span class="hljs-number">0f</span> <span class="hljs-number">1</span>e fa <span class="hljs-number">48</span> <span class="hljs-number">83</span><br></code></pre></td></tr></table></figure><p>根据日志可知，段错误发生的位置是在test进程调用的<code>libfoo.so</code>库里，我们先使用ldd找到动态库的位置，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">[root@localhost <span class="hljs-number">69</span>]<span class="hljs-meta"># ldd test</span><br>        linux-vdso.so<span class="hljs-number">.1</span> (<span class="hljs-number">0x00007ffd15b24000</span>)<br>        libfoo.so =&gt; ./libfoo.so (<span class="hljs-number">0x00007f8c01879000</span>)<br>        libc.so<span class="hljs-number">.6</span> =&gt; /lib64/libc.so<span class="hljs-number">.6</span> (<span class="hljs-number">0x00007f8c014b4000</span>)<br>        /lib64/ld-linux-x86<span class="hljs-number">-64.</span>so<span class="hljs-number">.2</span> (<span class="hljs-number">0x00007f8c01a7b000</span>)<br></code></pre></td></tr></table></figure><p>00007ffa1f588580为程序崩溃点IP指令地址，使用dmesg消息中ip指令地址减去动态库基址值(00007ffa1f588580 -7ffa1f588000&#x3D;580), 差值0x580为错误点在动态库的地址，调用addr2line, 注意-e参数后文件名改为动态库名:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">addr2line -e libfoo.so <span class="hljs-number">580</span> -f -p<br></code></pre></td></tr></table></figure><h2 id="四、内核驱动程序运行崩溃"><a href="#四、内核驱动程序运行崩溃" class="headerlink" title="四、内核驱动程序运行崩溃"></a>四、内核驱动程序运行崩溃</h2><p>使用方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">addr2line -e xxx.ko 地址偏移量 -f<br></code></pre></td></tr></table></figure><p>本人所用主机即属于一旦发生Oops，就会触发panic，因此总是无法查看Oops时的dmesg日志，经查阅资料，发现是内核参数panic_on_oops的原因导致的，因为该参数被设置为1，所以Oops会触发panic，从而导致机器总是死机重启，无法查看Oops时的dmesg日志。下面提供两种方法修改Oops内核参数，使其不会在Oops的时候触发panic导致死机重启。</p><p>方法一：修改 &#x2F;proc下内核参数文件内容，临时生效，重启后失效。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">echo <span class="hljs-number">0</span> &gt; /proc/sys/kernel/panic_on_oops<br></code></pre></td></tr></table></figure><p>方法二：修改&#x2F;etc&#x2F;sysctl.conf 文件的内核参数来永久更改。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# vi /etc/sysctl.conf<br>[root@localhost ~]# cat /etc/sysctl.conf<br><span class="hljs-meta prompt_"># </span><span class="language-bash">sysctl settings are defined through files <span class="hljs-keyword">in</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">/usr/lib/sysctl.d/, /run/sysctl.d/, and /etc/sysctl.d/.</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"></span><br><span class="language-bash"><span class="hljs-comment"># Vendors settings live in /usr/lib/sysctl.d/.</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">To override a whole file, create a new file with the same <span class="hljs-keyword">in</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">/etc/sysctl.d/ and put new settings there. To override</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">only specific settings, add a file with a lexically later</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">name <span class="hljs-keyword">in</span> /etc/sysctl.d/ and put new settings there.</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"></span><br><span class="language-bash"><span class="hljs-comment"># For more information, see sysctl.conf(5) and sysctl.d(5).</span></span><br>kernel.panic_on_oops=0<br>[root@localhost ~]# cat /proc/sys/kernel/panic_on_oops<br>1 <br>[root@localhost ~]# sysctl -p<br>kernel.panic_on_oops = 0<br>[root@localhost ~]#<br>[root@localhost ~]# cat /proc/sys/kernel/panic_on_oops<br>0<br></code></pre></td></tr></table></figure><p>假设内核某ko运行后发生如下错误：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c">[root@localhost ~]<span class="hljs-meta"># dmesg</span><br>[ <span class="hljs-number">1039.918606</span>] my_oops_init<br>[ <span class="hljs-number">1039.918616</span>] BUG: unable to handle kernel <span class="hljs-literal">NULL</span> pointer dereference at <span class="hljs-number">0000000000000000</span><br>[ <span class="hljs-number">1039.926442</span>] PGD <span class="hljs-number">0</span> P4D <span class="hljs-number">0</span><br>[ <span class="hljs-number">1039.928979</span>] Oops: <span class="hljs-number">0002</span> [#<span class="hljs-number">1</span>] SMP NOPTI<br>[ <span class="hljs-number">1039.932637</span>] CPU: <span class="hljs-number">34</span> PID: <span class="hljs-number">3843</span> Comm: insmod Kdump: loaded Tainted: G           OE    --------- -  - <span class="hljs-number">4.18</span><span class="hljs-number">.0</span><span class="hljs-number">-394.</span>el8.x86_64 #<span class="hljs-number">1</span><br>[ <span class="hljs-number">1039.943756</span>] Hardware name: New H3C Technologies Co., Ltd. H3C UniServer R4950 G5/RS45M2C9SB, BIOS <span class="hljs-number">5.37</span> <span class="hljs-number">09</span>/<span class="hljs-number">30</span>/<span class="hljs-number">2021</span><br>[ <span class="hljs-number">1039.954000</span>] RIP: <span class="hljs-number">0010</span>:do_oops+<span class="hljs-number">0x5</span>/<span class="hljs-number">0x11</span> [oops]<br>[ <span class="hljs-number">1039.958364</span>] Code: Unable to access opcode bytes at RIP <span class="hljs-number">0xffffffffc02e6fdb</span>.<br>[ <span class="hljs-number">1039.965231</span>] RSP: <span class="hljs-number">0018</span>:ffffb9d40a8c7cb0 EFLAGS: <span class="hljs-number">00010246</span><br>[ <span class="hljs-number">1039.970449</span>] RAX: <span class="hljs-number">000000000000000</span>c RBX: <span class="hljs-number">0000000000000000</span> RCX: <span class="hljs-number">0000000000000000</span><br>[ <span class="hljs-number">1039.977573</span>] RDX: <span class="hljs-number">0000000000000000</span> RSI: ffff98942ee96758 RDI: ffff98942ee96758<br>[ <span class="hljs-number">1039.984697</span>] RBP: ffffffffc02e7011 R08: <span class="hljs-number">0000000000000000</span> R09: c0000000ffff7fff<br>[ <span class="hljs-number">1039.991822</span>] R10: <span class="hljs-number">0000000000000001</span> R11: ffffb9d40a8c7ad8 R12: ffffffffc02e9000<br>[ <span class="hljs-number">1039.998944</span>] R13: ffffffffc02e9018 R14: ffffffffc02e91d0 R15: <span class="hljs-number">0000000000000000</span><br>[ <span class="hljs-number">1040.006069</span>] FS:  <span class="hljs-number">00007f</span>1b8d93b740(<span class="hljs-number">0000</span>) GS:ffff98942ee80000(<span class="hljs-number">0000</span>) knlGS:<span class="hljs-number">0000000000000000</span><br>[ <span class="hljs-number">1040.014145</span>] CS:  <span class="hljs-number">0010</span> DS: <span class="hljs-number">0000</span> ES: <span class="hljs-number">0000</span> CR0: <span class="hljs-number">0000000080050033</span><br>[ <span class="hljs-number">1040.019884</span>] CR2: ffffffffc02e6fdb CR3: <span class="hljs-number">0000000145</span>c02000 CR4: <span class="hljs-number">0000000000350</span>ee0<br>[ <span class="hljs-number">1040.027008</span>] Call Trace:<br>[ <span class="hljs-number">1040.029454</span>]  my_oops_init+<span class="hljs-number">0x16</span>/<span class="hljs-number">0x19</span> [oops]<br>[ <span class="hljs-number">1040.033550</span>]  do_one_initcall+<span class="hljs-number">0x46</span>/<span class="hljs-number">0x1d0</span><br>[ <span class="hljs-number">1040.037390</span>]  ? do_init_module+<span class="hljs-number">0x22</span>/<span class="hljs-number">0x220</span><br>[ <span class="hljs-number">1040.041318</span>]  ? kmem_cache_alloc_trace+<span class="hljs-number">0x142</span>/<span class="hljs-number">0x280</span><br>[ <span class="hljs-number">1040.046023</span>]  do_init_module+<span class="hljs-number">0x5a</span>/<span class="hljs-number">0x220</span><br>[ <span class="hljs-number">1040.049777</span>]  load_module+<span class="hljs-number">0x14ba</span>/<span class="hljs-number">0x17f0</span><br>[ <span class="hljs-number">1040.053530</span>]  ? __do_sys_finit_module+<span class="hljs-number">0xb1</span>/<span class="hljs-number">0x110</span><br>[ <span class="hljs-number">1040.058059</span>]  __do_sys_finit_module+<span class="hljs-number">0xb1</span>/<span class="hljs-number">0x110</span><br>[ <span class="hljs-number">1040.062411</span>]  do_syscall_64+<span class="hljs-number">0x5b</span>/<span class="hljs-number">0x1a0</span><br>[ <span class="hljs-number">1040.066077</span>]  entry_SYSCALL_64_after_hwframe+<span class="hljs-number">0x65</span>/<span class="hljs-number">0xca</span><br>[ <span class="hljs-number">1040.071130</span>] RIP: <span class="hljs-number">0033</span>:<span class="hljs-number">0x7f1b8c8509bd</span><br>[ <span class="hljs-number">1040.074701</span>] Code: ff c3 <span class="hljs-number">66</span> <span class="hljs-number">2</span>e <span class="hljs-number">0f</span> <span class="hljs-number">1f</span> <span class="hljs-number">84</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">90</span> f3 <span class="hljs-number">0f</span> <span class="hljs-number">1</span>e fa <span class="hljs-number">48</span> <span class="hljs-number">89</span> f8 <span class="hljs-number">48</span> <span class="hljs-number">89</span> f7 <span class="hljs-number">48</span> <span class="hljs-number">89</span> d6 <span class="hljs-number">48</span> <span class="hljs-number">89</span> ca <span class="hljs-number">4</span>d <span class="hljs-number">89</span> c2 <span class="hljs-number">4</span>d <span class="hljs-number">89</span> c8 <span class="hljs-number">4</span>c <span class="hljs-number">8b</span> <span class="hljs-number">4</span>c <span class="hljs-number">24</span> <span class="hljs-number">08</span> <span class="hljs-number">0f</span> <span class="hljs-number">05</span> &lt;<span class="hljs-number">48</span>&gt; <span class="hljs-number">3</span>d <span class="hljs-number">01</span> f0 ff ff <span class="hljs-number">73</span> <span class="hljs-number">01</span> c3 <span class="hljs-number">48</span> <span class="hljs-number">8b</span> <span class="hljs-number">0</span>d <span class="hljs-number">9b</span> <span class="hljs-number">54</span> <span class="hljs-number">38</span> <span class="hljs-number">00</span> f7 d8 <span class="hljs-number">64</span> <span class="hljs-number">89</span> <span class="hljs-number">01</span> <span class="hljs-number">48</span><br>[ <span class="hljs-number">1040.093446</span>] RSP: <span class="hljs-number">002b</span>:<span class="hljs-number">00007f</span>fc4df0a968 EFLAGS: <span class="hljs-number">00000246</span> ORIG_RAX: <span class="hljs-number">0000000000000139</span><br>[ <span class="hljs-number">1040.101004</span>] RAX: ffffffffffffffda RBX: <span class="hljs-number">00005653f</span>b1997d0 RCX: <span class="hljs-number">00007f</span>1b8c8509bd<br>[ <span class="hljs-number">1040.108126</span>] RDX: <span class="hljs-number">0000000000000000</span> RSI: <span class="hljs-number">00005653f</span>980c8b6 RDI: <span class="hljs-number">0000000000000003</span><br>[ <span class="hljs-number">1040.115251</span>] RBP: <span class="hljs-number">00005653f</span>980c8b6 R08: <span class="hljs-number">0000000000000000</span> R09: <span class="hljs-number">00007f</span>1b8cbd9760<br>[ <span class="hljs-number">1040.122375</span>] R10: <span class="hljs-number">0000000000000003</span> R11: <span class="hljs-number">0000000000000246</span> R12: <span class="hljs-number">0000000000000000</span><br>[ <span class="hljs-number">1040.129498</span>] R13: <span class="hljs-number">00005653f</span>b1997b0 R14: <span class="hljs-number">0000000000000000</span> R15: <span class="hljs-number">0000000000000000</span><br>[ <span class="hljs-number">1040.136623</span>] Modules linked in: oops(OE+) binfmt_misc xt_CHECKSUM ipt_MASQUERADE xt_conntrack ipt_REJECT nf_reject_ipv4 nft_compat nft_counter nft_chain_nat nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 nf_tables nfnetlink rpcsec_gss_krb5 auth_rpcgss nfsv4 dns_resolver nfs lockd grace fscache bridge stp llc intel_rapl_msr intel_rapl_common amd64_edac_mod edac_mce_amd amd_energy kvm_amd kvm irqbypass ipmi_ssif pcspkr crct10dif_pclmul crc32_pclmul ghash_clmulni_intel rapl joydev ccp sp5100_tco i2c_piix4 k10temp ptdma acpi_ipmi ipmi_si sunrpc vfat fat xfs libcrc32c sd_mod t10_pi sg crc32c_intel ast drm_vram_helper drm_kms_helper syscopyarea sysfillrect sysimgblt fb_sys_fops drm_ttm_helper ttm ahci drm libahci <span class="hljs-title function_">nfp</span><span class="hljs-params">(OE)</span> igb libata dca i2c_algo_bit dm_mirror dm_region_hash dm_log dm_mod ipmi_devintf ipmi_msghandler<br>[ 1040.208357] CR2: 0000000000000000<br>[ 1040.211668] ---[ end trace b69c1e8998070273 ]---<br>[ 1040.230185] RIP: 0010:do_oops+0x5/0x11 [oops]<br>[ 1040.234540] Code: Unable to access opcode bytes at RIP 0xffffffffc02e6fdb.<br>[ 1040.241409] RSP: 0018:ffffb9d40a8c7cb0 EFLAGS: 00010246<br>[ 1040.246626] RAX: 000000000000000c RBX: 0000000000000000 RCX: 0000000000000000<br>[ 1040.253750] RDX: 0000000000000000 RSI: ffff98942ee96758 RDI: ffff98942ee96758<br>[ 1040.260876] RBP: ffffffffc02e7011 R08: 0000000000000000 R09: c0000000ffff7fff<br>[ 1040.267998] R10: 0000000000000001 R11: ffffb9d40a8c7ad8 R12: ffffffffc02e9000<br>[ 1040.275124] R13: ffffffffc02e9018 R14: ffffffffc02e91d0 R15: 0000000000000000<br>[ 1040.282247] FS:  00007<span class="hljs-title function_">f1b8d93b740</span><span class="hljs-params">(<span class="hljs-number">0000</span>)</span> GS:<span class="hljs-title function_">ffff98942ee80000</span><span class="hljs-params">(<span class="hljs-number">0000</span>)</span> knlGS:0000000000000000<br>[ 1040.290323] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033<br>[ 1040.296061] CR2: ffffffffc02e6fdb CR3: 0000000145c02000 CR4: 0000000000350ee0<br></code></pre></td></tr></table></figure><p>Oops: 0002 – 错误码<br>Oops: [#1] – Oops发生的次数<br>CPU: 34 – 表示Oops是发生在CPU34上<br>关键信息如下，这里提示在操作函数do_oops的时候出现异常，地址偏移量0x5：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">[ 1039.954000] RIP: 0010:do_oops+0x5/0x11 [oops]<br></code></pre></td></tr></table></figure><p>为什么这条信息关键? 因为其含有指令指针RIP；指令指针IP&#x2F;EIP&#x2F;RIP的基本功能是指向要执行的下一条地址。在8080 8位微处理器上的寄存器名称是PC（program counter，程序计数器），从8086起，被称为IP（instruction pointer，指令指针）。主要区别在与PC指向正在执行的指令，而IP指向下一条指令。在64位模式下，指令指针是RIP寄存器。这个寄存器保存着下一条要执行的指令的64位地址偏移量。64位模式支持一种新的寻址模式，被称为RIP相对寻址。使用这个模式，有效地址的计算方式变为RIP（指向下一条指令）加上位移量。</p><p>由此可以看出内核执行到do_oops+0x5&#x2F;0x11这个地址的时候出现异常，我们只需要找到这个地址对应的代码即可。</p><p>do_oops指示了是在do_oops函数中出现的异常， 0x5表示出错的地址偏移量， 0x11表示do_oops函数的大小。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">打印格式：do_oops+<span class="hljs-number">0x5</span>/<span class="hljs-number">0x11</span> [oops] <br>即：symbol+offset/size [module] <br>symbol: 符号 offset：地址偏移量 size：函数的长度 module: 所属内核模块<br></code></pre></td></tr></table></figure><p>使用如下命令解析</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">addr2line -e oops.ko <span class="hljs-number">0x5</span> -f -p<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;addr2line是一个将地址转换为文件名和行号的工具。给定可执行文件(如exe&amp;#x2F;a.out等)中的地址或可重定位对象(如so,ko等)部分中的偏移量，它会使用调试信息来确定与之相关的文件名和行数。&lt;/p&gt;
&lt;p&gt;用户态coredump，一般使用gdb调试接口，g</summary>
      
    
    
    
    <category term="Linux工具" scheme="http://example.com/categories/Linux%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="Linux工具" scheme="http://example.com/tags/Linux%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>个人博客网站部署&amp;文章提交</title>
    <link href="http://example.com/posts/%E7%BD%91%E7%AB%99%E9%83%A8%E7%BD%B2-%E5%86%99%E4%BD%9C.html"/>
    <id>http://example.com/posts/%E7%BD%91%E7%AB%99%E9%83%A8%E7%BD%B2-%E5%86%99%E4%BD%9C.html</id>
    <published>2024-11-10T07:38:23.000Z</published>
    <updated>2024-11-10T14:44:31.349Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、网站部署"><a href="#一、网站部署" class="headerlink" title="一、网站部署"></a>一、网站部署</h2><p>1、首先在github上创建自己的一个仓库，仓库名字为mengchao666.github.io</p><p>2、将<a href="https://github.com/mengchao666/blog-demo">https://github.com/mengchao666/blog-demo</a>代码下载到本地，用VScode打开</p><p>3、安装node.js，pnpm，hexo</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">node.js官网安装：https://nodejs.cn/download/<br>pnpm安装：npm install pnpm -g<br>hexo安装：npm install hexo-cli -g<br></code></pre></td></tr></table></figure><p>4、在Vscode打开的项目终端下执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">pnpm i<br>pnpm dev<br></code></pre></td></tr></table></figure><p>5、使用hexo deploy命令部署，打开mengchao666.github.io即可</p><p>6、新增文章使用如下命令新增</p><p>例如：hexo new post “网站部署”</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo new post &lt;title&gt;<br></code></pre></td></tr></table></figure><p>7、新增文章后，使用命令部署提交到github</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo clean<br>hexo deploy<br></code></pre></td></tr></table></figure><p>更多操作可以参考：<a href="https://xaoxuu.com/wiki/stellar/topic.html">https://xaoxuu.com/wiki/stellar/topic.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、网站部署&quot;&gt;&lt;a href=&quot;#一、网站部署&quot; class=&quot;headerlink&quot; title=&quot;一、网站部署&quot;&gt;&lt;/a&gt;一、网站部署&lt;/h2&gt;&lt;p&gt;1、首先在github上创建自己的一个仓库，仓库名字为mengchao666.github.io&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="网站" scheme="http://example.com/categories/%E7%BD%91%E7%AB%99/"/>
    
    
    <category term="网站" scheme="http://example.com/tags/%E7%BD%91%E7%AB%99/"/>
    
  </entry>
  
</feed>
