<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>mengchao666</title>
  
  <subtitle>个人记录</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-11-24T15:31:39.142Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ftpget</title>
    <link href="http://example.com/posts/ftpget.html"/>
    <id>http://example.com/posts/ftpget.html</id>
    <published>2024-11-24T15:31:27.000Z</published>
    <updated>2024-11-24T15:31:39.142Z</updated>
    
    <content type="html"><![CDATA[<p>ftpget -u  username -p passwd IP  source  target</p><p>ftpput -u  username -p passwd IP  target  source</p><p>举个例子：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ftpput -u zhangsan -p 000000 192.168.10.10 target.txt source.txt   <br>// 将本地的 source.txt 文件传输到 192.168.10.10 /home/zhangsan/ 目录下，并以target.txt 保存<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;ftpget -u  username -p passwd IP  source  target&lt;/p&gt;
&lt;p&gt;ftpput -u  username -p passwd IP  target  source&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;figure class=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>scp</title>
    <link href="http://example.com/posts/scp.html"/>
    <id>http://example.com/posts/scp.html</id>
    <published>2024-11-24T15:30:53.000Z</published>
    <updated>2024-11-24T15:31:04.571Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、从本地复制到远程主机"><a href="#一、从本地复制到远程主机" class="headerlink" title="一、从本地复制到远程主机"></a>一、从本地复制到远程主机</h2><p>命令格式如下：</p><p>scp &#x2F;path&#x2F;to&#x2F;local&#x2F;file.txt user@remote_host:&#x2F;path&#x2F;on&#x2F;remote&#x2F;</p><p>这会将本地的 <code>file.txt</code> 文件复制到远程主机 <code>remote_host</code> 的 <code>/path/on/remote/</code> 目录下。</p><h3 id="二、从远程主机复制到本地"><a href="#二、从远程主机复制到本地" class="headerlink" title="二、从远程主机复制到本地"></a>二、从远程主机复制到本地</h3><p>（1）命令解释<br>命令格式如下：scp user@remote_host:&#x2F;path&#x2F;on&#x2F;remote&#x2F;file.txt &#x2F;path&#x2F;to&#x2F;local&#x2F;</p><p>这会将远程主机 <code>remote_host</code> 的 <code>/path/on/remote/file.txt</code> 文件复制到本地的 <code>/path/to/local/</code> 目录下。</p><p>（2）实际操作<br>实操命令如下：<br>scp <a href="mailto:&#x72;&#x6f;&#x6f;&#116;&#64;&#x31;&#57;&#x32;&#46;&#x31;&#54;&#x38;&#46;&#x31;&#x2e;&#49;&#x30;&#x39;">&#x72;&#x6f;&#x6f;&#116;&#64;&#x31;&#57;&#x32;&#46;&#x31;&#54;&#x38;&#46;&#x31;&#x2e;&#49;&#x30;&#x39;</a>:&#x2F;home&#x2F;DataBaseMysql.zip .&#x2F;</p><p>这会将远程主机 <code>192.168.1.109</code> 的&#x2F;home&#x2F;DataBaseMysql.zip 文件复制到本地的当前目录下</p><h3 id="三、递归复制目录"><a href="#三、递归复制目录" class="headerlink" title="三、递归复制目录"></a>三、递归复制目录</h3><p>实操命令如下：scp -r user@remote_host:&#x2F;path&#x2F;on&#x2F;remote&#x2F;directory &#x2F;path&#x2F;to&#x2F;local&#x2F;</p><p>这会将远程主机 <code>remote_host</code> 的 <code>/path/on/remote/directory</code> 目录及其所有内容复制到本地的 <code>/path/to/local/</code> 目录下。</p><h3 id="四、指定-SSH-端口"><a href="#四、指定-SSH-端口" class="headerlink" title="四、指定 SSH 端口"></a>四、指定 SSH 端口</h3><p>如果远程主机的 SSH 端口不是默认的 22，可以使用 <code>-P</code> 选项指定端口：</p><p>scp -P 2222 user@remote_host:&#x2F;path&#x2F;on&#x2F;remote&#x2F;file.txt &#x2F;path&#x2F;to&#x2F;local&#x2F;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、从本地复制到远程主机&quot;&gt;&lt;a href=&quot;#一、从本地复制到远程主机&quot; class=&quot;headerlink&quot; title=&quot;一、从本地复制到远程主机&quot;&gt;&lt;/a&gt;一、从本地复制到远程主机&lt;/h2&gt;&lt;p&gt;命令格式如下：&lt;/p&gt;
&lt;p&gt;scp &amp;#x2F;path&amp;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>find</title>
    <link href="http://example.com/posts/find.html"/>
    <id>http://example.com/posts/find.html</id>
    <published>2024-11-24T15:30:13.000Z</published>
    <updated>2024-11-24T15:30:25.117Z</updated>
    
    <content type="html"><![CDATA[<p>find . -name “my_file”</p><p>find . -name &#x2F;etc -type d</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;find . -name “my_file”&lt;/p&gt;
&lt;p&gt;find . -name &amp;#x2F;etc -type d&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>grep</title>
    <link href="http://example.com/posts/grep.html"/>
    <id>http://example.com/posts/grep.html</id>
    <published>2024-11-24T15:29:25.000Z</published>
    <updated>2024-11-24T15:29:37.251Z</updated>
    
    <content type="html"><![CDATA[<p>文本搜索工具，根据用户指定的“模式”（过滤条件），对目标文本逐行进行匹配，并打印输出匹配到的行。</p><p>完整语法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">grep   [options]   [pattern]   file<br> <br>命令    参数         匹配模式      文件数据<br></code></pre></td></tr></table></figure><p>常用参数：</p><table><thead><tr><th>常用参数</th><th>描述</th></tr></thead><tbody><tr><td>-i</td><td>忽略大小写</td></tr><tr><td>-n</td><td>显示匹配行与行号</td></tr><tr><td>-r</td><td>递归查找子目录</td></tr><tr><td>-v</td><td>显示不能被匹配到的字符串</td></tr></tbody></table><p>常用正则表达式</p><p>表达式解释</p><ul><li><p>^用于模式最左侧，如 “^yu” 即匹配以yu开头的单词</p></li><li><p>$用于模式最右侧，如 “yu$” 即匹配以yu结尾的单词</p></li><li><p>^$组合符，表示空行</p></li><li><p>.匹配任意一个且只有一个字符，不能匹配空行</p></li><li><p>|使用egrep命令</p></li><li></li><li><p>重匹配前一个字符连续出现0次或1次以上</p></li><li><p>.*匹配任意字符</p></li><li><p>^.*组合符，匹配任意多个字符开头的内容</p></li><li><p>.*$组合符，匹配任意多个字符结尾的内容</p></li><li><p>[abc]匹配 [] 内集合中的任意一个字符，a或b或c，也可以写成 [ac]</p></li><li><p>[^abc]匹配除了 ^后面的任意一个字符，a或b或c，[]内 ^ 表示取反操作</p></li></ul><p>常用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">grep -nr <span class="hljs-string">&quot;xxx&quot;</span> .<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;文本搜索工具，根据用户指定的“模式”（过滤条件），对目标文本逐行进行匹配，并打印输出匹配到的行。&lt;/p&gt;
&lt;p&gt;完整语法：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>内存检测工具</title>
    <link href="http://example.com/posts/%E5%86%85%E5%AD%98%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7.html"/>
    <id>http://example.com/posts/%E5%86%85%E5%AD%98%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7.html</id>
    <published>2024-11-24T15:28:12.000Z</published>
    <updated>2024-11-24T15:28:27.781Z</updated>
    
    <content type="html"><![CDATA[<p>在写大型C&#x2F;C++工程时难免会发生内存泄漏现象，系统编程中一个重要的方面就是有效地处理与内存相关的问题。你的工作越接近系统，你就需要面对越多的内存问题。有时这些问题非常琐碎，而更多时候它会演变成一个调试内存问题的恶梦。 常见的内存问题一共七种：</p><ol><li>动态内存泄露；</li><li>资源泄露，比如文件指针不关闭；</li><li>动态内存越界；</li><li>4.数组内存越界；</li><li>5.动态内存double free；</li><li>6.使用野指针，即未初始化的指针；</li><li>7.释放野指针，即未初始化的指针。</li></ol><p>内存问题非常难定位，对于小工程来说，简单去检查代码中new和delete的匹配对数就基本能定位到问题，但是一旦代码量上升到以万单位时，仅靠肉眼检查来定位问题那就非常困难了，所以我们需要利用工具帮助我们找出问题所在。在Linux系统下内存检测工具首推Valgrind，一款非常好用的开源内存管理框架。Valgrind其实是一个工具集，内存错误检测只是它众多功能的一个，但我们用得最多的功能正是它——memcheck。</p><p>该工具可以检测下列与内存相关的问题 :</p><ul><li>未释放内存的使用</li><li>对释放后内存的读&#x2F;写</li><li>对已分配内存块尾部的读&#x2F;写</li><li>内存泄露</li><li>不匹配的使用malloc&#x2F;new&#x2F;new[] 和 free&#x2F;delete&#x2F;delete[]</li><li>重复释放内存</li></ul><p>首先安装Valgrind非常简单：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown">//valgrind下载：<br>http://valgrind.org/downloads/valgrind-3.12.0.tar.bz2<br><br>valgrind安装：<br><span class="hljs-bullet">1.</span> tar -jxvf valgrind-3.12.0.tar.bz2<br><span class="hljs-bullet">2.</span> cd valgrind-3.12.0<br><span class="hljs-bullet">3.</span> ./configure<br><span class="hljs-bullet">4.</span> make<br><span class="hljs-bullet">5.</span> sudo make install<br></code></pre></td></tr></table></figure><p>下面开始讲解Valgrind的应用场景。</p><p>注意: 下面讨论的所有测试代码都应该使用gcc&#x2F;g++并且加上-g选项。</p><h2 id="1-使用未初始化的内存（使用野指针）"><a href="#1-使用未初始化的内存（使用野指针）" class="headerlink" title="1. 使用未初始化的内存（使用野指针）"></a>1. 使用未初始化的内存（使用野指针）</h2><p>这里我们定义了一个指针p，但并未给他开辟空间，即他是一个野指针，但我们却使用它了。</p><p><img src="https://raw.githubusercontent.com/mengchao666/picture/main/blog1093303-20180413193554002-1364573355.jpg"></p><p>Valgrind检测出我们程序使用了未初始化的变量，但并未检测出内存泄漏。</p><p><img src="https://raw.githubusercontent.com/mengchao666/picture/main/blog1093303-20180413193604735-1875378577.jpg"></p><h2 id="2-在内存被释放后进行读-写（使用野指针）"><a href="#2-在内存被释放后进行读-写（使用野指针）" class="headerlink" title="2.在内存被释放后进行读&#x2F;写（使用野指针）"></a>2.在内存被释放后进行读&#x2F;写（使用野指针）</h2><p>p所指向的内存被释放了，p变成了野指针，但是我们却继续使用这片内存。</p><p><img src="https://raw.githubusercontent.com/mengchao666/picture/main/blog1093303-20180413193613574-1154240221.jpg"></p><p>Valgrind检测出我们使用了已经free掉的内存，并给出这片内存是哪里分配哪里释放的。</p><p><img src="https://raw.githubusercontent.com/mengchao666/picture/main/blog1093303-20180413193624421-247811116.jpg"></p><h2 id="3-从已分配内存块的尾部进行读-写（动态内存越界）"><a href="#3-从已分配内存块的尾部进行读-写（动态内存越界）" class="headerlink" title="3.从已分配内存块的尾部进行读&#x2F;写（动态内存越界）"></a>3.从已分配内存块的尾部进行读&#x2F;写（动态内存越界）</h2><p>我们动态地分配了一段数组，但我们在访问个数组时发生了越界读写，程序crash掉。</p><p><img src="https://raw.githubusercontent.com/mengchao666/picture/main/blog1093303-20180413193638871-928305119.jpg"></p><p>Valgrind检测出越界的位置。</p><p><img src="https://raw.githubusercontent.com/mengchao666/picture/main/blog1093303-20180413193651410-2101563201.jpg"></p><p>注意：Valgrind不检查静态分配数组的使用情况！所以对静态分配的数组，Valgrind表示无能为力！比如下面的例子，程序crash掉，我们却不知道为什么。</p><p><img src="https://raw.githubusercontent.com/mengchao666/picture/main/blog1093303-20180413193706246-508790416.jpg"></p><p><img src="https://raw.githubusercontent.com/mengchao666/picture/main/blog1093303-20180413193716994-628209858.jpg"></p><h2 id="4-内存泄漏"><a href="#4-内存泄漏" class="headerlink" title="4.内存泄漏"></a>4.内存泄漏</h2><p>内存泄漏的原因在于没有成对地使用malloc&#x2F;free和new&#x2F;delete，比如下面的例子。</p><p><img src="https://raw.githubusercontent.com/mengchao666/picture/main/blog1093303-20180413193726929-641784050.jpg"></p><p>Valgrind会给出程序中malloc和free的出现次数以判断是否发生内存泄漏，比如对上面的程序运行memcheck，Valgrind的记录显示上面的程序用了1次malloc，却调用了0次free，明显发生了内存泄漏！</p><p><img src="https://raw.githubusercontent.com/mengchao666/picture/main/blog1093303-20180413193738724-1869262186.jpg"></p><p>上面提示了我们可以使用–leak-check&#x3D;full进一步获取内存泄漏的信息，比如malloc和free的具体行号。</p><p><img src="https://raw.githubusercontent.com/mengchao666/picture/main/blog1093303-20180413193750769-1501914916.jpg"></p><h2 id="5-不匹配地使用malloc-new-new-和-free-delete-delete"><a href="#5-不匹配地使用malloc-new-new-和-free-delete-delete" class="headerlink" title="5. 不匹配地使用malloc&#x2F;new&#x2F;new[] 和 free&#x2F;delete&#x2F;delete[]"></a>5. 不匹配地使用malloc&#x2F;new&#x2F;new[] 和 free&#x2F;delete&#x2F;delete[]</h2><p>正常使用new&#x2F;delete和malloc&#x2F;free是这样子的：</p><p><img src="https://raw.githubusercontent.com/mengchao666/picture/main/blog1093303-20180413193802975-763647802.jpg"></p><p><img src="https://raw.githubusercontent.com/mengchao666/picture/main/blog1093303-20180413193817047-1922627647.jpg"></p><p>而不匹配地使用malloc&#x2F;new&#x2F;new[] 和 free&#x2F;delete&#x2F;delete[]则会被提示mismacth：</p><p><img src="https://raw.githubusercontent.com/mengchao666/picture/main/blog1093303-20180413193830425-1531404607.jpg"></p><p><img src="https://raw.githubusercontent.com/mengchao666/picture/main/blog1093303-20180413193844415-122107118.jpg"></p><h2 id="6-两次释放内存"><a href="#6-两次释放内存" class="headerlink" title="6.两次释放内存"></a>6.两次释放内存</h2><p>double free的情况同样是根据malloc&#x2F;free的匹配对数来体现的，比如free多了一次，Valgrind也会提示。</p><p><img src="https://raw.githubusercontent.com/mengchao666/picture/main/blog1093303-20180413193909777-1273155147.jpg"></p><p><img src="https://raw.githubusercontent.com/mengchao666/picture/main/blog1093303-20180413193923068-1690539405.jpg"></p><p>当然，Valgrind也不是万能的。Valgrind也有无法找到问题的时候，有些问题只能通过不断的review代码找到了症结。发现问题，解决问题，毕竟是末流。最好的方法，就是不引入内存问题。这可以通过良好的代码风格和设计来实现的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在写大型C&amp;#x2F;C++工程时难免会发生内存泄漏现象，系统编程中一个重要的方面就是有效地处理与内存相关的问题。你的工作越接近系统，你就需要面对越多的内存问题。有时这些问题非常琐碎，而更多时候它会演变成一个调试内存问题的恶梦。 常见的内存问题一共七种：&lt;/p&gt;
&lt;ol&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>top</title>
    <link href="http://example.com/posts/top.html"/>
    <id>http://example.com/posts/top.html</id>
    <published>2024-11-24T15:24:01.000Z</published>
    <updated>2024-11-24T15:24:22.298Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">ps -ef | grep xxx //xxx为进程名字<br></code></pre></td></tr></table></figure><p>通过ps找到进程号，通过如下命令可以查看该进程下的所有<strong>线程</strong>CPU利用率，注意这里是该进程PID下对应的所有线程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">top -H -p pid<br></code></pre></td></tr></table></figure><p>例如进程pid为5810，则命令为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">top -H -p <span class="hljs-number">5810</span><br></code></pre></td></tr></table></figure><h2 id="一、top命令的使用帮助"><a href="#一、top命令的使用帮助" class="headerlink" title="一、top命令的使用帮助"></a>一、top命令的使用帮助</h2><h3 id="1、top命令的选项"><a href="#1、top命令的选项" class="headerlink" title="1、top命令的选项"></a>1、top命令的选项</h3><p>top命令的使用方法：top [-d number] | top [-bnp]</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>选项</td><td>解析</td></tr><tr><td>-b</td><td>以批处理模式操作；</td></tr><tr><td>-c</td><td>显示完整的治命令；</td></tr><tr><td>-d</td><td>屏幕刷新间隔时间；</td></tr><tr><td>-I</td><td>忽略失效过程；</td></tr><tr><td>-s</td><td>保密模式；</td></tr><tr><td>-S</td><td>累积模式；</td></tr><tr><td>-i&lt;时间&gt;</td><td>设置间隔时间；</td></tr><tr><td>-u&lt;用户名&gt;</td><td>指定用户名；</td></tr><tr><td>-p&lt;进程号&gt;</td><td>指定进程；</td></tr><tr><td>-n&lt;次数&gt;</td><td>循环显示的次数。</td></tr></tbody></table><h2 id="二、top命令的交换命令"><a href="#二、top命令的交换命令" class="headerlink" title="二、top命令的交换命令"></a>二、top命令的交换命令</h2><p>在top命令执行过程中可以使用的一些交互命令。这些命令都是单字母的，如果在命令行中使用了-s选项， 其中一些命令可能会被屏蔽。</p><p><strong>也就是在top命令运行过程中，可以按下如下案件，会按照相应指令显示</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Bash">h：显示帮助画面，给出一些简短的命令总结说明；<br>k：终止一个进程；<br>i：忽略闲置和僵死进程，这是一个开关式命令；<br>q：退出程序；<br>r：重新安排一个进程的优先级别；<br>S：切换到累计模式；<br>s：改变两次刷新之间的延迟时间（单位为s），如果有小数，就换算成ms。输入0值则系统将不断刷新，默认值是5s；<br>f或者F：从当前显示中添加或者删除项目；<br>o或者O：改变显示项目的顺序；<br>l：切换显示平均负载和启动时间信息；<br>m：切换显示内存信息；<br>t：切换显示进程和CPU状态信息；<br>c：切换显示命令名称和完整命令行；<br>M：以内存的使用资源排序显示；<br>P：根据CPU使用百分比大小进行排序；<br>T：根据时间/累计时间进行排序；<br>w：将当前设置写入~/.toprc文件中。<br></code></pre></td></tr></table></figure><h2 id="三、top显示信息解释"><a href="#三、top显示信息解释" class="headerlink" title="三、top显示信息解释"></a>三、top显示信息解释</h2><h3 id="1、top的第一行解释"><a href="#1、top的第一行解释" class="headerlink" title="1、top的第一行解释"></a>1、top的第一行解释</h3><p>在命令行输入top，进入系统监控信息的交互界面，第一行解释如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-number">10</span>:<span class="hljs-number">40</span>:<span class="hljs-number">53</span>          表示当前时间<br>up  <span class="hljs-number">7</span>:<span class="hljs-number">09</span>         系统运行时间，格式为时：分。<br><span class="hljs-number">3</span> users      当前登录用户数<br>load average: <span class="hljs-number">0.05</span>, <span class="hljs-number">0.03</span>, <span class="hljs-number">0.05</span>        系统负载，即任务队列的平均长度。 三个数值分别为 <span class="hljs-number">1</span>分钟、<span class="hljs-number">5</span>分钟、<span class="hljs-number">15</span>分钟前到现在的平均值。<br></code></pre></td></tr></table></figure><p><img src="https://hwwyaazvtut.feishu.cn/space/api/box/stream/download/asynccode/?code=MTVlZDRhZGZiM2ZmODg1N2E5YjFiZDAwMjkwNTkyYzVfNElvVk1FM2Z0bThxa3VlSmVBdU5MajJOeUpXbFVSc0lfVG9rZW46WmFGNWI1c1N4b0NMNUV4aFhZU2NVdERDbmZlXzE3MjEzMTI0NDQ6MTcyMTMxNjA0NF9WNA"></p><h3 id="2、top的第二、三行信息解释"><a href="#2、top的第二、三行信息解释" class="headerlink" title="2、top的第二、三行信息解释"></a>2、top的第二、三行信息解释</h3><p>在命令行输入top，进入系统监控信息的交互界面，第2、3行为进程和CPU的信息，当有多个CPU时，这些内容可能会超过两行，</p><p>第二行解释如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-number">216</span> total          进程总数<br><span class="hljs-number">1</span> running          正在运行的进程数<br><span class="hljs-number">215</span> sleeping       睡眠的进程数<br><span class="hljs-number">0</span> stopped          停止的进程数<br><span class="hljs-number">0</span> zombie          僵尸进程数<br><span class="hljs-number">0.0</span> us              用户空间占用CPU百分比<br><span class="hljs-number">0.1</span> sy              内核空间占用CPU百分比<br><span class="hljs-number">0.0</span> ni              用户进程空间内改变过优先级的进程占用CPU百分比<br><span class="hljs-number">99.9</span> id              空闲CPU百分比<br><span class="hljs-number">0.0</span> wa              等待输入输出的CPU时间百分比<br><span class="hljs-number">0.0</span> hi              硬中断（Hardware IRQ）占用CPU的百分比<br><span class="hljs-number">0.0</span> si              软中断（Software Interrupts）占用CPU的百分比<br><span class="hljs-number">0.0</span> st              虚拟CPU等待实际CPU的时间的百分比。<br></code></pre></td></tr></table></figure><h3 id="3、top的第四、五行信息解释"><a href="#3、top的第四、五行信息解释" class="headerlink" title="3、top的第四、五行信息解释"></a>3、top的第四、五行信息解释</h3><p>第四行及第五行主要显示系统的内存信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C">KiB Mem: <span class="hljs-number">12119056</span> tota         物理内存总量<br><span class="hljs-number">10016948</span> <span class="hljs-built_in">free</span>                 空闲内存总量<br><span class="hljs-number">923252</span> used                    使用的物理内存总量<br><span class="hljs-number">1178856</span> buff/cache             用作内核缓存的内存量<br>KiB Swap: <span class="hljs-number">2093052</span> total         交换区总量<br><span class="hljs-number">267544</span> used                     使用的交换区总量<br><span class="hljs-number">2093052</span> <span class="hljs-built_in">free</span>                 空闲交换区总量<br><span class="hljs-number">0</span> used                         缓冲的交换区总量。<br><span class="hljs-number">10742188</span> avail Mem             代表可用于进程下一次分配的物理内存数量<br></code></pre></td></tr></table></figure><h3 id="4、top的进程信息"><a href="#4、top的进程信息" class="headerlink" title="4、top的进程信息"></a>4、top的进程信息</h3><p>top命令的交换界面主要区域，监控系统进程的实时状态信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C">PID            进程id<br>USER    进程所有者的用户名<br>PR            优先级<br>NI            nice值，负值表示高优先级，正值表示低优先级。<br>VIRT    进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES<br>RES            进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA<br>SHR            共享内存大小，单位kb<br>S            进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程<br>%CPU    上次更新到现在的CPU时间占用百分比<br>%MEM    进程使用的物理内存百分比<br>TIME+   进程使用的CPU时间总计，单位<span class="hljs-number">1</span>/<span class="hljs-number">100</span>秒<br>COMMAND 命令名/命令行<br></code></pre></td></tr></table></figure><p>其余监控项解释</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Bash">PPID        父进程<span class="hljs-built_in">id</span><br>RUSER        Real user name<br>UID            进程所有者的用户<span class="hljs-built_in">id</span><br>GROUP   进程所有者的组名<br>TTY            启动进程的终端名。不是从终端启动的进程则显示为 ?<br>P            最后使用的CPU，仅在多CPU环境下有意义<br>TIME        进程使用的CPU时间总计，单位秒<br>SWAP        进程使用的虚拟内存中，被换出的大小，单位kb<br>CODE        可执行代码占用的物理内存大小，单位kb<br>DATA        可执行代码以外的部分(数据段+栈)占用的物理内存大小，单位kb<br>nFLT        页面错误次数<br>nDRT        最后一次写入到现在，被修改过的页面数。<br>WCHAN        若该进程在睡眠，则显示睡眠中的系统函数名<br>Flags        任务标志<br></code></pre></td></tr></table></figure><h2 id="四、top命令的基本使用"><a href="#四、top命令的基本使用" class="headerlink" title="四、top命令的基本使用"></a>四、top命令的基本使用</h2><p>1、查看当前系统cpu占用最高的进程</p><p>进入top交互界面后，按P键对CPU负载的进程进行排列。</p><p>2、查看当前系统内存使用最高的进程</p><p>进入top交互界面后，按M键对CPU负载的进程进行排列。</p><p>3、对排序的列进行高亮显示</p><p>敲击键盘‘x’（打开&#x2F;关闭排序列的加亮效果）</p><p>4、对运行的进程进行高亮显示</p><p>敲击键盘‘b’（打开关闭加亮效果），对运行的进程进行高亮显示</p>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code clas</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>tcpdump</title>
    <link href="http://example.com/posts/tcpdump.html"/>
    <id>http://example.com/posts/tcpdump.html</id>
    <published>2024-11-24T15:21:54.000Z</published>
    <updated>2024-11-24T15:22:05.753Z</updated>
    
    <content type="html"><![CDATA[<p>tmpdump用于抓包，一个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">tcpdump -i any host <span class="hljs-number">192.168</span>.x.x -s0 -vvv -w <span class="hljs-number">1.</span>cap<br></code></pre></td></tr></table></figure><ul><li>-i any 任何网络</li><li>-s0 防止截断</li><li>-w写入文件</li><li>-vvv详细的信息</li></ul><p>最终得到一个名为1.cap的文件，可以使用wireshark工具打开</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;tmpdump用于抓包，一个例子：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>sed</title>
    <link href="http://example.com/posts/sed.html"/>
    <id>http://example.com/posts/sed.html</id>
    <published>2024-11-24T15:21:02.000Z</published>
    <updated>2024-11-24T15:21:13.640Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/2301_78315274/article/details/133880462">https://blog.csdn.net/2301_78315274/article/details/133880462</a></p><p>1、将每行第一个111替换为AAA</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">sed -i <span class="hljs-string">&quot;s/111/AAA/&quot;</span> a.txt<br></code></pre></td></tr></table></figure><p>-i作用会修改源文件，如这里的a.txt，如果不加-i就不会修改，只是命令回显改变了</p><p>2、替换所有的111为AAA</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1.</span> sed -i <span class="hljs-string">&quot;s/111/AAA/g&quot;</span> a.txt<br></code></pre></td></tr></table></figure><p>3、替换第一到四行的所有111为AAA</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">sed <span class="hljs-string">&quot;1,4s/111/AAA/g&quot;</span> a.txt<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/2301_78315274/article/details/133880462&quot;&gt;https://blog.csdn.net/2301_78315274/article/details/133880462&lt;/a&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>tar</title>
    <link href="http://example.com/posts/tar.html"/>
    <id>http://example.com/posts/tar.html</id>
    <published>2024-11-24T15:20:22.000Z</published>
    <updated>2024-11-24T15:20:37.038Z</updated>
    
    <content type="html"><![CDATA[<p>tar全称是tape archive，初衷是将多个文件写入磁带。首先，需要分清两个概念——打包与压缩。<strong>打包</strong>：将多个文件汇总成一个文件。<strong>压缩</strong>：将一个大文件通过压缩算法变成一个小文件。而tar命令执行的打包流程，真正执行压缩的是使用的压缩算法，比如gzip、bzip2、xz。tar命令在Linux社区内十分受欢迎，其中一个原因就是灵活性强，可以根据需要选择不同的压缩算法。</p><h2 id="一、常用参数"><a href="#一、常用参数" class="headerlink" title="一、常用参数"></a>一、常用参数</h2><ol><li>打包过程</li></ol><ul><li><code>-c</code>或<code>--create</code>。创建档案文件（可以理解为压缩包名）</li><li><code>-x</code>或<code>--extract</code>。解压（提取）文件</li><li><code>-f</code>或<code>--file</code>。指定档案文件，告诉tar命令，后面是文件名</li><li><code>-t</code>或<code>--list</code>。列出档案文件的内容</li><li><code>-v</code>或<code>--verbose</code>。显示处理文件的详细信息</li></ul><p>当多个参数简写在一起的时候，可以只用一个<code>-</code>。在实际使用中，最常使用的参数就是<code>-cvf</code>，即创建压缩包，并以显示详细处理信息。</p><ol start="2"><li>压缩过程</li></ol><ul><li><code>gzip</code>：参数<code>-z</code>或<code>--gzip</code>；文件拓展名：<code>.tar.gz</code>或<code>.tgz</code></li><li><code>bzip2</code>：<code>-j</code>或<code>--bzip2</code>；<code>.tar.bz2</code></li><li><code>xz</code>：<code>-J</code>或<code>--xz</code>；<code>.tar.xz</code></li></ul><p>压缩算法之间的区别：</p><table><thead><tr><th>压缩算法</th><th><code>gzip</code></th><th><code>bzip2</code></th><th><code>xz</code></th></tr></thead><tbody><tr><td>参数</td><td><code>-z</code></td><td><code>-j</code></td><td><code>-J</code></td></tr><tr><td>文件拓展名</td><td><code>.tar.gz</code></td><td><code>.tar.bz2</code></td><td><code>.tar.xz</code></td></tr><tr><td>压缩速度</td><td>快</td><td>中</td><td>慢</td></tr><tr><td>解压速度</td><td>快</td><td>中</td><td>中</td></tr><tr><td>压缩比</td><td>低</td><td>中</td><td>高</td></tr><tr><td>资源占用</td><td>少</td><td>中</td><td>高</td></tr><tr><td>适用场景</td><td>快速压缩&#x2F;解压</td><td>高压缩比</td><td>最大压缩比</td></tr></tbody></table><p>在日常使用中，使用<code>gzip</code>压缩就可以了，虽然压缩比低，但是它十分的快。并且如果被压缩的文件本身就比较小，使用<code>xz</code>压缩的结果也不会少太多。因此，日常使用建议<code>gzip</code>，既想要速度也想要压缩比建议<code>bzip2</code>，超大文件建议<code>xz</code>。</p><h2 id="二、示例"><a href="#二、示例" class="headerlink" title="二、示例"></a>二、示例</h2><p>流程相似，只需更换压缩算法的参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">压缩。压缩包名 + 被压缩的目录或者文件路径</span><br>tar -czvf archive_name.tar.gz path_to_compress<br><span class="hljs-meta prompt_"># </span><span class="language-bash">解压。用什么压缩算法压缩的，就用什么压缩算法解压</span><br>tar -xzvf archive_name.tar.gz <br><span class="hljs-meta prompt_"># </span><span class="language-bash">解压到当前目录</span><br>tar -xzvf archive_name.tar.gz -C path_to_extract <br><span class="hljs-meta prompt_"># </span><span class="language-bash">解压至指定目录。 -C （change directory）指出目录地址</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;tar全称是tape archive，初衷是将多个文件写入磁带。首先，需要分清两个概念——打包与压缩。&lt;strong&gt;打包&lt;/strong&gt;：将多个文件汇总成一个文件。&lt;strong&gt;压缩&lt;/strong&gt;：将一个大文件通过压缩算法变成一个小文件。而tar命令执行的打包流程</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>objdump</title>
    <link href="http://example.com/posts/objdump.html"/>
    <id>http://example.com/posts/objdump.html</id>
    <published>2024-11-24T15:19:04.000Z</published>
    <updated>2024-11-24T15:19:19.309Z</updated>
    
    <content type="html"><![CDATA[<p>objdump提供了对二进制文件进行反汇编和查看目标文件信息的能力。用于分析目标文件（object file）和可执行文件（executable file）。它可以显示二进制文件的汇编代码、符号表、段信息等，是理解程序底层实现、调试和逆向工程的有力助手。</p><h2 id="一、objdump的基本用法"><a href="#一、objdump的基本用法" class="headerlink" title="一、objdump的基本用法"></a>一、objdump的基本用法</h2><p>显示目标文件的反汇编代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">objdump -d your_binary<br></code></pre></td></tr></table></figure><p>该命令会显示目标文件中所有段的反汇编代码。这是一种深入了解程序执行逻辑的方式。</p><p>显示符号表信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">objdump -t your_binary<br></code></pre></td></tr></table></figure><p>该命令会显示目标文件的符号表，包括函数名、变量名等信息。</p><p>显示文件头信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">objdump -f your_binary<br></code></pre></td></tr></table></figure><p>该命令显示目标文件的文件头信息，包括文件格式、入口点地址等。objdump 的使用还可以根据需求加入一些参数来获取更详细的信息。</p><p>显示所有段的详细信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">objdump -p your_binary<br></code></pre></td></tr></table></figure><p>这将显示目标文件中所有段的详细信息，包括每个段的大小、偏移量等。</p><p>显示特定段的反汇编代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">objdump -s -j section_name your_binary<br></code></pre></td></tr></table></figure><p>这将显示指定段（section_name）的反汇编代码。</p><p>只显示符号表的信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">objdump -T your_binary<br></code></pre></td></tr></table></figure><p>该命令显示符号表的信息，但不显示反汇编代码。</p><p>显示源代码和反汇编代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">objdump -S your_binary<br></code></pre></td></tr></table></figure><p>这将显示源代码和反汇编代码的混合视图，方便理解源代码和汇编之间的对应关系。</p><p>以指定格式显示反汇编代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">objdump -M intel -d your_binary<br></code></pre></td></tr></table></figure><p>-M 参数允许你指定反汇编代码的输出格式，例如 intel 或 att。</p><p>以上是一些常见的 objdump 用法和参数。通过组合使用这些参数，你可以根据具体的需求更深入地了解目标文件的内部结构和代码执行逻辑。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;objdump提供了对二进制文件进行反汇编和查看目标文件信息的能力。用于分析目标文件（object file）和可执行文件（executable file）。它可以显示二进制文件的汇编代码、符号表、段信息等，是理解程序底层实现、调试和逆向工程的有力助手。&lt;/p&gt;
&lt;h2 i</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>objcopy</title>
    <link href="http://example.com/posts/objcopy.html"/>
    <id>http://example.com/posts/objcopy.html</id>
    <published>2024-11-24T15:18:36.000Z</published>
    <updated>2024-11-24T15:18:50.441Z</updated>
    
    <content type="html"><![CDATA[<p>objcopy转换elf文件为bin文件，以下是一个将boot.elf转为boot.bin的命令</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">arm-linux-objcopy -O binary -R .note -R .comment -S boot.elf boot.bin<br></code></pre></td></tr></table></figure><ul><li>使用 -O binary (或–out-target&#x3D;binary) 输出为原始的二进制文件</li><li>使用 -R .note (或–remove-section) 输出文件中不要.note这个section，缩小了文件尺寸</li><li>使用 -S (或 –strip-all) 输出文件中不要重定位信息和符号信息，缩小了文件尺寸</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;objcopy转换elf文件为bin文件，以下是一个将boot.elf转为boot.bin的命令&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>nm</title>
    <link href="http://example.com/posts/nm.html"/>
    <id>http://example.com/posts/nm.html</id>
    <published>2024-11-24T15:17:52.000Z</published>
    <updated>2024-11-24T15:18:05.074Z</updated>
    
    <content type="html"><![CDATA[<p>nm命令是linux下针对某些特定文件的分析工具，能够列出库文件（.a、.lib）、目标文件（*.o）、可执行文件的符号表。</p><h2 id="一、nm命令的常用参数"><a href="#一、nm命令的常用参数" class="headerlink" title="一、nm命令的常用参数"></a>一、nm命令的常用参数</h2><ul><li>-A 或 -o 或 –print-file-name：打印出每个符号属于的文件</li><li>-a 或 –debug-syms：显示调试符号。</li><li>-B：等同于–format&#x3D;bsd，用来兼容MIPS的nm。</li><li>-C 或 –demangle：将低级符号名解码(demangle)成用户级名字。这样可以使得C++函数名具有可读性。</li><li>-D 或 –dynamic：显示动态符号。该任选项仅对于动态目标(例如特定类型的共享库)有意义。</li><li>-f forma 或 –format&#x3D;formatt：使用format格式输出。format可以选取bsd、sysv或posix，该选项在GNU的nm中有用。默认为bsd。</li><li>-g 或 –extern-only：仅显示外部符号。</li><li>-n 、-v 或 –numeric-sort：按符号对应地址的顺序排序，而非按符号名的字符顺序。</li><li>-p 或 –no-sort：按目标文件中遇到的符号顺序显示，不排序。</li><li>-P 或 –portability：使用POSIX.2标准输出格式代替默认的输出格式。等同于使用任选项-f posix。</li><li>-s 或 –print-armap：当列出库中成员的符号时，包含索引。索引的内容包含：哪些模块包含哪些名字的映射。</li><li>-r 或 –reverse-sort：反转排序的顺序(例如，升序变为降序)。</li><li>–size-sort：按大小排列符号顺序。该大小是按照一个符号的值与它下一个符号的值进行计算的。</li><li>-t radix 或 –radix&#x3D;radix：使用radix进制显示符号值。radix只能为“d”表示十进制、“o”表示八进制或“x”表示十六进制。</li><li>–target&#x3D;bfdname：指定一个目标代码的格式，而非使用系统的默认格式。</li><li>-u 或 –undefined-only：仅显示没有定义的符号(那些外部符号)。</li><li>-l 或 –line-numbers：对每个符号，使用调试信息来试图找到文件名和行号。对于已定义的符号，查找符号地址的行号。对于未定义符号，查找指向符号重定位入口的行号。如果可以找到行号信息，显示在符号信息之后。</li><li>-V 或 –version：显示nm的版本号。</li><li>–help：显示nm的任选项。</li></ul><p>举个栗子</p><p>编写源文件test.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> ch = <span class="hljs-string">&#x27;x&#x27;</span>;<br><span class="hljs-type">int</span> uninit;<br><span class="hljs-type">int</span> init = <span class="hljs-number">10</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">function</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> *ref = &amp;init;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> sta_int = <span class="hljs-number">10</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, ch);<br>&#125;<br></code></pre></td></tr></table></figure><p>编译test.c文件 生成test.o</p><p><code>gcc -c test.c</code></p><p>用nm命令分析符号表</p><p><code>nm -n test.o</code>（-n以地址排序，方便查看）</p><p>输出结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C">                 U <span class="hljs-built_in">putchar</span><br><span class="hljs-number">0000000000000000</span> R ch<br><span class="hljs-number">0000000000000000</span> T function<br><span class="hljs-number">0000000000000000</span> D init<br><span class="hljs-number">0000000000000004</span> d sta_int<span class="hljs-number">.2182</span><br><span class="hljs-number">0000000000000004</span> C uninit<br></code></pre></td></tr></table></figure><h2 id="二、nm信息的含义"><a href="#二、nm信息的含义" class="headerlink" title="二、nm信息的含义"></a>二、nm信息的含义</h2><p>第一列：符号值，即该符号的起始地址<br>第二列：符号类型，各字母代表什么类型在下一小节中介绍<br>第三列：符号名称</p><h2 id="三、输出符号类型详解"><a href="#三、输出符号类型详解" class="headerlink" title="三、输出符号类型详解"></a>三、输出符号类型详解</h2><p>符号类型大写代表全局符号，小写代表本地符号</p><ul><li>A 该符号的值是绝对的，在以后的链接过程中，不允许进行改变。这样的符号值，常常出现在中断向量表中，例如用符号来表示各个中断向量函数在中断向量表中的位置。</li><li>B 该符号的值出现在非初始化数据段(bss)中。例如，在一个文件中定义全局static int test。则该符号test的类型为b，位于bss section中。其值表示该符号在bss段中的偏移。一般而言，bss段分配于RAM中。</li><li>C 该符号为common。common symbol是未初始话数据段。该符号没有包含于一个普通section中。只有在链接过程中才进行分配。符号的值表示该符号需要的字节数。例如在一个c文件中，定义int test，并且该符号在别的地方会被引用，则该符号类型即为C。否则其类型为B。</li><li>D 该符号位于初始话数据段中。一般来说，分配到data section中。例如定义全局int baud_table[5] &#x3D; {9600, 19200, 38400, 57600, 115200}，则会分配于初始化数据段中。</li><li>G 该符号也位于初始化数据段中。主要用于small object提高访问small data object的一种方式。</li><li>I 该符号是对另一个符号的间接引用。</li><li>N 该符号是一个debugging符号。</li><li>R 该符号位于只读数据区。例如定义全局const int test[] &#x3D; {123, 123};则test就是一个只读数据区的符号。注意在cygwin下如果使用gcc直接编译成MZ格式时，源文件中的test对应_test，并且其符号类型为D，即初始化数据段中。但是如果使用m6812-elf-gcc这样的交叉编译工具，源文件中的test对应目标文件的test,即没有添加下划线，并且其符号类型为R。一般而言，位于rodata section。值得注意的是，如果在一个函数中定义const char *test &#x3D; “abc”, const char test_int &#x3D; 3。使用nm都不会得到符号信息，但是字符串“abc”分配于只读存储器中，test在rodata section中，大小为4。</li><li>S 符号位于非初始化数据区，用于small object。</li><li>T 该符号位于代码区text section。</li><li>U 该符号在当前文件中是未定义的，即该符号的定义在别的文件中。例如，当前文件调用另一个文件中定义的函数，在这个被调用的函数在当前就是未定义的；但是在定义它的文件中类型是T。但是对于全局变量来说，在定义它的文件中，其符号类型为C，在使用它的文件中，其类型为U。</li><li>V 该符号是一个weak object。</li><li>W 该符号是没有被明确标记为weak object的弱符号类型。</li><li>该符号是a.out格式文件中的stabs symbol。</li><li>? 该符号类型没有定义。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;nm命令是linux下针对某些特定文件的分析工具，能够列出库文件（.a、.lib）、目标文件（*.o）、可执行文件的符号表。&lt;/p&gt;
&lt;h2 id=&quot;一、nm命令的常用参数&quot;&gt;&lt;a href=&quot;#一、nm命令的常用参数&quot; class=&quot;headerlink&quot; title=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>readelf</title>
    <link href="http://example.com/posts/readelf.html"/>
    <id>http://example.com/posts/readelf.html</id>
    <published>2024-11-24T15:16:27.000Z</published>
    <updated>2024-11-24T15:16:45.646Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、三类目标文件（ELF）："><a href="#一、三类目标文件（ELF）：" class="headerlink" title="一、三类目标文件（ELF）："></a>一、三类目标文件（ELF）：</h2><p>1.可重定位目标文件 (.o )</p><p>每个 .o 文件都是由对应的 .c 文件通过编译器和汇编器生成；包含代码和数据，代码和数据地址都从0开始。通过 gcc -c xxx.c 得到。</p><p>2.可执行目标文件（默认为a.out）</p><p>由链接器生成，包含的代码和数据可以直接通过加载器加载到内存中并被执行。通过gcc -o xxx.c 得到。</p><p>3.共享目标文件 (.so）</p><p>特殊的可重定位目标文件，可以在链接(静态共享库)时加入目标文件或加载时或运行时(动态共享库)被动态的加载到内存并执行。在 windows 中被称为 Dynamic Link Libraries(DLLs)。 gcc xxx.c -fPIC -shared -o libxxx.so （-fPIC 作用于编译阶段，告诉编译器产生与位置无关代码。）</p><p>readelf命令：</p><p>通过readelf来区分上面三种类型的ELF文件，每种类型文件的头部信息是不一样的。</p><h2 id="二、readelf-h"><a href="#二、readelf-h" class="headerlink" title="二、readelf -h"></a>二、readelf -h</h2><p>readelf -h main.o -h等价于–file-header</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Bash"> 1 ELF Header:<br> 2   Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00<br> 3   Class:                             ELF64<br> 4   Data:                              2<span class="hljs-string">&#x27;s complement, little endian</span><br><span class="hljs-string"> 5   Version:                           1 (current)</span><br><span class="hljs-string"> 6   OS/ABI:                            UNIX - System V</span><br><span class="hljs-string"> 7   ABI Version:                       0</span><br><span class="hljs-string"> 8   Type:                              REL (Relocatable file)</span><br><span class="hljs-string"> 9   Machine:                           Advanced Micro Devices X86-64</span><br><span class="hljs-string">10   Version:                           0x1</span><br><span class="hljs-string">11   Entry point address:               0x0</span><br><span class="hljs-string">12   Start of program headers:          0 (bytes into file)</span><br><span class="hljs-string">13   Start of section headers:          720 (bytes into file)</span><br><span class="hljs-string">14   Flags:                             0x0</span><br><span class="hljs-string">15   Size of this header:               64 (bytes)</span><br><span class="hljs-string">16   Size of program headers:           0 (bytes)</span><br><span class="hljs-string">17   Number of program headers:         0</span><br><span class="hljs-string">18   Size of section headers:           64 (bytes)</span><br><span class="hljs-string">19   Number of section headers:         12</span><br><span class="hljs-string">20   Section header string table index: 11</span><br></code></pre></td></tr></table></figure><ul><li>第 1 行，ELF Header: 指名 ELF 文件头开始。</li><li>第 2 行，Magic 魔数，用来指名该文件是一个 ELF 目标文件。第一个字节 7F 是个固定的数；后面的 3 个字节正是 E, L, F 三个字母的 ASCII 形式。</li><li>第 3 行，CLASS 表示文件类型，这里是 64位的 ELF 格式。</li><li>第 4 行，Data 表示文件中的数据是按照什么格式组织(大端或小端)的，不同处理器平台数据组织格式可能就不同，如x86平台为小端存储格式。</li><li>第 5 行，当前 ELF 文件头版本号，这里版本号为 1 。</li><li>第 6 行，OS&#x2F;ABI ，指出操作系统类型，ABI 是 Application Binary Interface 的缩写。</li><li>第 7 行，ABI 版本号，当前为 0 。</li><li>第 8 行，Type 表示文件类型。ELF 文件有 3 种类型，一种是如上所示的 Relocatable file 可重定位目标文件，一种是可执行文件(Executable)，另外一种是共享库(Shared Library) 。 [这里就是区分上面三种类型的ELF文件]</li><li>第 9 行，机器平台类型，这里是在X86-64位机器。</li><li>第 10 行，当前目标文件的版本号。</li><li>第 11 行，程序的虚拟地址入口点，因为这还不是可运行的程序，故而这里为零。如果是可运行程序，这个地址并不是main函数的地址，而是_start函数的地址，_start由链接器创建，_start是为了初始化程序。通过这个命令可以看到_start函数，objdump -d -j .text a.out(默认，改名之后需更改此处)。</li><li>第 12 行，与 11 行同理，这个目标文件没有 Program Headers。</li><li>第 13 行，sections 头开始处，这里 720 是十进制，表示从地址偏移 0x450 处开始。</li><li>第 14 行，是一个与处理器相关联的标志，x86 平台上该处为 0 。</li><li>第 15 行，ELF 文件头的字节数。64bytes</li><li>第 16 行，因为这个不是可执行程序，故此处大小为 0。</li><li>第 17 行，同理于第 16 行。</li><li>第 18 行，sections header 的大小，这里每个 section 头大小为 64bytes。</li><li>第 19 行，一共有多少个 section 头，这里是 12个。</li><li>第 20 行，section 头字符串表索引号。区中存储的信息是用来链接使用的，主要包括：程序代码、程序数据（变量）、重定向信息等。比如：Code section保存的是代码，data section保存的是初始化或未初始化的数据，等等。</li></ul><h2 id="三、readelf-S-main"><a href="#三、readelf-S-main" class="headerlink" title="三、readelf -S main"></a>三、readelf -S main</h2><p>功能：查看区内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs Bash">1 There are 29 section headers, starting at offset 0x1948:<br> 2 Section Headers:<br> 3   [Nr] Name              Type             Address           Offset      Size              EntSize          Flags  Link  Info  Align<br> 4   [ 0]                   NULL             0000000000000000  00000000       0000000000000000  0000000000000000           0     0     0<br> 5   [ 1] .interp           PROGBITS         0000000000000238  00000238       000000000000001c  0000000000000000   A       0     0     1<br> 6   [ 2] .note.ABI-tag     NOTE             0000000000000254  00000254       0000000000000020  0000000000000000   A       0     0     4<br> 7   [ 3] .note.gnu.build-i NOTE             0000000000000274  00000274     0000000000000024  0000000000000000   A       0     0     4<br> 8   [ 4] .gnu.hash         GNU_HASH         0000000000000298  00000298       000000000000001c  0000000000000000   A       5     0     8<br> 9   [ 5] .dynsym           DYNSYM           00000000000002b8  000002b8       0000000000000090  0000000000000018   A       6     1     8<br>10   [ 6] .dynstr           STRTAB           0000000000000348  00000348       000000000000007d  0000000000000000   A       0     0     1<br>11   [ 7] .gnu.version      VERSYM           00000000000003c6  000003c6     000000000000000c  0000000000000002   A       5     0     2<br>12   [ 8] .gnu.version_r    VERNEED          00000000000003d8  000003d8       0000000000000020  0000000000000000   A       6     1     8<br>13   [ 9] .rela.dyn         RELA             00000000000003f8  000003f8       00000000000000c0  0000000000000018   A       5     0     8<br>14   [10] .init             PROGBITS         00000000000004b8  000004b8     0000000000000017  0000000000000000  AX       0     0     4<br>15   [11] .plt              PROGBITS         00000000000004d0  000004d0      0000000000000010  0000000000000010  AX       0     0     16<br>16   [12] .plt.got          PROGBITS         00000000000004e0  000004e0       0000000000000008  0000000000000008  AX       0     0     8<br>17   [13] .text             PROGBITS         00000000000004f0  000004f0       00000000000001e2  0000000000000000  AX       0     0     16<br>18   [14] .fini             PROGBITS         00000000000006d4  000006d4     0000000000000009  0000000000000000  AX       0     0     4<br>19   [15] .rodata           PROGBITS         00000000000006e0  000006e0       0000000000000004  0000000000000004  AM       0     0     4<br>20   [16] .eh_frame_hdr     PROGBITS         00000000000006e4  000006e4      0000000000000044  0000000000000000   A       0     0     4<br>21   [17] .eh_frame         PROGBITS         0000000000000728  00000728      0000000000000128  0000000000000000   A       0     0     8<br>22   [18] .init_array       INIT_ARRAY       0000000000200df0  00000df0      0000000000000008  0000000000000008  WA       0     0     8<br>23   [19] .fini_array       FINI_ARRAY       0000000000200df8  00000df8     0000000000000008  0000000000000008  WA       0     0     8<br>24   [20] .dynamic          DYNAMIC          0000000000200e00  00000e00      00000000000001c0  0000000000000010  WA       6     0     8<br>25   [21] .got              PROGBITS         0000000000200fc0  00000fc0      0000000000000040  0000000000000008  WA       0     0     8<br>26   [22] .data             PROGBITS         0000000000201000  00001000      0000000000000018  0000000000000000  WA       0     0     8<br>27   [23] .bss              NOBITS           0000000000201018  00001018       0000000000000008  0000000000000000  WA       0     0     1<br>28   [24] .comment          PROGBITS         0000000000000000  00001018       000000000000002b  0000000000000001  MS       0     0     1<br>29   [25] .symtab           SYMTAB           0000000000000000  00001048      0000000000000600  0000000000000018          26    43     8<br>30   [26] .strtab           STRTAB           0000000000000000  00001648       0000000000000200  0000000000000000           0     0     1<br>31   [27] .shstrtab         STRTAB           0000000000000000  00001848      00000000000000f9  0000000000000000           0     0     1<br>32 Key to Flags:<br>33   W (write), A (alloc), X (execute), M (merge), S (strings), I (info),<br>34   L (<span class="hljs-built_in">link</span> order), O (extra OS processing required), G (group), T (TLS),<br>35   C (compressed), x (unknown), o (OS specific), E (exclude),<br>36   l (large), p (processor specific)<br></code></pre></td></tr></table></figure><ul><li>.text：已编译程序的机器代码（二进制指令），该区的标志为X表示可执行。</li><li>.rodata：只读数据，比如printf语句中的格式串和开关（switch）语句的跳转表。</li><li>.data：已初始化的全局C变量。局部C变量在运行时被保存在栈中，既不出现在.data中，也不出现在.bss节中。</li><li>.bss：未初始化的全局C变量。在目标文件中并没有分配实际的空间给它，它只是一个占位符。目标文件格式区分初始化和未初始化变量是为了空间效率在：在目标文件中，未初始化变量不需要占据任何实际的磁盘空间。</li><li>.symtab：一个符号表（symbol table），它存放在程序中被定义和引用的函数和全局变量的信息。一些程序员错误地认为必须通过-g选项来编译一个程序，得到符号表信息。实际上，每个可重定位目标文件在.symtab中都有一张符号表。然而，和编译器中的符号表不同，.symtab符号表不包含局部变量的表目。</li><li>.rel.text：当链接噐把这个目标文件和其他文件结合时，.text节中的许多位置都需要修改。一般而言，任何调用外部函数或者引用全局变量的指令都需要修改。另一方面调用本地函数的指令则不需要修改。注意，可执行目标文件中并不需要重定位信息，因此通常省略，除非使用者显式地指示链接器包含这些信息。</li><li>.rel.data：被模块定义或引用的任何全局变量的信息。一般而言，任何已初始化全局变量的初始值是全局变量或者外部定义函数的地址都需要被修改。</li><li>.strtab：一个字符串表，其内容包括.symtab和.debug节中的符号表，以及节头部中的节名字。字符串表就是以null结尾的字符串序列。</li><li>.init和.fini保存了进程初始化和结束所用的代码，这通常是由编译器自动添加的。</li></ul><h2 id="四、readelf-s"><a href="#四、readelf-s" class="headerlink" title="四、readelf -s"></a>四、readelf -s</h2><p>readelf -s main.o</p><p>功能：查看符号表，Value的值是符号的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C">Symbol table <span class="hljs-string">&#x27;.symtab&#x27;</span> contains <span class="hljs-number">12</span> entries:<br>   Num:    Value          Size Type    Bind   Vis      Ndx Name<br>     <span class="hljs-number">0</span>: <span class="hljs-number">0000000000000000</span>     <span class="hljs-number">0</span> NOTYPE  LOCAL  DEFAULT  UND<br>     <span class="hljs-number">1</span>: <span class="hljs-number">0000000000000000</span>     <span class="hljs-number">0</span> FILE    LOCAL  DEFAULT  ABS main.c<br>     <span class="hljs-number">2</span>: <span class="hljs-number">0000000000000000</span>     <span class="hljs-number">0</span> SECTION LOCAL  DEFAULT    <span class="hljs-number">1</span><br>     <span class="hljs-number">3</span>: <span class="hljs-number">0000000000000000</span>     <span class="hljs-number">0</span> SECTION LOCAL  DEFAULT    <span class="hljs-number">3</span><br>     <span class="hljs-number">4</span>: <span class="hljs-number">0000000000000000</span>     <span class="hljs-number">0</span> SECTION LOCAL  DEFAULT    <span class="hljs-number">4</span><br>     <span class="hljs-number">5</span>: <span class="hljs-number">0000000000000000</span>     <span class="hljs-number">0</span> SECTION LOCAL  DEFAULT    <span class="hljs-number">6</span><br>     <span class="hljs-number">6</span>: <span class="hljs-number">0000000000000000</span>     <span class="hljs-number">0</span> SECTION LOCAL  DEFAULT    <span class="hljs-number">7</span><br>     <span class="hljs-number">7</span>: <span class="hljs-number">0000000000000000</span>     <span class="hljs-number">0</span> SECTION LOCAL  DEFAULT    <span class="hljs-number">5</span><br>     <span class="hljs-number">8</span>: <span class="hljs-number">0000000000000000</span>     <span class="hljs-number">8</span> OBJECT  GLOBAL DEFAULT    <span class="hljs-number">3</span> <span class="hljs-built_in">array</span><br>     <span class="hljs-number">9</span>: <span class="hljs-number">0000000000000000</span>    <span class="hljs-number">33</span> FUNC    GLOBAL DEFAULT    <span class="hljs-number">1</span> main<br>    <span class="hljs-number">10</span>: <span class="hljs-number">0000000000000000</span>     <span class="hljs-number">0</span> NOTYPE  GLOBAL DEFAULT  UND _GLOBAL_OFFSET_TABLE_<br>    <span class="hljs-number">11</span>: <span class="hljs-number">0000000000000000</span>     <span class="hljs-number">0</span> NOTYPE  GLOBAL DEFAULT  UND sum<br></code></pre></td></tr></table></figure><p>符号表保存了程序实现或使用的所有全局变量和函数，如果程序引用一个自身代码未定义的符号，则称之为未定义符号，这类引用必须在静态链接期间用其他目标模块或库解决，或在加载时通过动态链接解决。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、三类目标文件（ELF）：&quot;&gt;&lt;a href=&quot;#一、三类目标文件（ELF）：&quot; class=&quot;headerlink&quot; title=&quot;一、三类目标文件（ELF）：&quot;&gt;&lt;/a&gt;一、三类目标文件（ELF）：&lt;/h2&gt;&lt;p&gt;1.可重定位目标文件 (.o )&lt;/p&gt;
&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>dm-verity</title>
    <link href="http://example.com/posts/dm-verity.html"/>
    <id>http://example.com/posts/dm-verity.html</id>
    <published>2024-11-24T14:09:23.000Z</published>
    <updated>2024-11-24T15:28:47.465Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一、技术模块简介</strong></p><p>Dm-verity 是 device-mapper 架构下的一个目标设备类型， 通过它来保障设备或者设备分区的完整性。</p><p>dm-verity通常用于验证镜像的完整性。比如常规的系统启动的对根文件系统的验签，耗时很长。可以使用dm-verity替代，由于dm-verity是使用时才进行hash计算校验，所以对启动性能的提高有很大帮助。</p><p>Dm-verity类型的目标设备有两个底层设备，一个是数据设备(data device), 是用来存储实际数据的，另一个是hash设备(hash device), 用来存储hash数据的，这个是用来校验data device数据的完整性的。</p><p>简单的架构图如下：</p><p><img src="https://raw.githubusercontent.com/mengchao666/picture/main/blog2bca569a67ffab1bb48b246e4d57cb2a.png"></p><p>图中映射设备(Mapper Device)和目标设备(Target Device)是一对一关系，对映射设备的读操作被映射成对目标设备的读操作，在目标设备中，dm-verity又将读操作映射为数据设备（Data Device）的读操作。但是在读操作的结束处，dm-verity加了一个额外的校验操作，对读到的数据计算一个hash值，用这个哈希值和存储在哈希设备(Hash Device)</p><p><strong>二、设计原理</strong></p><p>对于本文要介绍的dm-verity功能模块，笔者选择在当前移动终端应用的角度来展开讲解，也就是Android平台在dm-verity的应用。</p><p>Android 端主要是在镜像启动时验证这个功能场景上使用到了 dm-verity 技术，该技术可以对块存储设备进行完整性检查，有助于阻止某些恶意程序对镜像的修改，有助于Android用户在启动设备时确认设备状态与上次使用时是否相同。在系统镜像(比如 system、vendor等)启动时以及运行时可以实时性监测当前镜像是否被篡改。</p><p>通过dm-verity技术，可以确认块设备内容是否跟预期一致，具体的实现原理是利用哈希树(hashtree)做到的。用以下图来形象说明</p><p><img src="https://raw.githubusercontent.com/mengchao666/picture/main/blog519d5a05bc1dbd5572a92395a526d2d1.png"></p><p>(图来自：<a href="https://source.android.com/security/verifiedboot/dm-verity">https://source.android.com/security/verifiedboot/dm-verity</a>)</p><p>简单说明一下这个插图背后的原理：</p><p>在编译(一般应该是运行open)阶段，首先会对系统镜像(比如system.img、vendor.img)按照每4k大小计算对应hash，将这些hash信息存起来，形成上面图中的layer 0层，紧接着会对 layer 0 层同样按照每4k大小计算hash，并将这层的hash信息存起来，形成layer 1层，以此类推，直至最后的hash信息存放在一个4k大小的块中(未填满使用0填充)，这里边存储的hash信息称为 root hash。</p><p>在运行阶段，对于镜像里的文件进行访问时，操作对应所在块设备的存储区域时，会计算当前存储块(按4k大小)的hash值，然后会跟存储在哈希树上对应块的hash值进行比较，如果匹配不上，则认为当前该文件在底层存储被篡改或是损坏了。</p><p>为了更形象的描述下镜像运行时如何利用哈希树做校验的，下面以一个1G大小的镜像为例，来说明一下这个过程：</p><p><img src="https://raw.githubusercontent.com/mengchao666/picture/main/blog3d6e32d1e4c62a2528f3f83da22eea6a.png"></p><p>根据 hashtree 的生成方式，以 1G 的镜像为例：</p><p>1）按照 4K 大小划分，将1G 大小的镜像依顺序划分可得到 262144 个 4k 大小的块</p><p>2）对这 262144 块数据块进行第一层(Level 0) hash 计算，由于 SHA256(具体的hash算法可配置，此例以SHA256为参考) 计算出来的hash值占 256 个字节，一个 4K 的块可以存储 128 个hash值，所以存储这 262144 块数据块的hash值需要花费 2048 块</p><p>3）对第一层存储 hash 值的数据块进行第二层(Level 1) 的 hash 计算，同理，计算这 2048 块hash数据块需要花费 16 块</p><p>4）对第二层存储 hash 值的数据块进行第三层(Level 2) 的 hash 计算，由于第二层的hash数据块小于128块，所以第三层是最后一层，直接计算得到 root hash 数据块(不够4K大小补齐0)。</p><p>细心的读者可能已经发现了，Level 0 层其实已经包含了所有raw data数据块的hash信息了，也就说明Level 0 层已经具备可以验证 raw data 的能力了，为何还需要在 Level 0 的基础上继续算hash组装下一个 Level 层级呢？</p><p>这里要引入一个安全策略设计问题，镜像raw data数据块是由对应的hash信息来校验保证的，为了保证镜像raw data是我们“想要的”，我们还需要对 hash 信息进行合法性验证，简单理解就是要确认这个hash信息是我们“想要的”， 方法就是对这个hash信息再次计算一次hash值，这里称为 root hash，然后添加一些类似于签名保护并保存起来<strong>（通常在实际工作中，在镜像编译阶段将root hash计算出来，保存在镜像的某个地方，通过cms等签名方式保存，启动阶段会进行cms验签以保证root_hash的正确性）</strong>，主要是为了防止 root hash 被非法篡改。在一次 raw data 数据块的校验过程中，需要对 hash 信息计算一次 hash，然后跟保存的 root hash 进行比较，验证了 hash 信息的合法性之后，再来校验对应的 raw data 数据块。</p><p>有了以上背景，再回到刚刚这个“为何还需要在 Level 0 的基础上继续算hash组装下一个 Level 层级”的问题，按照上面的安全策略，如果 hash 信息只有 Level 0 一层的话，接下来对 raw data 数据块的校验将会是这样：每操作一个raw data数据块，都需要计算一次 Level 0 的 hash 值，跟 root hash 进行比较，验证合法之后再对 raw data 数据块进行校验。本文中举例是 1G 的镜像，Level 0用来保存 hash 信息的数据块已经达到 2048 块，如果对面对更大的镜像，Level 0 所占的数据块也会更大，如果是按照上面的计算方法，对 raw data 数据块的校验效率将会非常非常低。</p><p>作为对比，哈希树机制是如何体现出效率呢，下面以具体某一块 raw data 数据块的读取过程来说明其设计原理：</p><p><img src="https://raw.githubusercontent.com/mengchao666/picture/main/blogafbc138ead05da1b26f41abf1b5c35f9.png"></p><p>1）假设目前正需要读取第 200000 块的数据块，通过前面哈希树的构造，可以比较快速的计算出在 Level 0 层，也就是直接对应这个数据块的hash值存储位置，通过对 128 相除以及求余的方式就可以分别计算出该 hash 值存储在具体某一块(块A)以及这一块上的偏移(偏移A)。</p><p>2）确定了 Level 0 层的具体块A后，利用相同的方式可以得到 Level 0 块A在 Level 1 层存储其 hash 值的块B位置以及块B上的偏移(偏移B)</p><p>3）同上述原理，可以最终定位到 Level 1 层块 B 在 Level 2 上的数据块(只有一块)上偏移(偏移C)</p><p>4）在获取到该数据块对应hashtree关联的各个层级的块以及偏移后，接下来就是做一层一层的验证：</p><p>步骤1. 优先验证的是Level 2 中的数据块(只有一个4k的数据块)， 计算这个数据块的hash，跟保存的 root hash进行比对，验证Level 2的数据块块是否正确。</p><p>步骤2. 在Level 2中的数据块得到验证后，由上面计算到的Level 2中数据块上的偏移 C 去校验 Level 1 层的 B 块。</p><p>步骤3. 在 Level 1 层的 B 数据块得到验证后，由上面计算到的 Level 1 中 B 数据块上的偏移B去验证 Level 0 层的 A块。</p><p>步骤4. Level 0层中的 A 数据块得到验证后，最终会由 Level 0 层的偏移A来校验最终的 raw data数据块(第 200000 块).</p><p>可以看到，在使用哈希树的设计之后，对数据块验证整个过程中，涉及到的数据块hash计算只有3块(有N层就计算N块)，相比于一层校验模式，效率要高很多。</p><p><strong>三、应用层面</strong></p><p>读者到目前为止应该大致了解到了移动终端在镜像完整性校验上相关的设计原理，接下来会从应用端层面来说明如何使用 dm-verity 底层提供的接口来初始化 dm 设备，并为后续实时校验做好准备，内核绝大多数功能模块存在的意义都要靠跟应用端的交互来体现，作为对内核某个模块的研究，初步从应用层出发不乏是一个好办法。</p><p>通常系统启动阶段，使用veritysetup工具指定data device和hash device，以及指定的root hash值，hash device的具体位置，hash device通常位于data device的后面一部分。通过veritysetup工具执行后，会生成dm设备，如我们原来使用的文件系统为&#x2F;dev&#x2F;sda3，则此时可以生成一个dm设备为sda3-dm，后续通过mount挂载sda3-dm到&#x2F;sysroot即可实现挂载根文件系统，后续读取根文件系统数据，均会通过sda3-dm设备中转，通过IO定向映射访问&#x2F;dev&#x2F;sda3，并进行hash校验</p><p>如下为veritysetup应用层的3个常规步骤：</p><p>步骤一. Create dm device</p><p>创建 dm 设备主要有如下小步骤：</p><ol><li>open &#x2F;dev&#x2F;device-mapper 设备节点</li><li>传入逻辑分区name、随机生成的uuid参数，调用 DM_DEV_CREATE ioctl 命令</li></ol><p>步骤二. Load verity table</p><p>这里需要引入一个 verity table 的概念，先简单介绍以下 verity table 所包含的内容：</p><p>1）Verity target version(verity target 版本号)</p><p>2）Data block device(存储实际待校验数据的块设备)</p><p>3）Hash block device(存储校验使用到hash的块设备，一般情况跟data block device是同一个)</p><p>4）Data block size(数据块设备的每块存储size)</p><p>5）Hash block size（hash块设备的每块存储size）</p><p>6）Num data block(数据块设备占用的块数量)</p><p>7）Hash start block(hash设备在存储设备的起始位置)</p><p>8）Hash algo(hash算法)</p><p>9）root digest(对应上面说的 root hash)</p><p>10）Salt(用于计算hash的盐值)</p><p>这些信息主要是跟最终数据块在校验计算过程中会被使用到的，比如说 hash 设备的起始位置、hash算法、root hash、salt，这些都在实际运行时校验数据块时会用到，这些信息是存储是镜像的固定位置上，这些信息在编译阶段构建镜像的时候就已经计算好的，并存储在镜像的固定位置。</p><p>Verity table 初始化代码具体如下：</p><p><img src="https://raw.githubusercontent.com/mengchao666/picture/main/blog2fe4aca179fac7a107e2e3d05b9a6732.png"></p><p>上层通过从镜像固定位置获取到信息并初始化好 verity table， 通过调用DM_TABLE_LOAD</p><p>Ioctl 命令将 verity table 传递至kernel。</p><p>步骤三. Active dm device</p><p>调用DM_DEV_SUSPEND ioctl 指令激活 dm device，对应底层，该 cmd 对应 suspend &amp; resume的实现，如果不设置 DM_SUSPEND_FLAG 标志位，默认走 resume 流程。</p><p>应用端在实现上比较简单，主要通过 create -&gt; load verity table -&gt; active dm device 的流程完成了对dm设备的创建、verity table的读取以及传递以及dm设备的激活，为后续实时进行的数据块校验做好了初始化工作。</p><p><strong>四、内核层面</strong></p><p>有了以上应用层面的流程讲解，那对应内核，自然而然就是对每一步应用端的系统调用做对应的内核实现做讲解。</p><p>相应的，内核层面也有以下3个步骤：</p><p>步骤一. dev_create</p><p>对应应用端的DM_DEV_CREATE ioctl cmd，kernel端的大致实现如下：</p><p><img src="https://raw.githubusercontent.com/mengchao666/picture/main/blogccfa2ebd83ceb9f60a306d6bc6ce6b76.png"></p><p>这部分比较简单：</p><p>1). 检测传入参数的partition name是否合法</p><p>2). 开始尝试分配内存初始化 mapped device 结构体以及分配设备minor号（最终用于 dm 设备的设备号，比如 dm-1），使用内核提供的blk_queue_make_request函数注册该mapped device对应的请求队列dm_make_request, 该请求队列最终会在IO重定向中被使用到。并将该mapped device作为磁盘块设备注册到内核中。</p><p>3). 将创建好的mapped device插入到一个全局hash表中，该表中保存了内核中当前创建的所有mapped device。</p><p>步骤二. dm_ctl_ioctl(DM_TABLE_LOAD_CMD(table_load))</p><p>对应应用端的DM_TABLE_LOAD ioctl cmd，kernel端的大致实现可看下面的思维导图：</p><p><img src="https://raw.githubusercontent.com/mengchao666/picture/main/blog4afc7c79fab30f870aed1bd266ea78e8.png"></p><p>总的来说，这个步骤主要是根据入参初始化相应的dm_table、dm_target结构，并且根据参数所指定的target类型，调用相应的target类型的构建函数ctr在内存中构建target device， 在结构上形成 dm_table –&gt; dm_target –&gt; target type –&gt; target device 的链路结构。</p><p>步骤三. dm_ctl_ioctl(DM_DEV_SUSPEND_CMD(dev_suspend))</p><p><img src="https://raw.githubusercontent.com/mengchao666/picture/main/bloge0642548438f6e608b96e333d12f12cd.png"></p><p>很显然，这一个步骤主要是建立 mapped device 与 dm_table 的关联。</p><p>通过以上几个步骤，在内核中就建立一个可以提供给用户使用的mapped device逻辑块设备</p><p>综上涉及到了几个关键的数据结构： mapped device、dm_table、dm_target、target_type、target device(以dm-verity为例)</p><p>其实这几个步骤主要是对上述数据结构进行初始化，并且更重要是互相建立了关联关系。他们之间的关联关系如下：</p><p><img src="https://raw.githubusercontent.com/mengchao666/picture/main/blog08c1b4ed417142d1c73e3a90a6e99bb8.png"></p><p>内核经过了这3个步骤，一方面是创建了一个可以提供给应用端使用的 mapped device 逻辑块设备，另一方面是内部建立了 mapped device - target device 的联系， 应用层可以通过对 mapped device 进行策略逻辑操作，最终会通过 mapped device - target device 的联系作用到 对应的target device 上。</p><p><strong>五、核心数据流</strong></p><p>在上面介绍了dm-verity的设计原理、应用层面以及内核层面的实现之后，读者可能比较关心整个链路的数据流，或者说镜像在校验链路具体流程是如何的，接下来以下主要是围绕着访问镜像文件时的IO流是如何的。</p><p>上面说到，应用层在经过 create -&gt; load verity table -&gt; active dm device 的流程完成了dm块设备的初始化工作，之后应用层会对该逻辑块设备进行文件系统挂载，在挂载的过程中，需要访问到实际存储设备(读取文件系统的super block等)，这个过程中就需要透过这个逻辑块设备，最终操作到与其关联的target device。</p><p>在这个过程中， 对块设备的IO请求会从逻辑设备mapped device转发相应的target device上，并且会根据对应target_type描述的IO处理规则对IO请求进行处理。以本文讨论的 dm-verity 类型的 target device 来说，对于 mapped device 转发过来的IO，会在 hashtree 里找到该 IO data 对应的 hash 数据，并进行比较，完成校验，返回此次的校验结果并结束本次IO请求。</p><p>同时dm-verity通常有两种模式，一般可以通过上述说的veritysetup工具或自研工具指定，两种模式为EIO模式和Loggin模式，EIO模式在校验到数据块的hash不对时直接返回错误，而Loggin模式在校验错误还可以正常使用，Loggin一般为debug使用</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;一、技术模块简介&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Dm-verity 是 device-mapper 架构下的一个目标设备类型， 通过它来保障设备或者设备分区的完整性。&lt;/p&gt;
&lt;p&gt;dm-verity通常用于验证镜像的完整性。比如常规的系统启动的对根文件系</summary>
      
    
    
    
    <category term="dm-verity" scheme="http://example.com/categories/dm-verity/"/>
    
    
    <category term="dm-verity" scheme="http://example.com/tags/dm-verity/"/>
    
  </entry>
  
  <entry>
    <title>98、验证二叉搜索树</title>
    <link href="http://example.com/posts/98%E3%80%81%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html"/>
    <id>http://example.com/posts/98%E3%80%81%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html</id>
    <published>2024-11-17T13:42:49.000Z</published>
    <updated>2024-11-17T14:10:17.359Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</p><p>有效 二叉搜索树定义如下：</p><p>节点的左子树只包含 小于 当前节点的数。<br>节点的右子树只包含 大于 当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。</p><p>示例 1：<br><img src="https://raw.githubusercontent.com/mengchao666/picture/main/blog20241117214340.png"></p><p>输入：root &#x3D; [2,1,3]<br>输出：true</p><p>示例 2：<br><img src="https://raw.githubusercontent.com/mengchao666/picture/main/blog20241117214354.png"></p><p>输入：root &#x3D; [5,1,4,null,null,3,6]<br>输出：false<br>解释：根节点的值是 5 ，但是右子节点的值是 4 。</p><p>提示：</p><p>树中节点数目范围在[1, 10^4] 内<br>-2^31 &lt;&#x3D; Node.val &lt;&#x3D; 2^31 - 1</p><h2 id="二、C语言代码"><a href="#二、C语言代码" class="headerlink" title="二、C语言代码"></a>二、C语言代码</h2><p>根据二叉搜索树的性质，二叉搜索树的中序遍历后，结果为有序且从小到大，所以我们遍历二叉树，将结果保存到数组中，然后判断数组是否有序即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     struct TreeNode *left;</span><br><span class="hljs-comment"> *     struct TreeNode *right;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> TreeNode* root)</span> &#123;<br>    <span class="hljs-type">int</span> returnSize = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> *res = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">10000</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-keyword">if</span> (res == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    traverse(root, res, &amp;returnSize);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; returnSize - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (res[i] &gt;= res[i + <span class="hljs-number">1</span>]) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">traverse</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> TreeNode* root, <span class="hljs-type">int</span> *res, <span class="hljs-type">int</span> *returnSize)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    traverse(root-&gt;left, res, returnSize);<br>    res[*returnSize] = root-&gt;val;<br>    (*returnSize)++;<br>    traverse(root-&gt;right, res, returnSize);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、题目描述&quot;&gt;&lt;a href=&quot;#一、题目描述&quot; class=&quot;headerlink&quot; title=&quot;一、题目描述&quot;&gt;&lt;/a&gt;一、题目描述&lt;/h2&gt;&lt;p&gt;给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。&lt;/p&gt;
&lt;p&gt;有效 二叉搜索树定义如</summary>
      
    
    
    
    <category term="二叉树" scheme="http://example.com/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
    <category term="二叉树" scheme="http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>96、不同的二叉搜索树</title>
    <link href="http://example.com/posts/96%E3%80%81%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html"/>
    <id>http://example.com/posts/96%E3%80%81%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html</id>
    <published>2024-11-17T12:57:49.000Z</published>
    <updated>2024-11-17T14:10:11.572Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。</p><p>示例 1：<br><img src="https://raw.githubusercontent.com/mengchao666/picture/main/blog20241117205823.png"><br>输入：n &#x3D; 3<br>输出：5<br>示例 2：</p><p>输入：n &#x3D; 1<br>输出：1</p><p>提示：<br>1 &lt;&#x3D; n &lt;&#x3D; 19</p><h2 id="二、C-代码"><a href="#二、C-代码" class="headerlink" title="二、C++代码"></a>二、C++代码</h2><p>解法一：</p><p>这种题目，我一般是计算出前面多个例子，根据计算出来的多个例子，进行归纳总结，利用数学归纳法，找规律，推算出第n个的结果，然后利用类似如下方法，根据第0个，第1个，第2个……，以此计算出第n个。</p><p>n&#x3D;1,搜索二叉树种数：1 ,只有一个节点，所以为1</p><p>n&#x3D;2,搜索二叉树种数：2 ,只有二个节点，要么1为根节点，要么2为根节点，所以结果为2</p><p>n&#x3D;3,搜索二叉树种数：5 ,有三个节点<br>(1)、1为根节点，另外两个节点，均大于1，根据二叉搜索树的性质，大于根节点的数字，即另外两个节点2和3只能作为右子树，再作为一个整体，构成二叉搜索树，此时另外两个节点构成结果等同于n&#x3D;2时的结果，为2<br>(2)、2为根节点，根据二叉搜索树性质，1只能作为左子树，3只能作为右子树，只有一种情况，所以结果为1<br>(3)、3为根节点，根据二叉搜索树性质，1和2只能作为左子树,1和2作为一个整体再构成二叉搜索树，此时与(1)一样，结果等于n&#x3D;2时的结果为2<br>所以n&#x3D;3时，搜索二叉树种数为2+1+2&#x3D;5</p><p>n&#x3D;4,搜索二叉树种数：14<br>(1)、1为根节点，另外三个节点，均大于1，另外节点只能作为右子树，其他节点再作为一个整体，构成二叉搜索树，此时另外三个节点构成结果等同于n&#x3D;3时的结果，为5<br>(2)、2为根节点，根据二叉搜索树性质，1只能作为左子树，3,4只能作为右子树，此时进行排列组合，即为n&#x3D;1和n&#x3D;2的结果相乘，为2<br>(3)、3为根节点，结果等于(2)时的结果为2<br>(3)、4为根节点，结果等于(1)时的结果为5</p><p>n&#x3D;5,搜索二叉树种数：42<br>……<br>所以我总结规律为当输入数字为100,结果应该为<code>n=0 * n=99 + n=1 * n=98 + …… + n=99 * n=0</code>, n&#x3D;0时为1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">3</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            res += (<span class="hljs-built_in">numTrees</span>(i) * <span class="hljs-built_in">numTrees</span>(n- <span class="hljs-number">1</span> - i));<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>解法二：<br>解法一比较耗时，所以在解法一基础上进行优化，可以把中间的结果都保存到数组nums中，后续就不需要每次都遍历才拿到结果了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nums</span><span class="hljs-params">(<span class="hljs-number">20</span>, <span class="hljs-number">0</span>)</span></span>;<br>        nums[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">traverse</span>(n, nums);<br>        <span class="hljs-keyword">return</span> nums[n];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">traverse</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (nums[n] != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> nums[n];<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            nums[n] += (<span class="hljs-built_in">traverse</span>(i, nums) * <span class="hljs-built_in">traverse</span>(n- <span class="hljs-number">1</span> - i, nums));<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>解法3：<br>动态规划，后续再写具体思路吧：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">// 二叉搜索数的特征，左子树小于根，右子树大于根</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n<span class="hljs-number">+1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;  <span class="hljs-comment">// dp[0]初始化为1</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)  <span class="hljs-comment">// 从1...n的二叉搜索数数目</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=i; j++)  <span class="hljs-comment">// 逐步选用1...n作为根节点</span><br>                dp[i]+=dp[j<span class="hljs-number">-1</span>]*dp[i-j];  <span class="hljs-comment">// 左侧j-1个数，右侧i-j个数</span><br>        <span class="hljs-keyword">return</span> dp[n]; <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、题目描述&quot;&gt;&lt;a href=&quot;#一、题目描述&quot; class=&quot;headerlink&quot; title=&quot;一、题目描述&quot;&gt;&lt;/a&gt;一、题目描述&lt;/h2&gt;&lt;p&gt;给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足</summary>
      
    
    
    
    <category term="二叉树" scheme="http://example.com/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
    <category term="二叉树" scheme="http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>94、二叉树的中序遍历</title>
    <link href="http://example.com/posts/94%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.html"/>
    <id>http://example.com/posts/94%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.html</id>
    <published>2024-11-17T12:41:04.000Z</published>
    <updated>2024-11-17T14:10:02.309Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个二叉树的根节点root，返回它的中序遍历 。</p><p>示例 1：<br><img src="https://raw.githubusercontent.com/mengchao666/picture/main/blog20241117204222.png"></p><p>输入：root &#x3D; [1,null,2,3]<br>输出：[1,3,2]<br>示例 2：</p><p>输入：root &#x3D; []<br>输出：[]<br>示例 3：</p><p>输入：root &#x3D; [1]<br>输出：[1]</p><p>提示：</p><p>树中节点数目在范围 [0, 100] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100</p><p>进阶: 递归算法很简单，你可以通过迭代算法完成吗？</p><h2 id="二、C语言题解"><a href="#二、C语言题解" class="headerlink" title="二、C语言题解"></a>二、C语言题解</h2><p>递归算法很简单，只需要按照左右根的顺序递归即可，代码如下：<br><strong>不过需要注意的是，leetcode中尽量最好不要使用全局变量吧，因为leetcode网站的题目，所有的用例是共享全局变量的，也就是第一个用例执行完后，第二个用例会继承第一个用例执行后的全局变量的值，导致后续的用例执行失败</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     struct TreeNode *left;</span><br><span class="hljs-comment"> *     struct TreeNode *right;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Note: The returned array must be malloced, assume caller calls free().</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span>* <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> TreeNode* root, <span class="hljs-type">int</span>* returnSize)</span> &#123;<br>    <span class="hljs-type">int</span>* res = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">100</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-keyword">if</span> (res == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    *returnSize = <span class="hljs-number">0</span>;<br><br>    traverse(root, res, returnSize);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">traverse</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> TreeNode* root, <span class="hljs-type">int</span>* res, <span class="hljs-type">int</span>* returnSize)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    traverse(root-&gt;left, res, returnSize);<br>    res[*returnSize] = root-&gt;val;<br>    (*returnSize)++;<br>    traverse(root-&gt;right, res, returnSize);<br>&#125;<br></code></pre></td></tr></table></figure><p>迭代方法：</p><h2 id="三、C-题解"><a href="#三、C-题解" class="headerlink" title="三、C++题解"></a>三、C++题解</h2><p>递归方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-built_in">traverse</span>(root, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(TreeNode* root, vector&lt;<span class="hljs-type">int</span>&gt; &amp;res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-built_in">traverse</span>(root-&gt;left, res);<br>        res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-built_in">traverse</span>(root-&gt;right, res);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、题目描述&quot;&gt;&lt;a href=&quot;#一、题目描述&quot; class=&quot;headerlink&quot; title=&quot;一、题目描述&quot;&gt;&lt;/a&gt;一、题目描述&lt;/h2&gt;&lt;p&gt;给定一个二叉树的根节点root，返回它的中序遍历 。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;br&gt;&lt;img src=&quot;h</summary>
      
    
    
    
    <category term="二叉树" scheme="http://example.com/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
    <category term="二叉树" scheme="http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>二叉树算法核心纲领</title>
    <link href="http://example.com/posts/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%97%E6%B3%95%E6%A0%B8%E5%BF%83%E7%BA%B2%E9%A2%86.html"/>
    <id>http://example.com/posts/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%97%E6%B3%95%E6%A0%B8%E5%BF%83%E7%BA%B2%E9%A2%86.html</id>
    <published>2024-11-17T12:39:53.000Z</published>
    <updated>2024-11-20T15:23:33.350Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、二叉树基本概念"><a href="#一、二叉树基本概念" class="headerlink" title="一、二叉树基本概念"></a>一、二叉树基本概念</h2><p>二叉树<br>二叉搜索树<br>完全二叉树</p><h2 id="二、二叉树的前中后序遍历"><a href="#二、二叉树的前中后序遍历" class="headerlink" title="二、二叉树的前中后序遍历"></a>二、二叉树的前中后序遍历</h2><p>二叉树的前中后序对应的不只是三种顺序不同的列表。前中后序是遍历二叉树过程中处理每一个节点的三个特殊时间点，绝不仅仅是三个顺序不同的 List：<br>前序位置的代码在刚刚进入一个二叉树节点的时候执行；<br>后序位置的代码在将要离开一个二叉树节点的时候执行；<br>中序位置的代码在一个二叉树节点左子树都遍历完，即将开始遍历右子树的时候执行。</p><h2 id="三、二叉树解题的思维方式"><a href="#三、二叉树解题的思维方式" class="headerlink" title="三、二叉树解题的思维方式"></a>三、二叉树解题的思维方式</h2><p>1、是否可以通过遍历一遍二叉树得到答案？如果可以，用一个 traverse 函数配合外部变量来实现，这叫「遍历」的思维模式。</p><p>2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「分解问题」的思维模式。</p><p>无论使用哪种思维模式，你都需要思考：</p><p>如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前&#x2F;中&#x2F;后序位置）做？其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作。</p><h2 id="四、后序位置的特殊之处"><a href="#四、后序位置的特殊之处" class="headerlink" title="四、后序位置的特殊之处"></a>四、后序位置的特殊之处</h2><h2 id="五、二叉树的层序遍历"><a href="#五、二叉树的层序遍历" class="headerlink" title="五、二叉树的层序遍历"></a>五、二叉树的层序遍历</h2><h2 id="六、N叉树"><a href="#六、N叉树" class="headerlink" title="六、N叉树"></a>六、N叉树</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、二叉树基本概念&quot;&gt;&lt;a href=&quot;#一、二叉树基本概念&quot; class=&quot;headerlink&quot; title=&quot;一、二叉树基本概念&quot;&gt;&lt;/a&gt;一、二叉树基本概念&lt;/h2&gt;&lt;p&gt;二叉树&lt;br&gt;二叉搜索树&lt;br&gt;完全二叉树&lt;/p&gt;
&lt;h2 id=&quot;二、二叉树的前中</summary>
      
    
    
    
    <category term="二叉树" scheme="http://example.com/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
    <category term="二叉树" scheme="http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>dd命令</title>
    <link href="http://example.com/posts/dd%E5%91%BD%E4%BB%A4.html"/>
    <id>http://example.com/posts/dd%E5%91%BD%E4%BB%A4.html</id>
    <published>2024-11-17T06:15:34.000Z</published>
    <updated>2024-11-17T06:16:08.278Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>dd命令可以从一个文件或设备向另一个文件或设备进行复制</p></blockquote><h2 id="一、dd命令常用语法"><a href="#一、dd命令常用语法" class="headerlink" title="一、dd命令常用语法"></a>一、dd命令常用语法</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">dd <span class="hljs-attribute">if</span>=input_file <span class="hljs-attribute">of</span>=output_file [options]<br></code></pre></td></tr></table></figure><p>options是一些可选参数，if和of是必须有的</p><ul><li>if 表示输入文件</li><li>of 表示输出文件</li><li>bs：设置每次读取和写入的块大小（单位为字节或者是可以添加的后缀，如b、k、m等），默认为512字节。</li><li>count：设置要复制的块数。</li><li>iflag：设置输入选项，常用的选项有direct（绕过缓存直接读取）和sync（同步数据到磁盘）。</li><li>oflag：设置输出选项，常用的选项有direct（绕过缓存直接写入）和sync（同步数据到磁盘）。</li><li>skip&#x3D;xxx 是在备份时对if 后面的部分也就是原文件跳过多少块再开始备份；</li><li>seek&#x3D;xxx则是在备份时对of 后面的部分也就是目标文件跳过多少块再开始写</li></ul><h2 id="二、dd常用命令-读磁盘"><a href="#二、dd常用命令-读磁盘" class="headerlink" title="二、dd常用命令-读磁盘"></a>二、dd常用命令-读磁盘</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">dd <span class="hljs-keyword">if</span>=/dev/sde1 of=tee-test.img bs=<span class="hljs-number">1</span>M skip=<span class="hljs-number">4</span> count=<span class="hljs-number">16</span><br></code></pre></td></tr></table></figure><p>含义为从&#x2F;dev&#x2F;sde1设备起始位置，跳过4M，读取16M内容到tee-test.img中<br>想要查看tee-test.img，可以使用hexdump命令</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">hexdump -C tee-test.img<br></code></pre></td></tr></table></figure><p>只查看部分内容，例如前100个字节：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">hexdump -C -n <span class="hljs-number">100</span> tee-test.img<br></code></pre></td></tr></table></figure><h2 id="三、dd常用命令-写磁盘"><a href="#三、dd常用命令-写磁盘" class="headerlink" title="三、dd常用命令-写磁盘"></a>三、dd常用命令-写磁盘</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">dd <span class="hljs-attribute">if</span>=/dev/zero <span class="hljs-attribute">of</span>=/dev/sda <span class="hljs-attribute">bs</span>=1k <span class="hljs-attribute">seek</span>=8224 <span class="hljs-attribute">count</span>=32<br></code></pre></td></tr></table></figure><p>含义为从&#x2F;dev&#x2F;zero中也就是将后面的of目标文件写0，将&#x2F;dev&#x2F;sda设备的起始地址，跳过8224KB后，连续写入32KB 0数据</p><h2 id="四、通过fdisk-l确认分区的实际起始地址"><a href="#四、通过fdisk-l确认分区的实际起始地址" class="headerlink" title="四、通过fdisk -l确认分区的实际起始地址"></a>四、通过fdisk -l确认分区的实际起始地址</h2><p>使用<code>fdisk -l</code>显示磁盘分区情况</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap"><span class="hljs-comment"># fdisk -l</span><br><br>Disk /dev/sde: 19.16 GB,<span class="hljs-number"> 20577255424 </span>bytes,<span class="hljs-number"> 5023744 </span>sectors<br>Sector size (logical/physical):<span class="hljs-number"> 4096 </span>bytes /<span class="hljs-number"> 4096 </span>bytes<br><br>  Device  Start     End<br>/dev/sde1  <span class="hljs-number"> 256 </span>    131327<br><br></code></pre></td></tr></table></figure><p>这里显示sde1的起始地址为256，那么实际地址为：<br>256 ✖️ 4096 &#x3D; 1048576 &#x3D; 1024 ✖️ 1024 &#x3D; 1MB，所以sde1的位置为&#x2F;dev&#x2F;sde的起始地址偏移1M，其实起始1M，存放的应该是磁盘分区信息</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;dd命令可以从一个文件或设备向另一个文件或设备进行复制&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一、dd命令常用语法&quot;&gt;&lt;a href=&quot;#一、dd命令常用语法&quot; class=&quot;headerlink&quot; title=&quot;一、dd命令常用语法</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Makefile基础语法</title>
    <link href="http://example.com/posts/Makefile%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.html"/>
    <id>http://example.com/posts/Makefile%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.html</id>
    <published>2024-11-13T13:26:43.000Z</published>
    <updated>2024-11-13T15:54:38.496Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Makefile规则"><a href="#一、Makefile规则" class="headerlink" title="一、Makefile规则"></a>一、Makefile规则</h2><p>一个简单的 Makefile 文件包含一系列的“规则”，其样式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">目标(target)…: 依赖(prerequiries)…<br>&lt;tab&gt;命令(command)<br></code></pre></td></tr></table></figure><p>目标(target)通常是要生成的文件的名称，可以是可执行文件或OBJ文件， 也可以是一个执行的动作名称，诸如‘ <strong>clean</strong> ’。<br>依赖是用来产生目标的材料(比如源文件)，一个目标经常有几个依赖。<br>命令是生成目标时执行的动作，一个规则可以含有几个命令，每个命令占一行。<br><strong>注意</strong>：<br>每个命令行前面必须是一个 Tab 字符，即命令行第一个字符是 Tab。这是容易出错的地方。<br>通常，如果一个依赖发生了变化，就需要规则调用命令以更新或创建目标。 但是并非所有的目标都有依赖，例如，目标“ <strong>clean</strong> ”的作用是清除文件，它有依赖。</p><p>一个 Makefile 文件可以包含规则以外的其他文本，但一个简单的 Makefile 文件仅仅需要包含规则。虽然真正的规则比这里展示的例子复杂，但格式是完全一样的</p><h2 id="二、make命令介绍"><a href="#二、make命令介绍" class="headerlink" title="二、make命令介绍"></a>二、make命令介绍</h2><p>make 命令的使用：</p><p>执行 make 命令时，它会去当前目录下查找名为“Makefile”的文件，并根 据它的指示去执行操作，生成第一个目标。<br>我们可以使用“  <strong>-f</strong> ”选项指定文件，不再使用名为“Makefile”的文件，比 如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make -f Makefile.build<br></code></pre></td></tr></table></figure><p>我们可以使用“  <strong>-C</strong> ”选项指定目录，切换到其他目录里去，比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make -C a/ -f Makefile.build<br></code></pre></td></tr></table></figure><p>我们可以指定目标，不再默认生成第一个目标：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make -C a/ -f Makefile.build other_target<br></code></pre></td></tr></table></figure><h2 id="三、Makefile变量介绍"><a href="#三、Makefile变量介绍" class="headerlink" title="三、Makefile变量介绍"></a>三、Makefile变量介绍</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">A = xxx // 延时变量<br>B ?= xxx // 延时变量，只有第一次定义时赋值才成功；如果曾定义过，此赋值无效<br>C := xxx // 立即变量<br>D += yyy // 如果 D 在前面是延时变量，那么现在它还是延时变量；// 如果 D 在前面是立即变量，那么现在它还是立即变量<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/mengchao666/picture/main/blog20241113232347.png" alt="示例"></p><h2 id="四、Makefile通配符-一些符号"><a href="#四、Makefile通配符-一些符号" class="headerlink" title="四、Makefile通配符&amp;一些符号"></a>四、Makefile通配符&amp;一些符号</h2><p><strong>%通配符</strong></p><ul><li>%.o：表示所用的.o文件%.</li><li>%.c：表示所有的.c文件</li></ul><p><strong>$@：表示目标</strong><br><strong>$&lt;：表示第一个依赖文件</strong><br><strong>$^：表示所有依赖文件</strong></p><p><img src="https://raw.githubusercontent.com/mengchao666/picture/main/blog20241113232528.png" alt="示例代码"><br><img src="https://raw.githubusercontent.com/mengchao666/picture/main/blog20241113232545.png" alt="结果"></p><h2 id="五、Makefile假想目标"><a href="#五、Makefile假想目标" class="headerlink" title="五、Makefile假想目标"></a>五、Makefile假想目标</h2><p>我们的 Makefile 中有这样的目标：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Makefile"><span class="hljs-section">clean:</span><br>  rm -f <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> find -name &quot;\*.o&quot;)</span><br>  rm -f <span class="hljs-variable">$(TARGET)</span><br></code></pre></td></tr></table></figure><p>如果当前目录下恰好有名为“clean”的文件，那么执行“ <strong>make clean</strong> ”时它 就不会执行那些删除命令。<br>这时我们需要把“ <strong>clean</strong> ”这个目标，设置为“假想目标”，这样可以确保执行“ <strong>make clean</strong> ”时那些删除命令肯定可以得到执行。</p><p>使用下面的语句把“clean”设置为假想目标：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Makefile">.PHONY : clean<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/mengchao666/picture/main/blog20241113232733.png"><br><img src="https://raw.githubusercontent.com/mengchao666/picture/main/blog20241113232751.png"></p><h2 id="六、Makefile常用函数"><a href="#六、Makefile常用函数" class="headerlink" title="六、Makefile常用函数"></a>六、Makefile常用函数</h2><h3 id="1-foreach-var-list-text"><a href="#1-foreach-var-list-text" class="headerlink" title="1.$(foreach var,list,text)"></a>1.$(foreach var,list,text)</h3><p>简单地说，就是 for each var in list, change it to text。对 list 中的每一个 元素，取出来赋给 var，然后把 var 改为 text 所描述的形式。</p><h3 id="2-wildcard-pattern"><a href="#2-wildcard-pattern" class="headerlink" title="2.$(wildcard pattern)"></a>2.$(wildcard pattern)</h3><p>pattern 所列出的文件是否存在，把存在的文件都列出来。</p><h3 id="3-filter-pattern…-text"><a href="#3-filter-pattern…-text" class="headerlink" title="3.$(filter pattern…,text)"></a>3.$(filter pattern…,text)</h3><p>把 text 中符合 pattern 格式的内容，filter(过滤)出来、留下来。</p><h3 id="4-filter-out-pattern…-text"><a href="#4-filter-out-pattern…-text" class="headerlink" title="4.$(filter-out pattern…,text)"></a>4.$(filter-out pattern…,text)</h3><p>把 text 中符合 pattern 格式的内容，filter-out(过滤)出来、扔掉。</p><h3 id="5-patsubst-pattern-replacement-text"><a href="#5-patsubst-pattern-replacement-text" class="headerlink" title="5.$(patsubst pattern,replacement,text)"></a>5.$(patsubst pattern,replacement,text)</h3><p>寻找’ <strong>text</strong> ‘中符合格式’ pattern ‘的字，用’ r<strong>eplacement</strong> ‘替换它们。</p><p>‘ <strong>pattern</strong> ‘和’ <strong>replacement</strong> ‘中可以使用通配符。<br><img src="https://raw.githubusercontent.com/mengchao666/picture/main/blog20241113234721.png" alt="代码示例"></p><h2 id="七、Makefile的例子，包含子目录"><a href="#七、Makefile的例子，包含子目录" class="headerlink" title="七、Makefile的例子，包含子目录"></a>七、Makefile的例子，包含子目录</h2><h2 id="八、Makefile中的EXTRA-CFLAGS"><a href="#八、Makefile中的EXTRA-CFLAGS" class="headerlink" title="八、Makefile中的EXTRA_CFLAGS"></a>八、Makefile中的EXTRA_CFLAGS</h2><p>EXTRA_CFLAGS是Makefile中预定义的一个变量，作为CFLGAS，在make时可以传递给gcc一些编译选项等，如—O2</p><h3 id="EXTRA-CFLAGS-D等价于gcc-D，相当于在源代码中定义一个宏"><a href="#EXTRA-CFLAGS-D等价于gcc-D，相当于在源代码中定义一个宏" class="headerlink" title="EXTRA_CFLAGS +&#x3D; -D等价于gcc -D，相当于在源代码中定义一个宏"></a>EXTRA_CFLAGS +&#x3D; -D等价于gcc -D，相当于在源代码中定义一个宏</h3><p>假如定义一个宏CONFIG_DEBUG<br>在.c里面定义为：#define CONFIG_DEBUG<br>在makefile里定义为: CONFIG_DEBUG&#x3D;y</p><p>假如说我们想在makefile里为.c文件进入一个宏定义，就用EXTRA_CFLAGS +&#x3D; DCONFIG_DEBUG( 等价于在.c文件里定义#define CONFIG_DEBUG)</p><p>这时CONFIG_DEBUG&#x3D;y与EXTRA_CFLAGS +&#x3D; DCONFIG_DEBUG的区别应该你已经看出来的，前者是对makefile编译时用的，比如说obj-(CONFIG_DEBUG) +&#x3D; test.o,而后者则是对.c源文件里的用的</p><h2 id="九、Makefile编译内核驱动ko"><a href="#九、Makefile编译内核驱动ko" class="headerlink" title="九、Makefile编译内核驱动ko"></a>九、Makefile编译内核驱动ko</h2><p>内核源代码中obj-m表示以模块ko的方式编译<br>obj-y表示将源代码编译到内核源码中<br>在工作的过程中，经常需要编译一些Ko模块，如果是单个的c文件编译直接在内核源码里面 obj-y&#x3D;xxx.o就好<br>如果这个ko文件需要多个c文件共同编译生成的话，最好以如下的模板来完成编译较好</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">首先指定好编译链工具</span><br>CROSS_COMPILE=/opt/gcc-linaro-7.3.1-2018.05-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-<br><span class="hljs-meta prompt_">#</span><span class="language-bash">指定用哪个内核去编译</span><br>KDIR=/mnt/nfsroot/zhengshuai.zhu/IPCSDK/ipc-sdk-full-release/kernel-4.19<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">目标是编译成一个test.ko文件</span><br>obj-m += test.o<br><span class="hljs-meta prompt_">#</span><span class="language-bash">test.o文件由当前目录下n个c文件编译成</span><br>test-objs += ./*.o<br><span class="hljs-meta prompt_">#</span><span class="language-bash">包含当前目录下的头文件</span><br>INCLUDE_DIRS := $(addprefix -I,$(shell find ../ -type d ))<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">包含当前目录下，内核目录下的头文件</span><br>ccflags-y:= -I$(_KDIR)/include/linux/ -I$(PWD)/platform/<br><span class="hljs-meta prompt_">#</span><span class="language-bash">忽略一些编译警告，类如什么变量未使用</span><br>ccflags-y += -Wno-declaration-after-statement<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">添加c文件中的环境变量，比如在代码中会有</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">ifdef CONFIG_ANDROID</span> <br><span class="hljs-meta prompt_">#</span><span class="language-bash">xxxx</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">endif</span><br>ifeq ($(SYSTEM_VERSION),)<br>    ccflags-y += -DCONFIG_LINUX_OS<br>else<br>    ccflags-y += -DCONFIG_ANDROID<br>endif<br><br>all:<br>  make ARCH=$&#123;ARCH&#125; -C $(KDIR) M=$(PWD) modules<br><br>clean:<br>  make ARCH=$&#123;ARCH&#125; -C $(KDIR) M=$(PWD) clean<br></code></pre></td></tr></table></figure><p><code>make ARCH=$&#123;ARCH&#125; -C ( K D I R ) M = (KDIR) M=(KDIR)M=(PWD) modules</code><br>如何理解这句话?<br>-C的选项可以理解为:<br>进入所指定的位置，$(KDIR)，也就是内核目录中，目的是什么？ 去读取内核目录顶层的Makefile文件，相当于编译的时候 选择一个内核，我要用这个内核去编译。<br>因为你这个目录没有被配置到kernel config里面去，也就是说没有指定用哪个内核版本，有了 -C $(KDIR),就相当于选了内核，如果你选择了kernel-4.19目录下，或者 kernel-5.0目录下，</p><p>M&#x3D;的选项可以理解为:<br>当我选好内核版本后，我用这个 版本的内核 要去编译哪个目录，然后进入$(PWD)目录去编译当前指定的文件，将其编译成ko文件</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、Makefile规则&quot;&gt;&lt;a href=&quot;#一、Makefile规则&quot; class=&quot;headerlink&quot; title=&quot;一、Makefile规则&quot;&gt;&lt;/a&gt;一、Makefile规则&lt;/h2&gt;&lt;p&gt;一个简单的 Makefile 文件包含一系列的“规则”，其样</summary>
      
    
    
    
    <category term="Makefile" scheme="http://example.com/categories/Makefile/"/>
    
    
    <category term="Makefile" scheme="http://example.com/tags/Makefile/"/>
    
  </entry>
  
</feed>
